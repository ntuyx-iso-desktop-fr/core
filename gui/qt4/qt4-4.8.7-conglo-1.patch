diff -Naur qt-everywhere-opensource-src-4.8.7-original/configure qt-everywhere-opensource-src-4.8.7/configure
--- qt-everywhere-opensource-src-4.8.7-original/configure	2015-05-07 14:14:56.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/configure	2017-09-26 08:07:04.650088893 +0000
@@ -7734,7 +7734,7 @@
     *-g++*)
 	# Check gcc's version
 	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
-	    5*|4*|3.4*)
+	    8*|7*|6*|5*|4*|3.4*)
 		;;
             3.3*)
                 canBuildWebKit="no"
@@ -8050,7 +8050,7 @@
     3.*)
         COMPILER_VERSION="3.*"
         ;;
-    5*|4.*)
+    8*|7*|6*|5*|4.*)
         COMPILER_VERSION="4"
         ;;
     *)
diff -Naur qt-everywhere-opensource-src-4.8.7-original/configure.orig qt-everywhere-opensource-src-4.8.7/configure.orig
--- qt-everywhere-opensource-src-4.8.7-original/configure.orig	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/configure.orig	2015-05-07 14:14:56.000000000 +0000
@@ -0,0 +1,9487 @@
+#!/bin/sh
+#############################################################################
+##
+## Copyright (C) 2015 The Qt Company Ltd.
+## Contact: http://www.qt.io/licensing/
+##
+## This file is the build configuration utility of the Qt Toolkit.
+##
+## $QT_BEGIN_LICENSE:LGPL$
+## Commercial License Usage
+## Licensees holding valid commercial Qt licenses may use this file in
+## accordance with the commercial license agreement provided with the
+## Software or, alternatively, in accordance with the terms contained in
+## a written agreement between you and The Qt Company. For licensing terms
+## and conditions see http://www.qt.io/terms-conditions. For further
+## information use the contact form at http://www.qt.io/contact-us.
+##
+## GNU Lesser General Public License Usage
+## Alternatively, this file may be used under the terms of the GNU Lesser
+## General Public License version 2.1 or version 3 as published by the Free
+## Software Foundation and appearing in the file LICENSE.LGPLv21 and
+## LICENSE.LGPLv3 included in the packaging of this file. Please review the
+## following information to ensure the GNU Lesser General Public License
+## requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+## http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+##
+## As a special exception, The Qt Company gives you certain additional
+## rights. These rights are described in The Qt Company LGPL Exception
+## version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+##
+## GNU General Public License Usage
+## Alternatively, this file may be used under the terms of the GNU
+## General Public License version 3.0 as published by the Free Software
+## Foundation and appearing in the file LICENSE.GPL included in the
+## packaging of this file.  Please review the following information to
+## ensure the GNU General Public License version 3.0 requirements will be
+## met: http://www.gnu.org/copyleft/gpl.html.
+##
+## $QT_END_LICENSE$
+##
+#############################################################################
+
+#-------------------------------------------------------------------------------
+# script initialization
+#-------------------------------------------------------------------------------
+
+# the name of this script
+relconf=`basename $0`
+# the directory of this script is the "source tree"
+relpath=`dirname $0`
+relpath=`(cd "$relpath"; /bin/pwd)`
+# the current directory is the "build tree" or "object tree"
+outpath=`/bin/pwd`
+
+#license file location
+LICENSE_FILE="$QT_LICENSE_FILE"
+[ -z "$LICENSE_FILE" ] && LICENSE_FILE="$HOME/.qt-license"
+if [ -f "$LICENSE_FILE" ]; then
+    tr -d '\r' <"$LICENSE_FILE" >"${LICENSE_FILE}.tmp"
+    diff "${LICENSE_FILE}.tmp" "${LICENSE_FILE}" >/dev/null 2>&1 || LICENSE_FILE="${LICENSE_FILE}.tmp"
+fi
+
+# later cache the command line in config.status
+OPT_CMDLINE=`echo $@ | sed "s,-v ,,g; s,-v$,,g"`
+
+# initialize global variables
+QMAKE_SWITCHES=
+QMAKE_VARS=
+QMAKE_CONFIG=
+QTCONFIG_CONFIG=
+QT_CONFIG=
+SUPPORTED=
+QMAKE_VARS_FILE=.qmake.vars
+DEVICE_VARS_FILE=.device.vars
+
+:> "$QMAKE_VARS_FILE"
+:> "$DEVICE_VARS_FILE"
+
+#-------------------------------------------------------------------------------
+# utility functions
+#-------------------------------------------------------------------------------
+
+shellEscape()
+{
+    echo "$@" | sed 's/ /\ /g'
+}
+
+# Adds a new qmake variable to the cache
+# Usage: QMakeVar mode varname contents
+#   where mode is one of: set, add, del
+QMakeVar()
+{
+    case "$1" in
+	set)
+	    eq="="
+	    ;;
+	add)
+	    eq="+="
+	    ;;
+	del)
+	    eq="-="
+	    ;;
+	*)
+	    echo >&2 "BUG: wrong command to QMakeVar: $1"
+	    ;;
+    esac
+
+    echo "$2" "$eq" "$3" >> "$QMAKE_VARS_FILE"
+}
+
+# Helper function for getQMakeConf. It parses include statements in
+# qmake.conf and prints out the expanded file
+getQMakeConf1()
+{
+    while read line; do case "$line" in
+        include*)
+	    inc_file=`echo "$line" | sed -n -e "/^include.*(.*)/s/include.*(\(.*\)).*$/\1/p"`
+	    current_dir=`dirname "$1"`
+	    conf_file="$current_dir/$inc_file"
+	    if [ ! -f  "$conf_file" ]; then
+                echo "WARNING: Unable to find file $conf_file" >&2
+                continue
+            fi
+            getQMakeConf1 "$conf_file"
+        ;;
+        *)
+            echo "$line"
+        ;;
+    esac; done < "$1"
+}
+
+getQMakeConf2()
+{
+    $AWK '
+BEGIN {
+    values["LITERAL_WHITESPACE"] = " "
+    values["LITERAL_DOLLAR"] = "$"
+}
+/^[_A-Z0-9.]+[ \t]*\+?=/ {
+    valStart = index($0, "=") + 1
+
+    append = 0
+    if (substr($0, valStart - 2, 1) == "+") {
+        append = 1
+    }
+
+    variable = substr($0, 0, valStart - 2 - append)
+    value = substr($0, valStart)
+    gsub("[ \t]+", "", variable)
+    gsub("^[ \t]+", "", value)
+    gsub("[ \t]+$", "", value)
+
+    ovalue = ""
+    while (match(value, /\$\$(\{[_A-Z0-9.]+\}|[_A-Z0-9.]+)/)) {
+        ovalue = ovalue substr(value, 1, RSTART - 1)
+        var = substr(value, RSTART + 2, RLENGTH - 2)
+        value = substr(value, RSTART + RLENGTH)
+        if (var ~ /^\{/) {
+            var = substr(var, 2, length(var) - 2)
+        }
+        ovalue = ovalue values[var]
+    }
+    ovalue = ovalue value
+
+    combinedValue = values[variable]
+    if (append == 1 && length(combinedValue) > 0) {
+        combinedValue = combinedValue " " ovalue
+    } else {
+        combinedValue = ovalue
+    }
+    values[variable] = combinedValue
+}
+END {
+    for (var in values) {
+        print var "=" values[var]
+    }
+}
+'
+}
+
+getQMakeConf3()
+{
+    echo "$2" | $AWK "/^($1)=/ { print substr(\$0, index(\$0, \"=\") + 1) }"
+}
+
+# relies on $QMAKESPEC being set correctly. parses include statements in
+# qmake.conf and prints out the expanded file
+getQMakeConf()
+{
+    if [ -z "$specvals" ]; then
+        specvals=`getQMakeConf1 "$QMAKESPEC/qmake.conf" | getQMakeConf2`
+    fi
+    getQMakeConf3 "$1" "$specvals"
+}
+
+getXQMakeConf()
+{
+    if [ -z "$xspecvals" ]; then
+        xspecvals=`getQMakeConf1 "$XQMAKESPEC/qmake.conf" | getQMakeConf2`
+    fi
+    getQMakeConf3 "$1" "$xspecvals"
+}
+
+compilerSupportsFlag()
+{
+    cat >conftest.cpp <<EOF
+int main() { return 0; }
+EOF
+    "$@" -o conftest-out.o conftest.cpp
+    ret=$?
+    rm -f conftest.cpp conftest-out.o
+    return $ret
+}
+
+linkerSupportsFlag()
+{
+    compiler=$1
+    shift
+    lflags=-Wl
+    for flag
+    do
+	safe_flag=`shellEscape "$flag"`
+	lflags=$lflags,$safe_flag
+    done
+    compilerSupportsFlag $compiler $lflags >/dev/null 2>&1
+}
+
+#-------------------------------------------------------------------------------
+# device options
+#-------------------------------------------------------------------------------
+DeviceVar()
+{
+    case "$1" in
+        set)
+            eq="="
+            ;;
+        *)
+            echo >&2 "BUG: wrong command to QMakeVar: $1"
+            ;;
+    esac
+
+    echo "$2" "$eq" "$3" >> "$DEVICE_VARS_FILE"
+}
+
+#-------------------------------------------------------------------------------
+# operating system detection
+#-------------------------------------------------------------------------------
+
+# need that throughout the script
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# detect the "echo without newline" style. usage: echo $ECHO_N "<string>$ECHO_C"
+if echo '\c' | grep '\c' >/dev/null; then
+    ECHO_N=-n
+else
+    ECHO_C='\c'
+fi
+
+#-------------------------------------------------------------------------------
+# window system detection
+#-------------------------------------------------------------------------------
+
+PLATFORM_X11=no
+PLATFORM_QWS=maybe
+PLATFORM_QPA=maybe
+BUILD_ON_MAC=no
+if [ -d /System/Library/Frameworks/Carbon.framework ]; then
+    PLATFORM_MAC=maybe
+    BUILD_ON_MAC=yes
+else
+    PLATFORM_MAC=no
+fi
+
+#-----------------------------------------------------------------------------
+# Qt version detection
+#-----------------------------------------------------------------------------
+QT_VERSION=`grep '^# *define *QT_VERSION_STR' "$relpath"/src/corelib/global/qglobal.h`
+QT_MAJOR_VERSION=
+QT_MINOR_VERSION=0
+QT_PATCH_VERSION=0
+if [ -n "$QT_VERSION" ]; then
+   QT_VERSION=`echo $QT_VERSION | sed 's,^# *define *QT_VERSION_STR *"*\([^ ]*\)"$,\1,'`
+   MAJOR=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\1,'`
+   if [ -n "$MAJOR" ]; then
+     MINOR=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\2,'`
+      PATCH=`echo $QT_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\3,'`
+      QT_MAJOR_VERSION="$MAJOR"
+      [ -z "$MINOR" ] || QT_MINOR_VERSION="$MINOR"
+      [ -z "$PATCH" ] || QT_PATCH_VERSION="$PATCH"
+   fi
+fi
+if [ -z "$QT_MAJOR_VERSION" ]; then
+   echo "Cannot process version from qglobal.h: $QT_VERSION"
+   echo "Cannot proceed."
+   exit 1
+fi
+
+QT_PACKAGEDATE=`grep '^# *define *QT_PACKAGEDATE_STR' "$relpath"/src/corelib/global/qglobal.h | sed -e 's,^# *define *QT_PACKAGEDATE_STR *"\([^ ]*\)"$,\1,' -e s,-,,g`
+if [ -z "$QT_PACKAGEDATE" ]; then
+   echo "Unable to determine package date from qglobal.h: '$QT_PACKAGEDATE'"
+   echo "Cannot proceed"
+   exit 1
+fi
+
+#-------------------------------------------------------------------------------
+# check the license
+#-------------------------------------------------------------------------------
+COMMERCIAL_USER=ask
+CFG_DEV=no
+CFG_NOKIA=no
+CFG_EMBEDDED=no
+CFG_RTOS_ENABLED=yes
+EditionString=Commercial
+
+earlyArgParse()
+{
+    # parse the arguments, setting things to "yes" or "no"
+    while [ "$#" -gt 0 ]; do
+        CURRENT_OPT="$1"
+        UNKNOWN_ARG=no
+        case "$1" in
+        #Autoconf style options
+        --enable-*)
+            VAR=`echo $1 | sed "s,^--enable-\(.*\),\1,"`
+            VAL=yes
+            ;;
+        --disable-*)
+            VAR=`echo $1 | sed "s,^--disable-\(.*\),\1,"`
+            VAL=no
+            ;;
+        --*=*)
+            VAR=`echo $1 | sed "s,^--\(.*\)=.*,\1,"`
+            VAL=`echo $1 | sed "s,^--.*=\(.*\),\1,"`
+            ;;
+        --no-*)
+            VAR=`echo $1 | sed "s,^--no-\(.*\),\1,"`
+            VAL=no
+            ;;
+        -embedded)
+            VAR=embedded
+            # this option may or may not be followed by an argument
+            if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+                VAL=auto
+            else
+                shift;
+                VAL=$1
+            fi
+            ;;
+        -embedded-lite|-qpa)
+            VAR=qpa
+            # this option may or may not be followed by an argument
+            if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+                VAL=auto
+            else
+                shift;
+                VAL=$1
+            fi
+            ;;
+        -nacl)
+            shift;
+            VAR=nacl
+            VAL=$1
+            ;;
+
+        -h|help|--help|-help)
+            if [ "$VAL" = "yes" ]; then
+                OPT_HELP="$VAL"
+                COMMERCIAL_USER="no" #doesn't matter we will display the help
+            else
+                UNKNOWN_OPT=yes
+                COMMERCIAL_USER="no" #doesn't matter we will display the help
+            fi
+            ;;
+        --*)
+            VAR=`echo $1 | sed "s,^--\(.*\),\1,"`
+            VAL=yes
+            ;;
+        -*)
+            VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+            VAL="unknown"
+            ;;
+        *)
+            UNKNOWN_ARG=yes
+            ;;
+        esac
+        if [ "$UNKNOWN_ARG" = "yes" ]; then
+            shift
+            continue
+        fi
+        shift
+
+        UNKNOWN_OPT=no
+        case "$VAR" in
+        embedded)
+            CFG_EMBEDDED="$VAL"
+            PLATFORM_X11=no
+            PLATFORM_MAC=no
+            PLATFORM_QWS=yes
+            PLATFORM_QPA=no
+            ;;
+        qpa)
+            CFG_EMBEDDED="no"
+            if [ "$PLATFORM_QPA" != "no" ]; then
+                if [ "$PLATFORM_QPA" = "maybe" ]; then
+                    PLATFORM_X11=no
+                    PLATFORM_MAC=no
+                    PLATFORM_QWS=no
+                    PLATFORM_QPA=yes
+                fi
+            else
+                echo "No license exists to enable Qt QPA. Disabling."
+                CFG_EMBEDDED=no
+            fi
+            ;;
+        nacl)
+            echo "Using NaCl at $VAL."
+            PLATFORM_X11=no
+            PLATFORM_MAC=no
+            PLATFORM_QWS=no
+            CFG_NACL_PATH=$VAL
+            CFG_EMBEDDED=nacl
+            ;;
+
+        developer-build)
+            CFG_DEV="yes"
+            ;;
+        nokia-developer)
+            CFG_DEV="yes"
+            CFG_NOKIA="yes"
+            COMMERCIAL_USER="no"
+            ;;
+        commercial)
+            COMMERCIAL_USER="yes"
+            ;;
+        opensource)
+            COMMERCIAL_USER="no"
+            ;;
+        *)
+            UNKNOWN_OPT=yes
+            ;;
+        esac
+    done
+}
+
+earlyArgParse "$@"
+
+if [ "$COMMERCIAL_USER" = "ask" ]; then
+    while true; do
+        echo "Which edition of Qt do you want to use ?"
+        echo
+        echo "Type 'c' if you want to use the Commercial Edition."
+        echo "Type 'o' if you want to use the Open Source Edition."
+        echo
+        read commercial
+        echo
+        if [ "$commercial" = "c" ]; then
+            COMMERCIAL_USER="yes"
+            break
+        elif [ "$commercial" = "o" ]; then
+            COMMERCIAL_USER="no"
+            break
+        fi
+    done
+fi
+
+if [ "$CFG_NOKIA" = "yes" ]; then
+    Licensee="Nokia"
+    Edition="NokiaInternalBuild"
+    EditionString="Nokia Internal Build"
+    QT_EDITION="QT_EDITION_OPENSOURCE"
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+elif [ -f "$relpath"/LICENSE.PREVIEW.COMMERCIAL ] && [ $COMMERCIAL_USER = "yes" ]; then
+    # Commercial preview release
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    Licensee="Preview"
+    Edition="Preview"
+    QT_EDITION="QT_EDITION_DESKTOP"
+    LicenseType="Technology Preview"
+elif [ $COMMERCIAL_USER = "yes" ]; then
+    # one of commercial editions
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    [ "$PLATFORM_QPA" = "maybe" ] && PLATFORM_QPA=no
+    [ "$PLATFORM_QWS" = "maybe" ] && PLATFORM_QWS=no
+
+    # read in the license file
+    if [ -f "$LICENSE_FILE" ]; then
+        . "$LICENSE_FILE" >/dev/null 2>&1
+        if [ -z "$LicenseKeyExt" ]; then
+            echo
+            echo "You are using an old license file."
+            echo
+            echo "Please install the license file supplied by The Qt Company,"
+            echo "or install the Qt Open Source Edition if you intend to"
+            echo "develop free software."
+            exit 1
+        fi
+	if [ -z "$Licensee" ]; then
+	    echo
+	    echo "Invalid license key. Please check the license key."
+	    exit 1
+	fi
+    else
+        if [ -z "$LicenseKeyExt" ]; then
+            echo
+            echo $ECHO_N "Please enter your license key: $ECHO_C"
+            read LicenseKeyExt
+            Licensee="Unknown user"
+        fi
+    fi
+
+    # Key verification
+    echo "$LicenseKeyExt" | grep ".....*-....*-....*-....*-.....*-.....*-...." >/dev/null 2>&1 \
+        && LicenseValid="yes" \
+        || LicenseValid="no"
+    if [ "$LicenseValid" != "yes" ]; then
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+    fi
+    ProductCode=`echo $LicenseKeyExt | cut -f 1 -d - | cut -b 1`
+    PlatformCode=`echo $LicenseKeyExt | cut -f 2 -d -`
+    LicenseTypeCode=`echo $LicenseKeyExt | cut -f 3 -d -`
+    LicenseFeatureCode=`echo $LicenseKeyExt | cut -f 4 -d - | cut -b 1`
+
+    # determine which edition we are licensed to use
+    case "$LicenseTypeCode" in
+    F4M)
+        LicenseType="Commercial"
+        case $ProductCode in
+        F)
+            Edition="Universal"
+            QT_EDITION="QT_EDITION_UNIVERSAL"
+            ;;
+        B)
+            Edition="FullFramework"
+            EditionString="Full Framework"
+            QT_EDITION="QT_EDITION_DESKTOP"
+            ;;
+        L)
+            Edition="GUIFramework"
+            EditionString="GUI Framework"
+            QT_EDITION="QT_EDITION_DESKTOPLIGHT"
+            ;;
+        esac
+        ;;
+    Z4M|R4M|Q4M)
+        LicenseType="Evaluation"
+        QMakeVar add DEFINES QT_EVAL
+        case $ProductCode in
+         B)
+            Edition="Evaluation"
+            QT_EDITION="QT_EDITION_EVALUATION"
+            ;;
+        esac
+        ;;
+    esac
+    if [ -z "$LicenseType" -o -z "$Edition" -o -z "$QT_EDITION" ]; then
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+    fi
+
+    # verify that we are licensed to use Qt on this platform
+    LICENSE_EXTENSION=
+    case "$PlatformCode" in
+	*L)
+	    CFG_RTOS_ENABLED=yes
+	    PlatformCode=`echo "$PlatformCode" | sed 'h;y/8NPQRTZ/UCWX9M7/;x;G;s/\(.\)....\(.\)./\1\2/'`
+	    ;;
+	*)
+	    CFG_RTOS_ENABLED=no
+	    PlatformCode=`echo "$PlatformCode" | sed 's/.$//'`
+	    ;;
+    esac
+    ### EMBEDDED_QPA logic missing ###
+    case "$PlatformCode,$PLATFORM_MAC,$PLATFORM_QWS" in
+        X9,* | XC,* | XU,* | XW,* | XM,*)
+            # Qt All-OS
+            LICENSE_EXTENSION="-ALLOS"
+            ;;
+        8M,* | KM,* | S9,* | SC,* | SM,* | SU,* | SW,* | X9,* | XC,* | XU,* | XW,*)
+            # Qt for Embedded Linux
+            LICENSE_EXTENSION="-EMBEDDED"
+            ;;
+        6M,*,no | N7,*,no | N9,*,no | NX,*,no)
+            # Embedded no-deploy
+            LICENSE_EXTENSION="-EMBEDDED"
+            ;;
+        FM,*,no | LM,yes,* | ZM,no,no)
+            # Desktop
+            LICENSE_EXTENSION="-DESKTOP"
+            ;;
+        *)
+            Platform=Linux/X11
+            [ "$PLATFORM_MAC" = "yes" ] && Platform='Mac OS X'
+            [ "$PLATFORM_QWS" = "yes" ] && Platform='Embedded Linux'
+            echo
+            echo "You are not licensed for the $Platform platform."
+            echo
+            echo "Please use contact form at http://www.qt.io/contact-us to upgrade your license to"
+            echo "include the $Platform platform, or install the Qt Open Source Edition"
+            echo "if you intend to develop free software."
+            exit 1
+            ;;
+    esac
+
+    if test -r "$relpath/.LICENSE"; then
+	# Generic, non-final license
+	LICENSE_EXTENSION=""
+	line=`sed 'y/a-z/A-Z/;q' "$relpath"/.LICENSE`
+	case "$line" in
+	    *BETA*)
+		Edition=Beta
+		;;
+	    *TECHNOLOGY?PREVIEW*)
+		Edition=Preview
+		;;
+	    *EVALUATION*)
+		Edition=Evaluation
+		;;
+	    *)
+		echo >&2 "Invalid license files; cannot continue"
+		exit 1
+		;;
+	esac
+	Licensee="$Edition"
+	EditionString="$Edition"
+	QT_EDITION="QT_EDITION_DESKTOP"
+    fi
+
+    case "$LicenseFeatureCode" in
+    B|G|L|Y)
+        # US
+        case "$LicenseType" in
+        Commercial)
+            cp -f "$relpath/.LICENSE${LICENSE_EXTENSION}-US" "$outpath/LICENSE"
+            ;;
+        Evaluation)
+            cp -f "$relpath/.LICENSE-EVALUATION-US" "$outpath/LICENSE"
+            ;;
+        esac
+        ;;
+    2|4|5|F)
+        # non-US
+        case "$LicenseType" in
+        Commercial)
+            cp -f "$relpath/.LICENSE${LICENSE_EXTENSION}" "$outpath/LICENSE"
+            ;;
+        Evaluation)
+            cp -f "$relpath/.LICENSE-EVALUATION" "$outpath/LICENSE"
+            ;;
+        esac
+        ;;
+    *)
+        echo
+        echo "Invalid license key. Please check the license key."
+        exit 1
+        ;;
+    esac
+    case "$LicenseFeatureCode" in
+	4|B|F|Y)
+	    CFG_RTOS_ENABLED=yes
+	    ;;
+	2|5|G|L)
+	    CFG_RTOS_ENABLED=no
+	    ;;
+    esac
+    if [ '!' -f "$outpath/LICENSE" ]; then
+        echo "The LICENSE, LICENSE.GPL3 LICENSE.LGPL file shipped with"
+        echo "this software has disappeared."
+        echo
+        echo "Sorry, you are not licensed to use this software."
+        echo "Try re-installing."
+        echo
+        exit 1
+    fi
+elif [ $COMMERCIAL_USER = "no" ]; then
+    # Open Source edition - may only be used under the terms of the GPL or LGPL.
+    [ "$PLATFORM_MAC" = "maybe" ] && PLATFORM_MAC=yes
+    Licensee="Open Source"
+    Edition="OpenSource"
+    EditionString="Open Source"
+    QT_EDITION="QT_EDITION_OPENSOURCE"
+fi
+
+#-------------------------------------------------------------------------------
+# initalize variables
+#-------------------------------------------------------------------------------
+
+SYSTEM_VARIABLES="RANLIB STRIP OBJDUMP LD CC CXX CFLAGS CXXFLAGS LDFLAGS"
+for varname in $SYSTEM_VARIABLES; do
+    qmakevarname="${varname}"
+    # use LDFLAGS for autoconf compat, but qmake uses QMAKE_LFLAGS
+    if [ "${varname}" = "LDFLAGS" ]; then
+        qmakevarname="LFLAGS"
+    elif [ "${varname}" = "LD" ]; then
+        qmakevarname="LINK"
+    fi
+    cmd=`echo \
+'if [ -n "\$'${varname}'" ]; then
+    QMakeVar set QMAKE_'${qmakevarname}' "\$'${varname}'"
+fi'`
+    eval "$cmd"
+done
+# Use CC/CXX to run config.tests
+mkdir -p "$outpath/config.tests"
+rm -f "$outpath/config.tests/.qmake.cache"
+cp "$QMAKE_VARS_FILE" "$outpath/config.tests/.qmake.cache"
+
+QMakeVar add styles "cde mac motif plastique cleanlooks windows"
+QMakeVar add decorations "default windows styled"
+QMakeVar add mouse-drivers "pc"
+if [ "$UNAME_SYSTEM" = "Linux" ] ; then
+    QMakeVar add gfx-drivers "linuxfb"
+    QMakeVar add mouse-drivers "linuxtp"
+fi
+QMakeVar add kbd-drivers "tty"
+
+if [ "$CFG_DEV" = "yes" ]; then
+    QMakeVar add kbd-drivers "um"
+fi
+
+# QTDIR may be set and point to an old or system-wide Qt installation
+unset QTDIR
+
+# the minimum version of libdbus-1 that we require:
+MIN_DBUS_1_VERSION=0.93
+
+# initalize internal variables
+CFG_CONFIGURE_EXIT_ON_ERROR=yes
+CFG_PROFILE=no
+CFG_EXCEPTIONS=unspecified
+CFG_GUI=auto # (yes|no|auto)
+CFG_SCRIPT=auto # (yes|no|auto)
+CFG_SCRIPTTOOLS=auto # (yes|no|auto)
+CFG_XMLPATTERNS=auto # (yes|no|auto)
+CFG_INCREMENTAL=auto
+CFG_QCONFIG=full
+CFG_DEBUG=auto
+CFG_MYSQL_CONFIG=
+CFG_PSQL_CONFIG=
+CFG_DEBUG_RELEASE=no
+CFG_SHARED=yes
+CFG_SM=auto
+CFG_XSHAPE=auto
+CFG_XSYNC=auto
+CFG_XVIDEO=auto
+CFG_XINERAMA=runtime
+CFG_XFIXES=runtime
+CFG_ZLIB=auto
+CFG_SYMBIAN_DEFFILES=auto
+CFG_S60=auto
+CFG_SQLITE=qt
+CFG_GIF=auto
+CFG_TIFF=auto
+CFG_LIBTIFF=auto
+CFG_PNG=yes
+CFG_LIBPNG=auto
+CFG_JPEG=auto
+CFG_LIBJPEG=auto
+CFG_MNG=auto
+CFG_LIBMNG=auto
+CFG_XCURSOR=runtime
+CFG_XRANDR=runtime
+CFG_XRENDER=auto
+CFG_MITSHM=auto
+CFG_OPENGL=auto
+CFG_OPENVG=auto
+CFG_OPENVG_LC_INCLUDES=no
+CFG_OPENVG_SHIVA=auto
+CFG_OPENVG_ON_OPENGL=auto
+CFG_EGL=no
+CFG_EGL_GLES_INCLUDES=no
+CFG_SSE=auto
+CFG_FONTCONFIG=auto
+CFG_QWS_FREETYPE=auto
+CFG_LIBFREETYPE=auto
+CFG_SQL_AVAILABLE=
+QT_DEFAULT_BUILD_PARTS="libs tools examples demos docs translations"
+CFG_BUILD_PARTS=""
+CFG_NOBUILD_PARTS=""
+CFG_RELEASE_QMAKE=no
+CFG_PHONON=auto
+CFG_PHONON_BACKEND=yes
+CFG_MULTIMEDIA=auto
+CFG_AUDIO_BACKEND=auto
+CFG_SVG=auto
+CFG_DECLARATIVE=auto
+CFG_DECLARATIVE_DEBUG=yes
+CFG_WEBKIT=auto # (yes|no|auto|debug)
+CFG_JAVASCRIPTCORE_JIT=auto
+CFG_STACK_PROTECTOR_STRONG=auto
+
+CFG_GFX_AVAILABLE="linuxfb transformed qvfb vnc multiscreen directfb"
+CFG_GFX_ON="linuxfb multiscreen"
+CFG_GFX_PLUGIN_AVAILABLE=
+CFG_GFX_PLUGIN=
+CFG_GFX_OFF=
+CFG_KBD_AVAILABLE="tty linuxinput qvfb"
+CFG_KBD_ON="tty"    #default, see QMakeVar above
+CFG_MOUSE_AVAILABLE="pc linuxtp linuxinput tslib qvfb"
+CFG_MOUSE_ON="pc linuxtp"   #default, see QMakeVar above
+
+if [ -f "$relpath/src/gui/embedded/qscreenqnx_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} qnx"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} qnx"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} qnx"
+fi
+if [ -f "$relpath/src/gui/embedded/qscreenintegrityfb_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} integrity"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} integrity"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} integrityfb"
+fi
+
+if [ -f "$relpath/src/gui/embedded/qscreenvxworksfb_qws.cpp" ]; then
+    CFG_KBD_AVAILABLE="${CFG_KBD_AVAILABLE} vxworks"
+    CFG_MOUSE_AVAILABLE="${CFG_MOUSE_AVAILABLE} vxworks"
+    CFG_GFX_AVAILABLE="${CFG_GFX_AVAILABLE} vxworksfb"
+fi
+
+CFG_ARCH=
+CFG_HOST_ARCH=
+CFG_KBD_PLUGIN_AVAILABLE=
+CFG_KBD_PLUGIN=
+CFG_KBD_OFF=
+CFG_MOUSE_PLUGIN_AVAILABLE=
+CFG_MOUSE_PLUGIN=
+CFG_MOUSE_OFF=
+CFG_USE_GNUMAKE=no
+CFG_IM=yes
+CFG_DECORATION_AVAILABLE="styled windows default"
+CFG_DECORATION_ON="${CFG_DECORATION_AVAILABLE}" # all on by default
+CFG_DECORATION_PLUGIN_AVAILABLE=
+CFG_DECORATION_PLUGIN=
+CFG_XINPUT=runtime
+CFG_XKB=auto
+CFG_NIS=auto
+CFG_CUPS=auto
+CFG_ICONV=auto
+CFG_DBUS=auto
+CFG_GLIB=auto
+CFG_GSTREAMER=auto
+CFG_QGTKSTYLE=auto
+CFG_QS60STYLE=auto
+CFG_LARGEFILE=auto
+CFG_OPENSSL=auto
+CFG_PTMALLOC=no
+CFG_STL=auto
+CFG_PRECOMPILE=auto
+CFG_SEPARATE_DEBUG_INFO=no
+CFG_SEPARATE_DEBUG_INFO_NOCOPY=no
+CFG_REDUCE_EXPORTS=auto
+CFG_MMX=auto
+CFG_3DNOW=auto
+CFG_SSE=auto
+CFG_SSE2=auto
+CFG_SSE3=auto
+CFG_SSSE3=auto
+CFG_SSE4_1=auto
+CFG_SSE4_2=auto
+CFG_AVX=auto
+CFG_REDUCE_RELOCATIONS=no
+CFG_IPV6=auto
+CFG_NAS=no
+CFG_QWS_DEPTHS=all
+CFG_USER_BUILD_KEY=
+CFG_ACCESSIBILITY=auto
+CFG_QT3SUPPORT=yes
+CFG_ENDIAN=auto
+CFG_HOST_ENDIAN=auto
+CFG_DOUBLEFORMAT=auto
+CFG_ARMFPA=auto
+CFG_IWMMXT=no
+CFG_NEON=auto
+CFG_CLOCK_GETTIME=auto
+CFG_CLOCK_MONOTONIC=auto
+CFG_MREMAP=auto
+CFG_GETADDRINFO=auto
+CFG_IPV6IFNAME=auto
+CFG_GETIFADDRS=auto
+CFG_INOTIFY=auto
+CFG_RPATH=yes
+CFG_FRAMEWORK=auto
+CFG_MAC_ARCHS=
+MAC_CONFIG_TEST_COMMANDLINE=  # used to make the configure tests run with the correct arch's and SDK settings
+CFG_MAC_DWARF2=auto
+CFG_MAC_XARCH=auto
+CFG_MAC_CARBON=no
+CFG_MAC_COCOA=yes
+COMMANDLINE_MAC_CARBON=no
+CFG_MAC_HARFBUZZ=no
+CFG_SXE=no
+CFG_PREFIX_INSTALL=yes
+CFG_SDK=
+D_FLAGS=
+I_FLAGS=
+L_FLAGS=
+RPATH_FLAGS=
+l_FLAGS=
+QCONFIG_FLAGS=
+XPLATFORM=              # This seems to be the QMAKESPEC, like "linux-g++" or "symbian-gcce"
+XPLATFORM_MINGW=no      # Whether target platform is MinGW (win32-g++*)
+XPLATFORM_INTEGRITY=no  # Whether target platform is INTEGRITY (*integrity*)
+XPLATFORM_SYMBIAN=no    # Whether target platform is SYMBIAN (*symbian*)
+XPLATFORM_SYMBIAN_SBSV2=no # Whether target platform is SYMBIAN_SBSV2 (symbian-sbsv2)
+XPLATFORM_QNX=no
+PLATFORM=$QMAKESPEC
+QT_CROSS_COMPILE=no
+OPT_CONFIRM_LICENSE=no
+OPT_SHADOW=maybe
+OPT_FAST=auto
+OPT_VERBOSE=no
+OPT_HELP=
+CFG_SILENT=no
+CFG_GRAPHICS_SYSTEM=default
+CFG_RUNTIME_SYSTEM=
+CFG_ALSA=auto
+CFG_PULSEAUDIO=auto
+CFG_COREWLAN=auto
+CFG_ICD=auto
+CFG_NOPROCESS=no
+CFG_ICU=auto
+CFG_SYSTEM_PROXIES=no
+CFG_SLOG2=auto
+
+# initalize variables used for installation
+QT_INSTALL_PREFIX=
+QT_INSTALL_DOCS=
+QT_INSTALL_HEADERS=
+QT_INSTALL_LIBS=
+QT_INSTALL_BINS=
+QT_INSTALL_PLUGINS=
+QT_INSTALL_IMPORTS=
+QT_INSTALL_DATA=
+QT_INSTALL_TRANSLATIONS=
+QT_INSTALL_SETTINGS=
+QT_INSTALL_EXAMPLES=
+QT_INSTALL_DEMOS=
+QT_HOST_PREFIX=
+
+#flags for SQL drivers
+QT_CFLAGS_PSQL=
+QT_LFLAGS_PSQL=
+QT_CFLAGS_MYSQL=
+QT_LFLAGS_MYSQL=
+QT_LFLAGS_MYSQL_R=
+QT_CFLAGS_SQLITE=
+QT_LFLAGS_SQLITE=
+QT_LFLAGS_ODBC="-lodbc"
+QT_LFLAGS_TDS=
+
+# flags for libdbus-1
+QT_CFLAGS_DBUS=
+QT_LIBS_DBUS=
+
+# flags for Glib (X11 only)
+QT_CFLAGS_GLIB=
+QT_LIBS_GLIB=
+
+# flags for GStreamer (X11 only)
+QT_CFLAGS_GSTREAMER=
+QT_LIBS_GSTREAMER=
+
+# default qpa platform
+QT_QPA_DEFAULT_PLATFORM=
+
+#flag for Symbian fpu settings
+QT_CFLAGS_FPU=
+
+# flags for libconnsettings0 (used for Maemo ICD bearer management plugin)
+QT_CFLAGS_CONNSETTINGS=
+QT_LIBS_CONNSETTINGS=
+
+#-------------------------------------------------------------------------------
+# check SQL drivers, mouse drivers and decorations available in this package
+#-------------------------------------------------------------------------------
+
+# opensource version removes some drivers, so force them to be off
+CFG_SQL_tds=no
+CFG_SQL_oci=no
+CFG_SQL_db2=no
+
+CFG_SQL_AVAILABLE=
+if [ -d "$relpath/src/plugins/sqldrivers" ]; then
+  for a in "$relpath/src/plugins/sqldrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_SQL_AVAILABLE="${CFG_SQL_AVAILABLE} ${base_a}"
+	 eval "CFG_SQL_${base_a}=auto"
+     fi
+  done
+fi
+
+CFG_DECORATION_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/decorations" ]; then
+  for a in "$relpath/src/plugins/decorations/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_DECORATION_PLUGIN_AVAILABLE="${CFG_DECORATION_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_KBD_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/kbddrivers" ]; then
+  for a in "$relpath/src/plugins/kbddrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_KBD_PLUGIN_AVAILABLE="${CFG_KBD_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_MOUSE_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/mousedrivers" ]; then
+  for a in "$relpath/src/plugins/mousedrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_MOUSE_PLUGIN_AVAILABLE="${CFG_MOUSE_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+fi
+
+CFG_GFX_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/gfxdrivers" ]; then
+  for a in "$relpath/src/plugins/gfxdrivers/"*; do
+     if [ -d "$a" ]; then
+	 base_a=`basename "$a"`
+  	 CFG_GFX_PLUGIN_AVAILABLE="${CFG_GFX_PLUGIN_AVAILABLE} ${base_a}"
+     fi
+  done
+  CFG_GFX_OFF="$CFG_GFX_AVAILABLE" # assume all off
+fi
+
+CFG_IMAGEFORMAT_PLUGIN_AVAILABLE=
+if [ -d "$relpath/src/plugins/imageformats" ]; then
+    for a in "$relpath/src/plugins/imageformats/"*; do
+        if [ -d "$a" ]; then
+            base_a=`basename "$a"`
+            CFG_IMAGEFORMAT_PLUGIN_AVAILABLE="${CFG_IMAGEFORMAT_PLUGIN_AVAILABLE} ${base_a}"
+        fi
+    done
+fi
+
+#-------------------------------------------------------------------------------
+# Set Default NaCl options
+#-------------------------------------------------------------------------------
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    echo "Setting NaCl options:"
+    echo "-static"
+    CFG_SHARED=no
+    echo "-qpa nacl"
+    PLATFORM_QPA=yes
+    echo "-fast"
+    OPT_FAST=yes
+    echo "-qconfig nacl"
+    CFG_QCONFIG=nacl
+
+    if [ `uname` = "Linux" ]; then
+        I_FLAGS="$I_FLAGS -I${CFG_NACL_PATH}/toolchain/linux_x86/sdk/nacl-sdk/include"
+        L_FLAGS="$L_FLAGS -I${CFG_NACL_PATH}/toolchain/linux_x86/sdk/nacl-sdk/lib"
+    else
+        I_FLAGS="$I_FLAGS -I${CFG_NACL_PATH}/toolchain/mac_x86/sdk/nacl-sdk/include"
+        L_FLAGS="$L_FLAGS -I${CFG_NACL_PATH}/toolchain/mac_x86/sdk/nacl-sdk/lib"
+    fi
+
+    echo "-no-multimedia -no-webkit -no-phonon -no-nultimedia -no-mediaservices -no-xmlpatterns -no-script -no-sql-sqlite -nomake tests"
+    CFG_MULTIMEDIA=no
+    CFG_WEBKIT=no
+    CFG_PHONON=no
+    CFG_MULTIMEDIA=no
+    CFG_MEDIASERVICES=no
+    CFG_XMLPATTERNS=no
+    CFG_SCRIPT=no
+    CFG_SQLITE=no
+    CFG_SQL_sqlite=no
+    CFG_LIBTIFF=no
+    CFG_NOBUILD_PARTS="$CFG_NOBUILD_PARTS tests"
+    QT_CONFIG="$QT_CONFIG nacl"
+fi
+
+#-------------------------------------------------------------------------------
+# parse command line arguments
+#-------------------------------------------------------------------------------
+
+# parse the arguments, setting things to "yes" or "no"
+while [ "$#" -gt 0 ]; do
+    CURRENT_OPT="$1"
+    UNKNOWN_ARG=no
+    case "$1" in
+    #Autoconf style options
+    --enable-*)
+        VAR=`echo $1 | sed "s,^--enable-\(.*\),\1,"`
+        VAL=yes
+        ;;
+    --disable-*)
+        VAR=`echo $1 | sed "s,^--disable-\(.*\),\1,"`
+        VAL=no
+        ;;
+    --*=*)
+        VAR=`echo $1 | sed "s,^--\(.*\)=.*,\1,"`
+        VAL=`echo $1 | sed "s,^--.*=\(.*\),\1,"`
+        ;;
+    --no-*)
+        VAR=`echo $1 | sed "s,^--no-\(.*\),\1,"`
+        VAL=no
+        ;;
+    --*)
+        VAR=`echo $1 | sed "s,^--\(.*\),\1,"`
+        VAL=yes
+        ;;
+    -system-proxies)
+        VAR=system-proxies
+        VAL=yes
+        ;;
+    -no-system-proxies)
+        VAR=system-proxies
+        VAL=no
+        ;;
+    #Qt plugin options
+    -no-*-*|-plugin-*-*|-qt-*-*)
+        VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        VAL=`echo $1 | sed "s,^-\([^-]*\).*,\1,"`
+        ;;
+    #WebKit options
+    -webkit)
+        VAR="webkit"
+        VAL="yes"
+        ;;
+    -webkit-debug)
+        VAR="webkit"
+        VAL="debug"
+        ;;
+    -no-webkit)
+        VAR="webkit"
+        VAL="no"
+        ;;
+    #Qt style no options
+    -no-*)
+        VAR=`echo $1 | sed "s,^-no-\(.*\),\1,"`
+        VAL=no
+        ;;
+    #Qt style yes options
+    -incremental|-qvfb|-profile|-shared|-static|-sm|-xinerama|-xshape|-xsync|-xinput|-egl|-reduce-exports|-pch|-separate-debug-info|-stl|-freetype|-xcursor|-xfixes|-xrandr|-xrender|-mitshm|-fontconfig|-xkb|-nis|-qdbus|-dbus|-dbus-linked|-glib|-gstreamer|-gtkstyle|-cups|-iconv|-largefile|-h|-help|-v|-verbose|-debug|-release|-fast|-accessibility|-confirm-license|-gnumake|-framework|-qt3support|-debug-and-release|-exceptions|-cocoa|-carbon|-universal|-harfbuzz|-prefix-install|-silent|-armfpa|-optimized-qmake|-dwarf2|-reduce-relocations|-sse|-openssl|-openssl-linked|-ptmalloc|-xmlpatterns|-phonon|-phonon-backend|-multimedia|-audio-backend|-svg|-declarative|-declarative-debug|-javascript-jit|-script|-scripttools|-rpath|-force-pkg-config|-s60|-usedeffiles|-icu)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        VAL=yes
+        ;;
+    #Qt style options that pass an argument
+    -qconfig)
+        if [ "$PLATFORM_QWS" != "yes" -a "$PLATFORM_QPA" != "yes" ]; then
+            echo
+            echo "WARNING: -qconfig is only tested and supported on Qt for Embedded Linux."
+            echo
+        fi
+        CFG_QCONFIG="$VAL"
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        shift
+        VAL=$1
+        ;;
+    -prefix|-docdir|-headerdir|-plugindir|-importdir|-datadir|-libdir|-bindir|-translationdir|-sysconfdir|-examplesdir|-demosdir|-depths|-make|-nomake|-platform|-xplatform|-device-option|-buildkey|-sdk|-arch|-host-arch|-mysql_config|-psql_config|-sysroot)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        shift
+        VAL="$1"
+        ;;
+    #Qt style complex options in one command
+    -enable-*|-disable-*)
+        VAR=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+        VAL=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        ;;
+    #Qt Builtin/System style options
+    -no-*|-system-*|-qt-*)
+        VAR=`echo $1 | sed "s,^-[^-]*-\(.*\),\1,"`
+        VAL=`echo $1 | sed "s,^-\([^-]*\)-.*,\1,"`
+        ;;
+    #Options that cannot be generalized
+    -k|-continue)
+        VAR=fatal_error
+        VAL=no
+        ;;
+    -embedded)
+        VAR=embedded
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=auto
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -embedded-lite|-qpa)
+        VAR=qpa
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=auto
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -nacl)
+        VAR=nacl
+        shift;
+    ;;
+    -opengl)
+        VAR=opengl
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=yes
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -openvg)
+        VAR=openvg
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=yes
+        else
+            shift;
+            VAL=$1
+        fi
+	;;
+    -hostprefix)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=$outpath
+        else
+            shift;
+            VAL=$1
+        fi
+        ;;
+    -host-*-endian)
+        VAR=host_endian
+        VAL=`echo $1 | sed "s,^-.*-\(.*\)-.*,\1,"`
+        ;;
+    -*-endian)
+        VAR=endian
+        VAL=`echo $1 | sed "s,^-\(.*\)-.*,\1,"`
+        ;;
+    -qtnamespace)
+        VAR="qtnamespace"
+        shift
+        VAL="$1"
+        ;;
+    -graphicssystem)
+	VAR="graphicssystem"
+	shift
+	VAL=$1
+	;;
+    -runtimegraphicssystem)
+	VAR="runtimegraphicssystem"
+	shift
+	VAL=$1
+	;;
+    -qtlibinfix)
+        VAR="qtlibinfix"
+        shift
+        VAL="$1"
+        ;;
+    -D?*|-D)
+        VAR="add_define"
+        if [ "$1" = "-D" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-D,,'`
+        fi
+        ;;
+    -fpu)
+        VAR="fpu"
+        # this option may or may not be followed by an argument
+        if [ -z "$2" ] || echo "$2" | grep '^-' >/dev/null 2>&1; then
+            VAL=no
+        else
+            shift
+            VAL=$1
+        fi
+        ;;
+    -I?*|-I)
+        VAR="add_ipath"
+        if [ "$1" = "-I" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-I,,'`
+        fi
+        ;;
+    -L?*|-L)
+        VAR="add_lpath"
+        if [ "$1" = "-L" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-L,,'`
+        fi
+        ;;
+    -R?*|-R)
+        VAR="add_rpath"
+        if [ "$1" = "-R" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-R,,'`
+        fi
+        ;;
+    -l?*)
+        VAR="add_link"
+        VAL=`echo $1 | sed 's,-l,,'`
+        ;;
+    -F?*|-F)
+        VAR="add_fpath"
+        if [ "$1" = "-F" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-F,,'`
+        fi
+        ;;
+    -fw?*|-fw)
+        VAR="add_framework"
+        if [ "$1" = "-fw" ]; then
+            shift
+            VAL="$1"
+        else
+            VAL=`echo $1 | sed 's,-fw,,'`
+        fi
+        ;;
+    -*)
+        VAR=`echo $1 | sed "s,^-\(.*\),\1,"`
+        VAL="unknown"
+        ;;
+    *)
+        UNKNOWN_ARG=yes
+        ;;
+    esac
+    if [ "$UNKNOWN_ARG" = "yes" ]; then
+        echo "$1: unknown argument"
+        OPT_HELP=yes
+        ERROR=yes
+        shift
+        continue
+     fi
+    shift
+
+    UNKNOWN_OPT=no
+    case "$VAR" in
+    qt3support)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_QT3SUPPORT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    accessibility)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ACCESSIBILITY="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    license)
+	LICENSE_FILE="$VAL"
+	;;
+    gnumake)
+        CFG_USE_GNUMAKE="$VAL"
+        ;;
+    mysql_config)
+	CFG_MYSQL_CONFIG="$VAL"
+	;;
+    psql_config)
+        CFG_PSQL_CONFIG="$VAL"
+        ;;
+    prefix)
+        QT_INSTALL_PREFIX="$VAL"
+        ;;
+    hostprefix)
+	QT_HOST_PREFIX="$VAL"
+	;;
+    force-pkg-config)
+        QT_FORCE_PKGCONFIG=yes
+        ;;
+    docdir)
+        QT_INSTALL_DOCS="$VAL"
+        ;;
+    headerdir)
+        QT_INSTALL_HEADERS="$VAL"
+        ;;
+    plugindir)
+        QT_INSTALL_PLUGINS="$VAL"
+        ;;
+    importdir)
+        QT_INSTALL_IMPORTS="$VAL"
+        ;;
+    datadir)
+        QT_INSTALL_DATA="$VAL"
+        ;;
+    libdir)
+        QT_INSTALL_LIBS="$VAL"
+        ;;
+    qtnamespace)
+        QT_NAMESPACE="$VAL"
+        ;;
+    qtlibinfix)
+        QT_LIBINFIX="$VAL"
+        ;;
+    translationdir)
+        QT_INSTALL_TRANSLATIONS="$VAL"
+        ;;
+    sysconfdir|settingsdir)
+        QT_INSTALL_SETTINGS="$VAL"
+        ;;
+    examplesdir)
+        QT_INSTALL_EXAMPLES="$VAL"
+        ;;
+    demosdir)
+        QT_INSTALL_DEMOS="$VAL"
+        ;;
+    qconfig)
+        CFG_QCONFIG="$VAL"
+        ;;
+    sysroot)
+        CFG_SYSROOT="$VAL"
+        ;;
+    bindir)
+        QT_INSTALL_BINS="$VAL"
+        ;;
+    buildkey)
+        CFG_USER_BUILD_KEY="$VAL"
+        ;;
+    sxe)
+	CFG_SXE="$VAL"
+        ;;
+    embedded)
+        CFG_EMBEDDED="$VAL"
+        PLATFORM_X11=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=yes
+        PLATFORM_QPA=no
+        ;;
+    embedded-lite|qpa)
+        CFG_EMBEDDED="no"
+        PLATFORM_X11=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=no
+        PLATFORM_QPA=yes
+        if [ "$VAL" != "auto" ]; then
+            QT_QPA_DEFAULT_PLATFORM="$VAL"
+        fi
+        ;;
+    nacl)
+        ;;
+    sse)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    endian)
+        if [ "$VAL" = "little" ]; then
+            CFG_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$VAL" = "big" ]; then
+            CFG_ENDIAN="Q_BIG_ENDIAN"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    host_endian)
+        if [ "$VAL" = "little" ]; then
+            CFG_HOST_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$VAL" = "big" ]; then
+            CFG_HOST_ENDIAN="Q_BIG_ENDIAN"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    armfpa)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ARMFPA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    depths)
+        CFG_QWS_DEPTHS="$VAL"
+        ;;
+    opengl)
+        if  [ "$VAL" = "auto" ] || [ "$VAL" = "desktop" ] ||
+            [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] ||
+            [ "$VAL" = "es1" ] || [ "$VAL" = "es2" ]; then
+            CFG_OPENGL="$VAL"
+            if  [ "$VAL" = "es1" ] || [ "$VAL" = "es2" ]; then
+                CFG_EGL="yes"
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openvg)
+        if [ "$VAL" = "auto" ] || [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_OPENVG="$VAL"
+            if [ "$CFG_EGL" = "no" ] && [ "$VAL" != "no" ]; then
+                CFG_EGL=auto
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    graphicssystem)
+        if [ "$PLATFORM_QWS" = "yes" ]; then
+            echo "Error: Graphics System plugins are not supported on QWS."
+            echo "   On QWS, the graphics system API is part of the QScreen plugin architecture "
+            echo "   rather than existing as a separate plugin."
+            echo ""
+            UNKNOWN_OPT=yes
+        else
+            if  [ "$VAL" = "opengl" ]; then
+                CFG_GRAPHICS_SYSTEM="opengl"
+            elif [ "$VAL" = "openvg" ]; then
+                CFG_GRAPHICS_SYSTEM="openvg"
+            elif [ "$VAL" = "raster" ]; then
+                CFG_GRAPHICS_SYSTEM="raster"
+            elif [ "$VAL" = "runtime" ]; then
+                CFG_GRAPHICS_SYSTEM="runtime"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+	;;
+    runtimegraphicssystem)
+        if  [ "$VAL" != "runtime" ]; then
+            CFG_RUNTIME_SYSTEM="$VAL"
+        fi
+	;;
+
+    qvfb) # left for commandline compatibility, not documented
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            if [ "$VAL" = "yes" ]; then
+		QMakeVar add gfx-drivers qvfb
+		QMakeVar add kbd-drivers qvfb
+		QMakeVar add mouse-drivers qvfb
+                CFG_GFX_ON="$CFG_GFX_ON qvfb"
+                CFG_KBD_ON="$CFG_KBD_ON qvfb"
+                CFG_MOUSE_ON="$CFG_MOUSE_ON qvfb"
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nomake)
+	CFG_NOBUILD_PARTS="$CFG_NOBUILD_PARTS $VAL"
+        ;;
+    make)
+	CFG_BUILD_PARTS="$CFG_BUILD_PARTS $VAL"
+        ;;
+    x11)
+        PLATFORM_QPA=no
+        PLATFORM_MAC=no
+        PLATFORM_QWS=no
+        PLATFORM_X11=yes
+        ;;
+    sdk)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            CFG_SDK="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+     dwarf2)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MAC_DWARF2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    arch)
+        # if this is a Mac then "windows" probably means
+        # we are cross-compiling for MinGW
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" != "windows" ]; then
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS $VAL"
+        else
+            CFG_ARCH=$VAL
+        fi
+        ;;
+    host-arch)
+        CFG_HOST_ARCH=$VAL
+        ;;
+    universal)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS x86 ppc"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    cocoa)
+#       do nothing - Cocoa is the default.
+        ;;
+    carbon)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_CARBON="$VAL"
+            COMMANDLINE_MAC_CARBON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    harfbuzz)
+        if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_CARBON" != "yes" ] && [ "$VAL" = "yes" ]; then
+            CFG_MAC_HARFBUZZ="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+
+    framework)
+        if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_QPA" = "yes" ]; then
+            CFG_FRAMEWORK="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    profile)
+        if [ "$VAL" = "yes" ]; then
+            CFG_PROFILE=yes
+	    QMakeVar add QMAKE_CFLAGS -pg
+	    QMakeVar add QMAKE_CXXFLAGS -pg
+	    QMakeVar add QMAKE_LFLAGS -pg
+            QMAKE_VARS="$QMAKE_VARS CONFIG+=nostrip"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    exceptions|g++-exceptions)
+        if [ "$VAL" = "no" ]; then
+            CFG_EXCEPTIONS=no
+        elif [ "$VAL" = "yes" ]; then
+            CFG_EXCEPTIONS=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    platform)
+        PLATFORM="$VAL"
+        # keep compatibility with old platform names
+        case $PLATFORM in
+        aix-64)
+            PLATFORM=aix-xlc-64
+            ;;
+        hpux-o64)
+            PLATFORM=hpux-acc-o64
+            ;;
+        hpux-n64)
+            PLATFORM=hpux-acc-64
+            ;;
+        hpux-acc-n64)
+            PLATFORM=hpux-acc-64
+            ;;
+        irix-n32)
+            PLATFORM=irix-cc
+            ;;
+        irix-64)
+            PLATFORM=irix-cc-64
+            ;;
+        irix-cc-n64)
+            PLATFORM=irix-cc-64
+            ;;
+        reliant-64)
+            PLATFORM=reliant-cds-64
+            ;;
+        solaris-64)
+            PLATFORM=solaris-cc-64
+            ;;
+        openunix-cc)
+            PLATFORM=unixware-cc
+            ;;
+        openunix-g++)
+            PLATFORM=unixware-g++
+            ;;
+        unixware7-cc)
+            PLATFORM=unixware-cc
+            ;;
+        unixware7-g++)
+            PLATFORM=unixware-g++
+            ;;
+        macx-g++-64)
+            PLATFORM=macx-g++
+	    NATIVE_64_ARCH=
+            case `uname -p` in
+            i386) NATIVE_64_ARCH="x86_64" ;;
+            powerpc) NATIVE_64_ARCH="ppc64" ;;
+            *)   echo "WARNING: Can't detect CPU architecture for macx-g++-64" ;;
+            esac
+	    if [ ! -z "$NATIVE_64_ARCH" ]; then
+		QTCONFIG_CONFIG="$QTCONFIG_CONFIG $NATIVE_64_ARCH"
+		CFG_MAC_ARCHS="$CFG_MAC_ARCHS $NATIVE_64_ARCH"
+            fi
+            ;;
+        esac
+        ;;
+    xplatform)
+        XPLATFORM="$VAL"
+        case `basename "$XPLATFORM"` in win32-g++*)
+            XPLATFORM_MINGW=yes
+            CFG_RPATH=no
+            CFG_REDUCE_EXPORTS=no
+            ;;
+        esac
+        case "$XPLATFORM" in *integrity*) XPLATFORM_INTEGRITY=yes;; esac
+        case "$XPLATFORM" in *symbian*) XPLATFORM_SYMBIAN=yes;; esac
+        case "$XPLATFORM" in symbian-sbsv2) XPLATFORM_SYMBIAN_SBSV2=yes;; esac
+        case "$XPLATFORM" in *qnx-*|*blackberry-*) XPLATFORM_QNX=yes;; esac
+        ;;
+    device-option)
+        DEV_VAR=`echo $VAL | sed "s,^\(.*\)=.*,\1,"`
+        DEV_VAL=`echo $VAL | sed "s,^.*=\(.*\),\1,"`
+        DeviceVar set $DEV_VAR $DEV_VAL
+        ;;
+    debug-and-release)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_DEBUG_RELEASE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    optimized-qmake)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_RELEASE_QMAKE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    release)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DEBUG=no
+        elif [ "$VAL" = "no" ]; then
+            CFG_DEBUG=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    prefix-install)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+	    CFG_PREFIX_INSTALL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+	;;
+    debug)
+        CFG_DEBUG="$VAL"
+        ;;
+    developer-build|commercial|opensource|nokia-developer)
+        # These switches have been dealt with already
+        ;;
+    static)
+        if [ "$VAL" = "yes" ]; then
+            CFG_SHARED=no
+        elif [ "$VAL" = "no" ]; then
+            CFG_SHARED=yes
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    incremental)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_INCREMENTAL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fatal_error)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_CONFIGURE_EXIT_ON_ERROR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    feature-*)
+            FEATURE=`echo $VAR | sed "s,^[^-]*-\([^-]*\),\1," | tr 'abcdefghijklmnopqrstuvwxyz-' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+            if [ "$VAL" = "no" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_$FEATURE"
+            elif [ "$VAL" = "yes" ] || [ "$VAL" = "unknown" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_$FEATURE"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        ;;
+    shared)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SHARED="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gif)
+        if [ "$VAL" = "no" ]; then
+            CFG_GIF="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sm)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SM="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+
+        ;;
+    xinerama)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XINERAMA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xshape)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XSHAPE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xvideo)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XVIDEO="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xsync)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XSYNC="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xinput)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XINPUT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    egl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_EGL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    stl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_STL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    pch)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PRECOMPILE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    separate-debug-info)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SEPARATE_DEBUG_INFO="$VAL"
+        elif [ "$VAL" = "nocopy" ] ; then
+            CFG_SEPARATE_DEBUG_INFO="yes"
+            CFG_SEPARATE_DEBUG_INFO_NOCOPY="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    reduce-exports)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_REDUCE_EXPORTS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    mmx)
+        if [ "$VAL" = "no" ]; then
+            CFG_MMX="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    3dnow)
+        if [ "$VAL" = "no" ]; then
+            CFG_3DNOW="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse2)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse3)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE3="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    ssse3)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSSE3="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse4.1)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE4_1="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sse4.2)
+        if [ "$VAL" = "no" ]; then
+            CFG_SSE4_2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    avx)
+        if [ "$VAL" = "no" ]; then
+            CFG_AVX="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    iwmmxt)
+	CFG_IWMMXT="yes"
+	;;
+    neon)
+        if [ "$VAL" = "no" ]; then
+            CFG_NEON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    reduce-relocations)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_REDUCE_RELOCATIONS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    freetype)
+        [ "$VAL" = "qt" ] && VAL=yes
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_QWS_FREETYPE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    zlib)
+        [ "$VAL" = "qt" ] && VAL=yes
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_ZLIB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        # No longer supported:
+        #[ "$VAL" = "no" ] && CFG_LIBPNG=no
+        ;;
+    s60)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_S60="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    usedeffiles)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SYMBIAN_DEFFILES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sqlite)
+        if [ "$VAL" = "system" ]; then
+            CFG_SQLITE=system
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libpng)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBPNG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libjpeg)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBJPEG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libmng)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBMNG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    libtiff)
+        [ "$VAL" = "yes" ] && VAL=qt
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ] || [ "$VAL" = "system" ]; then
+            CFG_LIBTIFF="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nas-sound)
+        if [ "$VAL" = "system" ] || [ "$VAL" = "no" ]; then
+            CFG_NAS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xcursor)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XCURSOR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xfixes)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XFIXES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xrandr)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "runtime" ]; then
+            CFG_XRANDR="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xrender)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XRENDER="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    mitshm)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MITSHM="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fontconfig)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_FONTCONFIG="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    xkb)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_XKB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    cups)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_CUPS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    iconv)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ICONV="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    glib)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_GLIB="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    slog2)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SLOG2="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gstreamer)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_GSTREAMER="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gtkstyle)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_QGTKSTYLE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    style-s60)
+        if [ "$VAL" = "qt" ] || [ "$VAL" = "no" ]; then
+            CFG_QS60STYLE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    gui)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_GUI="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_GUI="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    qdbus|dbus)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ] || [ "$VAL" = "linked" ]; then
+            CFG_DBUS="$VAL"
+	elif [ "$VAL" = "runtime" ]; then
+	    CFG_DBUS="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    dbus-linked)
+        if [ "$VAL" = "yes" ]; then
+	    CFG_DBUS="linked"
+	else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    nis)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_NIS="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    largefile)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_LARGEFILE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openssl)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_OPENSSL="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    openssl-linked)
+        if [ "$VAL" = "yes" ]; then
+            CFG_OPENSSL="linked"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    ptmalloc)
+        if [ "$VAL" = "yes" ]; then
+            CFG_PTMALLOC="yes"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+
+    xmlpatterns)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_XMLPATTERNS="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_XMLPATTERNS="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    script)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SCRIPT="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SCRIPT="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    scripttools)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SCRIPTTOOLS="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SCRIPTTOOLS="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    svg)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ]; then
+            CFG_SVG="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_SVG="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    declarative)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DECLARATIVE="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_DECLARATIVE="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+	;;
+    declarative-debug)
+        if [ "$VAL" = "yes" ]; then
+            CFG_DECLARATIVE_DEBUG="yes"
+        else
+            if [ "$VAL" = "no" ]; then
+                CFG_DECLARATIVE_DEBUG="no"
+            else
+                UNKNOWN_OPT=yes
+            fi
+        fi
+        ;;
+    webkit)
+        [ "$VAL" = "auto" ] && VAL="yes"
+        CFG_WEBKIT="$VAL"
+        ;;
+    javascript-jit)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "auto" ] || [ "$VAL" = "no" ]; then 
+            CFG_JAVASCRIPTCORE_JIT="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    confirm-license)
+        if [ "$VAL" = "yes" ]; then
+            OPT_CONFIRM_LICENSE="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    h|help)
+        if [ "$VAL" = "yes" ]; then
+            OPT_HELP="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    sql-*|gfx-*|decoration-*|kbd-*|mouse-*|imageformat-*)
+        # if Qt style options were used, $VAL can be "no", "qt", or "plugin"
+        # if autoconf style options were used, $VAL can be "yes" or "no"
+        [ "$VAL" = "yes" ] && VAL=qt
+        # now $VAL should be "no", "qt", or "plugin"... double-check
+        if [ "$VAL" != "no" ] && [ "$VAL" != "qt" ] && [ "$VAL" != "plugin" ]; then
+            UNKNOWN_OPT=yes
+        fi
+        # now $VAL is "no", "qt", or "plugin"
+        OPT="$VAL"
+        VAL=`echo $VAR | sed "s,^[^-]*-\([^-]*\).*,\1,"`
+        VAR=`echo $VAR | sed "s,^\([^-]*\).*,\1,"`
+
+        # Grab the available values
+        case "$VAR" in
+        sql)
+            avail="$CFG_SQL_AVAILABLE"
+            ;;
+        gfx)
+            avail="$CFG_GFX_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_GFX_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        decoration)
+            avail="$CFG_DECORATION_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_DECORATION_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        kbd)
+            avail="$CFG_KBD_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_KBD_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        mouse)
+            avail="$CFG_MOUSE_AVAILABLE"
+	    if [ "$OPT" = "plugin" ]; then
+		avail="$CFG_MOUSE_PLUGIN_AVAILABLE"
+	    fi
+            ;;
+        imageformat)
+            avail="$CFG_IMAGEFORMAT_PLUGIN_AVAILABLE"
+            if [ "$OPT" != "plugin" ]; then
+                # png is always built in
+                avail="$avail png"
+            fi
+            ;;
+        *)
+            avail=""
+            echo "BUG: Unhandled type $VAR used in $CURRENT_OPT"
+            ;;
+        esac
+
+        # Check that that user's value is available.
+        found=no
+        for d in $avail; do
+            if [ "$VAL" = "$d" ]; then
+                found=yes
+                break
+            fi
+        done
+        [ "$found" = yes ] || ERROR=yes
+
+        if [ "$VAR" = "sql" ]; then
+            # set the CFG_SQL_driver
+            eval "CFG_SQL_$VAL=\$OPT"
+            continue
+        elif [ "$VAR" = "imageformat" ]; then
+            [ "$OPT" = "qt" ] && OPT=yes
+            VAL="`echo $VAL |tr a-z A-Z`"
+            eval "CFG_$VAL=$OPT"
+            continue
+        fi
+
+        if [ "$OPT" = "plugin" ] || [ "$OPT" = "qt" ]; then
+            if [ "$OPT" = "plugin" ]; then
+                [ "$VAR" = "decoration" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "decoration" ] && CFG_DECORATION_ON=`echo "${CFG_DECORATION_ON} " | sed "s,${VAL} ,,g"` && CFG_DECORATION_PLUGIN="$CFG_DECORATION_PLUGIN ${VAL}"
+                [ "$VAR" = "kbd" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "kbd" ] && CFG_KBD_ON=`echo "${CFG_KBD_ON} " | sed "s,${VAL} ,,g"` && CFG_KBD_PLUGIN="$CFG_KBD_PLUGIN ${VAL}"
+                [ "$VAR" = "mouse" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "mouse" ] && CFG_MOUSE_ON=`echo "${CFG_MOUSE_ON} " | sed "s,${VAL} ,,g"` && CFG_MOUSE_PLUGIN="$CFG_MOUSE_PLUGIN ${VAL}"
+                [ "$VAR" = "gfx" ] && QMakeVar del "${VAR}s" "$VAL"
+                [ "$VAR" = "gfx" ] && CFG_GFX_ON=`echo "${CFG_GFX_ON} " | sed "s,${VAL} ,,g"` && CFG_GFX_PLUGIN="${CFG_GFX_PLUGIN} ${VAL}"
+                VAR="${VAR}-${OPT}"
+            else
+                if [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "decoration" ] || [ "$VAR" = "mouse" ]; then
+                    [ "$VAR" = "gfx" ] && CFG_GFX_ON="$CFG_GFX_ON $VAL"
+                    [ "$VAR" = "kbd" ] && CFG_KBD_ON="$CFG_KBD_ON $VAL"
+		    [ "$VAR" = "decoration" ] && CFG_DECORATION_ON="$CFG_DECORATION_ON $VAL"
+                    [ "$VAR" = "mouse" ] && CFG_MOUSE_ON="$CFG_MOUSE_ON $VAL"
+                    VAR="${VAR}-driver"
+                fi
+            fi
+	    QMakeVar add "${VAR}s" "${VAL}"
+        elif [ "$OPT" = "no" ]; then
+            PLUG_VAR="${VAR}-plugin"
+            if [ "$VAR" = "gfx" ] || [ "$VAR" = "kbd" ] || [ "$VAR" = "mouse" ]; then
+                IN_VAR="${VAR}-driver"
+            else
+                IN_VAR="${VAR}"
+            fi
+            [ "$VAR" = "decoration" ] && CFG_DECORATION_ON=`echo "${CFG_DECORATION_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "gfx" ] && CFG_GFX_ON=`echo "${CFG_GFX_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "kbd" ] && CFG_KBD_ON=`echo "${CFG_KBD_ON} " | sed "s,${VAL} ,,g"`
+            [ "$VAR" = "mouse" ] && CFG_MOUSE_ON=`echo "${CFG_MOUSE_ON} " | sed "s,${VAL} ,,g"`
+	    QMakeVar del "${IN_VAR}s" "$VAL"
+	    QMakeVar del "${PLUG_VAR}s" "$VAL"
+        fi
+        if [ "$ERROR" = "yes" ]; then
+           echo "$CURRENT_OPT: unknown argument"
+           OPT_HELP=yes
+        fi
+        ;;
+    v|verbose)
+        if [ "$VAL" = "yes" ]; then
+            if [ "$OPT_VERBOSE" = "$VAL" ]; then            # takes two verboses to turn on qmake debugs
+                QMAKE_SWITCHES="$QMAKE_SWITCHES -d"
+            else
+                OPT_VERBOSE=yes
+            fi
+        elif [ "$VAL" = "no" ]; then
+            if [ "$OPT_VERBOSE" = "$VAL" ] && echo "$QMAKE_SWITCHES" | grep ' -d' >/dev/null 2>&1; then
+                QMAKE_SWITCHES=`echo $QMAKE_SWITCHES | sed "s, -d,,"`
+            else
+                OPT_VERBOSE=no
+            fi
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fast)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            OPT_FAST="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    rpath)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_RPATH="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    add_define)
+        D_FLAGS="$D_FLAGS \"$VAL\""
+        ;;
+    add_ipath)
+        I_FLAGS="$I_FLAGS -I\"${VAL}\""
+        ;;
+    add_lpath)
+        L_FLAGS="$L_FLAGS -L\"${VAL}\""
+        ;;
+    add_rpath)
+        RPATH_FLAGS="$RPATH_FLAGS \"${VAL}\""
+        ;;
+    add_link)
+        l_FLAGS="$l_FLAGS -l\"${VAL}\""
+        ;;
+    add_fpath)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            L_FLAGS="$L_FLAGS -F\"${VAL}\""
+            I_FLAGS="$I_FLAGS -F\"${VAL}\""
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    add_framework)
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+            l_FLAGS="$l_FLAGS -framework \"${VAL}\""
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    silent)
+        CFG_SILENT="$VAL"
+        ;;
+    phonon)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PHONON="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    phonon-backend)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_PHONON_BACKEND="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    multimedia)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_MULTIMEDIA="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    dont-process)
+        CFG_NOPROCESS=yes
+        ;;
+    process)
+        CFG_NOPROCESS=no
+        ;;
+    audio-backend)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_AUDIO_BACKEND="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    fpu)
+       if [ "$VAL" != "no" ]; then
+          QT_CFLAGS_FPU=$VAL
+       fi
+       ;;
+    icu)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_ICU="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    system-proxies)
+        if [ "$VAL" = "yes" ] || [ "$VAL" = "no" ]; then
+            CFG_SYSTEM_PROXIES="$VAL"
+        else
+            UNKNOWN_OPT=yes
+        fi
+        ;;
+    *)
+        UNKNOWN_OPT=yes
+        ;;
+    esac
+    if [ "$UNKNOWN_OPT" = "yes" ]; then
+        echo "${CURRENT_OPT}: invalid command-line switch"
+        OPT_HELP=yes
+        ERROR=yes
+    fi
+done
+
+if [ "$CFG_QCONFIG" != "full" ] && [ "$CFG_QT3SUPPORT" = "yes" ]; then
+    echo "Warning: '-qconfig $CFG_QCONFIG' will disable the qt3support library."
+    CFG_QT3SUPPORT="no"
+fi
+if [ "$CFG_GUI" = "no" ]; then
+    echo "Warning: -no-gui will disable the qt3support library."
+    CFG_QT3SUPPORT="no"
+fi
+
+#disable Qt3Support for Lighthouse
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    CFG_QT3SUPPORT="no"
+fi
+
+# update QT_CONFIG to show our current predefined configuration
+case "$CFG_QCONFIG" in
+minimal|small|medium|large|full)
+    # these are a sequence of increasing functionality
+    for c in minimal small medium large full; do
+        QT_CONFIG="$QT_CONFIG $c-config"
+        [ "$CFG_QCONFIG" = $c ] && break
+    done
+    ;;
+*)
+    # not known to be sufficient for anything
+    if [ '!' -f "$relpath/src/corelib/global/qconfig-${CFG_QCONFIG}.h" ] && [ '!' -f `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` ]; then
+        echo >&2 "Error: configuration file not found:"
+        echo >&2 "  $relpath/src/corelib/global/qconfig-${CFG_QCONFIG}.h"
+        echo >&2 "  or"
+        echo >&2 "  `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"`"
+        OPT_HELP=yes
+    fi
+esac
+
+#-------------------------------------------------------------------------------
+# build tree initialization
+#-------------------------------------------------------------------------------
+
+# where to find which..
+unixtests="$relpath/config.tests/unix"
+mactests="$relpath/config.tests/mac"
+symbiantests="$relpath/config.tests/symbian"
+WHICH="$unixtests/which.test"
+
+PERL=`$WHICH perl 2>/dev/null`
+
+# find out which awk we want to use, prefer gawk, then nawk, then regular awk
+AWK=
+for e in gawk nawk awk; do
+    if "$WHICH" $e >/dev/null 2>&1 && ( $e -f /dev/null /dev/null ) >/dev/null 2>&1; then
+        AWK=$e
+        break
+    fi
+done
+
+# find perl
+PERL="/usr/bin/perl"
+if "$WHICH" perl >/dev/null 2>&1 && ( perl /dev/null ) >/dev/null 2>&1; then
+    PERL=`$WHICH perl`
+fi
+
+### skip this if the user just needs help...
+if [ "$OPT_HELP" != "yes" ]; then
+
+# is this a shadow build?
+if [ "$OPT_SHADOW" = "maybe" ]; then
+    OPT_SHADOW=no
+    if [ "$relpath" != "$outpath" ] && [ '!' -f "$outpath/configure" ]; then
+        if [ -h "$outpath" ]; then
+            [ "$relpath" -ef "$outpath" ] || OPT_SHADOW=yes
+        else
+            OPT_SHADOW=yes
+        fi
+    fi
+fi
+if [ "$OPT_SHADOW" = "yes" ]; then
+    if [ -f "$relpath/.qmake.cache" -o -f "$relpath/src/corelib/global/qconfig.h" -o -f "$relpath/src/corelib/global/qconfig.cpp" ]; then
+        echo >&2 "You cannot make a shadow build from a source tree containing a previous build."
+        echo >&2 "Cannot proceed."
+        exit 1
+    fi
+    [ "$OPT_VERBOSE" = "yes" ] && echo "Performing shadow build..."
+fi
+
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ] && [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    echo
+    echo "WARNING: -debug-and-release is not supported anymore on Qt/X11 and Qt for Embedded Linux"
+    echo "Qt can be built in release mode with separate debug information, so"
+    echo "-debug-and-release is not necessary anymore"
+    echo
+fi
+
+# detect build style
+if [ "$CFG_DEBUG" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" -o "$XPLATFORM_MINGW" = "yes" ]; then
+        CFG_DEBUG_RELEASE=yes
+        CFG_DEBUG=yes
+    elif [ "$CFG_DEV" = "yes" ]; then
+        CFG_DEBUG_RELEASE=no
+        CFG_DEBUG=yes
+    else
+        CFG_DEBUG_RELEASE=no
+        CFG_DEBUG=no
+    fi
+fi
+if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG build_all"
+fi
+
+if [ "$CFG_SILENT" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG silent"
+fi
+
+# if the source tree is different from the build tree,
+# symlink or copy part of the sources
+if [ "$OPT_SHADOW" = "yes" ]; then
+    echo "Preparing build tree..."
+
+    if [ -z "$PERL" ]; then
+        echo
+        echo "You need perl in your PATH to make a shadow build."
+        echo "Cannot proceed."
+        exit 1
+    fi
+
+    [ -d "$outpath/bin" ] || mkdir -p "$outpath/bin"
+
+    # symlink the qmake directory
+    find "$relpath/qmake" | while read a; do
+        my_a=`echo "$a" | sed "s,^${relpath}/,${outpath}/,"`
+        if [ '!' -f "$my_a" ]; then
+            if [ -d "$a" ]; then
+                # directories are created...
+                mkdir -p "$my_a"
+            else
+                a_dir=`dirname "$my_a"`
+                [ -d "$a_dir" ] || mkdir -p "$a_dir"
+                # ... and files are symlinked
+                case `basename "$a"` in
+                *.o|*.d|GNUmakefile*|qmake)
+                    ;;
+                *)
+                    rm -f "$my_a"
+                    ln -s "$a" "$my_a"
+                    ;;
+                esac
+            fi
+        fi
+    done
+
+    # make a syncqt script that can be used in the shadow
+    rm -f "$outpath/bin/syncqt"
+    if [ -x "$relpath/bin/syncqt" ]; then
+        mkdir -p "$outpath/bin"
+        echo "#!/bin/sh" >"$outpath/bin/syncqt"
+        echo "QTDIR=\"$relpath\"; export QTDIR" >>"$outpath/bin/syncqt"
+        echo "perl \"$relpath/bin/syncqt\" -outdir \"$outpath\" \"\$@\"" >>"$outpath/bin/syncqt"
+        chmod 755 "$outpath/bin/syncqt"
+    fi
+
+    for i in elf2e32_qtwrapper createpackage patch_capabilities; do
+        rm -f "$outpath/bin/$i"
+        if [ -x "$relpath/bin/$i" ]; then
+            mkdir -p "$outpath/bin"
+            echo "#!/bin/sh" >"$outpath/bin/$i"
+            echo "QTDIR=\"$relpath\"; export QTDIR" >>"$outpath/bin/$i"
+            echo "\"$relpath/bin/$i\" \"\$@\"" >>"$outpath/bin/$i"
+            chmod 755 "$outpath/bin/$i"
+        fi
+    done
+
+    # symlink the mkspecs directory
+    mkdir -p "$outpath/mkspecs"
+    rm -rf "$outpath"/mkspecs/*
+    ln -s "$relpath"/mkspecs/* "$outpath/mkspecs"
+    rm -f "$outpath/mkspecs/default"
+
+    ShadowMkspecs()
+    {
+        rm -rf "$outpath/mkspecs/$1"
+        find "$relpath/mkspecs/$1" -type d | sed "s,^$relpath,$outpath," | xargs mkdir -p
+        find "$relpath/mkspecs/$1" -type f | sed "s,^$relpath/,," | while read f; do ln -s "$relpath/$f" "$outpath/$f"; done
+    }
+
+    # Special case for mkspecs/features directory.
+    # To be able to place .prf files into a shadow build directory,
+    # we're creating links for files only. The directory structure is reproduced.
+    ShadowMkspecs features
+
+    # The modules dir is special, too.
+    ShadowMkspecs modules
+
+    # symlink the doc directory
+    rm -rf "$outpath/doc"
+    ln -s "$relpath/doc" "$outpath/doc"
+
+    # make sure q3porting.xml can be found
+    mkdir -p "$outpath/tools/porting/src"
+    rm -f "$outpath/tools/porting/src/q3porting.xml"
+    ln -s "$relpath/tools/porting/src/q3porting.xml" "$outpath/tools/porting/src"
+fi
+
+# symlink fonts to be able to run application from build directory
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ] && [ ! -d "${outpath}/lib/fonts" ]; then
+    if [ "$PLATFORM" = "$XPLATFORM" ]; then
+        mkdir -p "${outpath}/lib"
+        ln -s "${relpath}/lib/fonts" "${outpath}/lib/fonts"
+    fi
+fi
+
+if [ "$OPT_FAST" = "auto" ]; then
+   if [ '!' -z "$AWK" ] && [ "$CFG_DEV" = "yes" ]; then
+       OPT_FAST=yes
+   else
+       OPT_FAST=no
+   fi
+fi
+
+# find a make command
+if [ -z "$MAKE" ]; then
+    MAKE=
+    for mk in gmake make; do
+        if "$WHICH" $mk >/dev/null 2>&1; then
+            MAKE=`"$WHICH" $mk`
+            break
+        fi
+    done
+    if [ -z "$MAKE" ]; then
+        echo >&2 "You don't seem to have 'make' or 'gmake' in your PATH."
+        echo >&2 "Cannot proceed."
+        exit 1
+    fi
+    # export MAKE, we need it later in the config.tests
+    export MAKE
+fi
+
+fi ### help
+
+#-------------------------------------------------------------------------------
+# auto-detect all that hasn't been specified in the arguments
+#-------------------------------------------------------------------------------
+
+[ "$PLATFORM_QWS" = "yes" -a "$CFG_EMBEDDED" = "no" ] && CFG_EMBEDDED=auto
+if [ "$CFG_EMBEDDED" != "no" ]; then
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+    Darwin:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/macx-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/macx-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    FreeBSD:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/freebsd-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/freebsd-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    SunOS:5*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/solaris-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/solaris-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    Linux:*)
+        if [ -z "$PLATFORM" ]; then
+            case "$UNAME_MACHINE" in
+            *86)
+                PLATFORM=qws/linux-x86-g++
+                ;;
+            *86_64)
+                PLATFORM=qws/linux-x86_64-g++
+                ;;
+            *)
+                PLATFORM=qws/linux-generic-g++
+                ;;
+            esac
+        fi
+        if [ -z "$XPLATFORM" ]; then
+            if [ "$CFG_EMBEDDED" = "auto" ]; then
+                if [ -n "$CFG_ARCH" ]; then
+                    CFG_EMBEDDED=$CFG_ARCH
+                else
+                    case "$UNAME_MACHINE" in
+                    *86)
+                        CFG_EMBEDDED=x86
+                        ;;
+                    *86_64)
+                        CFG_EMBEDDED=x86_64
+                        ;;
+                    *)
+                        CFG_EMBEDDED=generic
+                        ;;
+                    esac
+                fi
+            fi
+            XPLATFORM="qws/linux-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    QNX:*)
+        [ -z "$PLATFORM" ] && PLATFORM=qws/qnx-generic-g++
+        if [ -z "$XPLATFORM" ]; then
+            [ "$CFG_EMBEDDED" = "auto" ] && CFG_EMBEDDED=generic
+            XPLATFORM="qws/qnx-$CFG_EMBEDDED-g++"
+        fi
+        ;;
+    CYGWIN*:*)
+	if [ -z "$XPLATFORM" ]; then
+		CFG_EMBEDDED=x86
+	fi
+	;;
+    *)
+        echo "Qt for Embedded Linux is not supported on this platform. Disabling."
+        CFG_EMBEDDED=no
+        PLATFORM_QWS=no
+        PLATFORM_QPA=no
+        ;;
+    esac
+fi
+if [ -z "$PLATFORM" ]; then
+    PLATFORM_NOTES=
+    case "$UNAME_SYSTEM:$UNAME_RELEASE" in
+     Darwin:*)
+        if [ "$PLATFORM_MAC" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+          PLATFORM=macx-g++
+        # PLATFORM=macx-xcode
+        else
+          PLATFORM=darwin-g++
+        fi
+        ;;
+     AIX:*)
+        #PLATFORM=aix-g++
+        #PLATFORM=aix-g++-64
+        PLATFORM=aix-xlc
+        #PLATFORM=aix-xlc-64
+        PLATFORM_NOTES="
+            - Also available for AIX: aix-g++ aix-g++-64 aix-xlc-64
+        "
+        ;;
+     GNU:*)
+        PLATFORM=hurd-g++
+        ;;
+     dgux:*)
+        PLATFORM=dgux-g++
+        ;;
+#     DYNIX/ptx:4*)
+#       PLATFORM=dynix-g++
+#       ;;
+     ULTRIX:*)
+        PLATFORM=ultrix-g++
+        ;;
+     FreeBSD:*)
+        PLATFORM=freebsd-g++
+        PLATFORM_NOTES="
+            - Also available for FreeBSD: freebsd-icc
+        "
+        ;;
+     OpenBSD:*)
+        PLATFORM=openbsd-g++
+        ;;
+     NetBSD:*)
+        PLATFORM=netbsd-g++
+        ;;
+     BSD/OS:*|BSD/386:*)
+        PLATFORM=bsdi-g++
+        ;;
+     IRIX*:*)
+        #PLATFORM=irix-g++
+        PLATFORM=irix-cc
+        #PLATFORM=irix-cc-64
+        PLATFORM_NOTES="
+            - Also available for IRIX: irix-g++ irix-cc-64
+        "
+        ;;
+     HP-UX:*)
+        case "$UNAME_MACHINE" in
+            ia64)
+                #PLATFORM=hpuxi-acc-32
+                PLATFORM=hpuxi-acc-64
+                PLATFORM_NOTES="
+                    - Also available for HP-UXi: hpuxi-acc-32
+                "
+            ;;
+            *)
+                #PLATFORM=hpux-g++
+                PLATFORM=hpux-acc
+                #PLATFORM=hpux-acc-64
+                #PLATFORM=hpux-cc
+                #PLATFORM=hpux-acc-o64
+                PLATFORM_NOTES="
+                    - Also available for HP-UX: hpux-g++ hpux-acc-64 hpux-acc-o64
+                "
+            ;;
+        esac
+        ;;
+     OSF1:*)
+        #PLATFORM=tru64-g++
+        PLATFORM=tru64-cxx
+        PLATFORM_NOTES="
+            - Also available for Tru64: tru64-g++
+        "
+        ;;
+     Linux:*)
+        PLATFORM=linux-g++
+        PLATFORM_NOTES="
+            - Also available for Linux: linux-kcc linux-icc linux-cxx
+        "
+        ;;
+     SunOS:5*)
+        if [ "$XPLATFORM_MINGW" = "yes" ]; then
+            PLATFORM="solaris-g++"
+        else
+            #PLATFORM=solaris-g++
+            PLATFORM=solaris-cc
+            #PLATFORM=solaris-cc64
+        fi
+        PLATFORM_NOTES="
+            - Also available for Solaris: solaris-g++ solaris-cc-64
+        "
+        ;;
+     ReliantUNIX-*:*|SINIX-*:*)
+        PLATFORM=reliant-cds
+        #PLATFORM=reliant-cds-64
+        PLATFORM_NOTES="
+            - Also available for Reliant UNIX: reliant-cds-64
+        "
+        ;;
+     CYGWIN*:*)
+        PLATFORM=cygwin-g++
+        ;;
+     LynxOS*:*)
+        PLATFORM=lynxos-g++
+        ;;
+     OpenUNIX:*)
+        #PLATFORM=unixware-g++
+        PLATFORM=unixware-cc
+        PLATFORM_NOTES="
+            - Also available for OpenUNIX: unixware-g++
+        "
+        ;;
+     UnixWare:*)
+        #PLATFORM=unixware-g++
+        PLATFORM=unixware-cc
+        PLATFORM_NOTES="
+            - Also available for UnixWare: unixware-g++
+        "
+        ;;
+     SCO_SV:*)
+        #PLATFORM=sco-g++
+        PLATFORM=sco-cc
+        PLATFORM_NOTES="
+            - Also available for SCO OpenServer: sco-g++
+        "
+        ;;
+     UNIX_SV:*)
+        PLATFORM=unixware-g++
+        ;;
+     QNX:*)
+        PLATFORM=unsupported/qnx-g++
+        ;;
+     *)
+        if [ "$OPT_HELP" != "yes" ]; then
+            echo
+            for p in $PLATFORMS; do
+                echo "    $relconf $* -platform $p"
+            done
+            echo >&2
+            echo "   The build script does not currently recognize all" >&2
+            echo "   platforms supported by Qt." >&2
+            echo "   Rerun this script with a -platform option listed to" >&2
+            echo "   set the system/compiler combination you use." >&2
+            echo >&2
+            exit 2
+        fi
+    esac
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    CFG_SM=no
+    PLATFORMS=`find "$relpath/mkspecs/qws" | sed "s,$relpath/mkspecs/qws/,,"`
+else
+    PLATFORMS=`find "$relpath/mkspecs/" -type f | grep -v qws | sed "s,$relpath/mkspecs/qws/,,"`
+fi
+
+[ -z "$XPLATFORM" ] && XPLATFORM="$PLATFORM"
+
+case `basename "$XPLATFORM"` in win32-g++*) XPLATFORM_MINGW=yes;; esac
+case "$XPLATFORM" in *integrity*) XPLATFORM_INTEGRITY=yes;; esac
+case "$XPLATFORM" in *symbian*) XPLATFORM_SYMBIAN=yes;; esac
+case "$XPLATFORM" in symbian-sbsv2) XPLATFORM_SYMBIAN_SBSV2=yes;; esac
+case "$XPLATFORM" in *qnx-*|*blackberry-*) XPLATFORM_QNX=yes;; esac
+
+if [ -d "$PLATFORM" ]; then
+  QMAKESPEC="$PLATFORM"
+else
+  QMAKESPEC="$relpath/mkspecs/${PLATFORM}"
+fi
+if [ -d "$XPLATFORM" ]; then
+  XQMAKESPEC="$XPLATFORM"
+else
+  XQMAKESPEC="$relpath/mkspecs/${XPLATFORM}"
+fi
+if [ "$PLATFORM" != "$XPLATFORM" ]; then
+    QT_CROSS_COMPILE=yes
+    QMAKE_CONFIG="$QMAKE_CONFIG cross_compile"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG cross_compile"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+   if [ `basename $QMAKESPEC` = "macx-xcode" ] || [ `basename $XQMAKESPEC` = "macx-xcode" ]; then
+      echo >&2
+      echo "   Platform 'macx-xcode' should not be used when building Qt/Mac." >&2
+      echo "   Please build Qt/Mac with 'macx-g++', then if you would like to" >&2
+      echo "   use mac-xcode on your application code it can link to a Qt/Mac" >&2
+      echo "   built with 'macx-g++'" >&2
+      echo >&2
+      exit 2
+    fi
+fi
+
+# check specified platforms are supported
+if [ '!' -d "$QMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "      $QMAKESPEC"
+    echo
+    echo "   Please see the README file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -d "$XQMAKESPEC" ]; then
+    echo
+    echo "   The specified system/compiler is not supported:"
+    echo
+    echo "      $XQMAKESPEC"
+    echo
+    echo "   Please see the README file for a complete list."
+    echo
+    exit 2
+fi
+if [ '!' -f "${XQMAKESPEC}/qplatformdefs.h" ]; then
+    echo
+    echo "   The specified system/compiler port is not complete:"
+    echo
+    echo "      $XQMAKESPEC/qplatformdefs.h"
+    echo
+    echo "   Please use the contact form at http://www.qt.io/contact-us"
+    echo
+    exit 2
+fi
+
+# now look at the configs and figure out what platform we are config'd for
+[ "$CFG_EMBEDDED" = "no" ] && [ "$PLATFORM_QPA" != "yes" ] \
+  && [ -n "`getXQMakeConf QMAKE_LIBS_X11`" ] \
+  && PLATFORM_X11=yes
+### echo "$XQMAKESPEC" | grep mkspecs/qws >/dev/null 2>&1 && PLATFORM_QWS=yes
+
+if [ "$UNAME_SYSTEM" = "SunOS" ]; then
+    # Solaris 2.5 and 2.6 have libposix4, which was renamed to librt for Solaris 7 and up
+    if echo $UNAME_RELEASE | grep "^5\.[5|6]" >/dev/null 2>&1; then
+        sed -e "s,-lrt,-lposix4," "$XQMAKESPEC/qmake.conf" > "$XQMAKESPEC/qmake.conf.new"
+        mv "$XQMAKESPEC/qmake.conf.new" "$XQMAKESPEC/qmake.conf"
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# determine the system architecture
+#-------------------------------------------------------------------------------
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo "Determining system architecture... ($UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_MACHINE)"
+fi
+
+if [ "$CFG_EMBEDDED" != "no" -a "$CFG_EMBEDDED" != "auto" ] && [ -n "$CFG_ARCH" ]; then
+    if [ "$CFG_ARCH" != "$CFG_EMBEDDED" ]; then
+        echo ""
+        echo "You have specified a target architecture with -embedded and -arch."
+        echo "The two architectures you have specified are different, so we can"
+        echo "not proceed. Either set both to be the same, or only use -embedded."
+        echo ""
+        exit 1
+    fi
+fi
+
+if [ "$CFG_RTOS_ENABLED" = "no" ]; then
+    case `basename "$XPLATFORM"` in
+	qnx-* | vxworks-*)
+            echo ""
+            echo "You are not licensed for Qt for `basename $XPLATFORM`."
+            echo ""
+            echo "Please use the contact form at http://www.qt.io/contact-us"
+            echo "to upgrade your license to include this platform, or install"
+            echo "the Qt Open Source Edition if you intend to develop free software."
+            exit 1
+	    ;;
+    esac
+fi
+
+if [ -z "${CFG_HOST_ARCH}" ]; then
+    case "$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_MACHINE" in
+    GNU:*:*)
+        CFG_HOST_ARCH=`echo ${UNAME_MACHINE} | sed -e 's,[-/].*$,,'`
+        case "$CFG_HOST_ARCH" in
+            i?86)
+                CFG_HOST_ARCH=i386
+                ;;
+        esac
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    GNU/Hurd ($CFG_HOST_ARCH)"
+        fi
+        ;;
+    IRIX*:*:*)
+        CFG_HOST_ARCH=`uname -p`
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    SGI ($CFG_HOST_ARCH)"
+        fi
+        ;;
+    SunOS:5*:*)
+        case "$UNAME_MACHINE" in
+	sun4u*|sun4v*)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    Sun SPARC (sparc)"
+            fi
+            CFG_HOST_ARCH=sparc
+            ;;
+        i86pc)
+	    case "$PLATFORM" in
+	    *-64*)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+	            echo "    64-bit AMD 80x86 (x86_64)"
+                fi
+                CFG_HOST_ARCH=x86_64
+                ;;
+	    *)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+	            echo "    32-bit Intel 80x86 (i386)"
+                fi
+                CFG_HOST_ARCH=i386
+                ;;
+            esac
+        esac
+        ;;
+    Darwin:*:*)
+        case "$UNAME_MACHINE" in
+            Power?Macintosh)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+                    echo "    32-bit Apple PowerPC (powerpc)"
+                fi
+                ;;
+            x86)
+                if [ "$OPT_VERBOSE" = "yes" ]; then
+                    echo "    32-bit Intel 80x86 (i386)"
+                fi
+                ;;
+        esac
+        CFG_HOST_ARCH=macosx
+        ;;
+    AIX:*:00????????00)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    64-bit IBM PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    HP-UX:*:9000*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    HP PA-RISC (parisc)"
+        fi
+        CFG_HOST_ARCH=parisc
+        ;;
+    *:*:i?86)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    32-bit Intel 80x86 (i386)"
+        fi
+        CFG_HOST_ARCH=i386
+        ;;
+    *:*:x86_64|*:*:amd64)
+        if [ "$PLATFORM" = "linux-g++-32" -o "$PLATFORM" = "linux-icc-32" ]; then
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    32 bit on 64-bit AMD 80x86 (i386)"
+            fi
+            CFG_HOST_ARCH=i386
+        else
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    64-bit AMD 80x86 (x86_64)"
+            fi
+            CFG_HOST_ARCH=x86_64
+        fi
+        ;;
+    *:*:ppc)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    32-bit PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    *:*:ppc64*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    64-bit PowerPC (powerpc)"
+        fi
+        CFG_HOST_ARCH=powerpc
+        ;;
+    *:*:s390*)
+    	if [ "$OPT_VERBOSE" = "yes" ]; then
+    	    echo "    IBM S/390 (s390)"
+    	fi
+    	CFG_HOST_ARCH=s390
+    	;;
+    *:*:aarch64*|*:*:arm64*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    AArch64 (aarch64)"
+        fi
+        CFG_HOST_ARCH=aarch64
+        ;;
+    *:*:arm*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    ARM (arm)"
+        fi
+        CFG_HOST_ARCH=arm
+        ;;
+    Linux:*:sparc*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    Linux on SPARC"
+        fi
+        CFG_HOST_ARCH=sparc
+        ;;
+    QNX:*:*)
+        case "$UNAME_MACHINE" in
+        x86pc)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "    QNX on Intel 80x86 (i386)"
+            fi
+            CFG_HOST_ARCH=i386
+            ;;
+        esac
+        ;;
+    *:*:*)
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    Trying '$UNAME_MACHINE'..."
+        fi
+        CFG_HOST_ARCH="$UNAME_MACHINE"
+        ;;
+    esac
+fi
+
+if [ "$PLATFORM" != "$XPLATFORM" -a "$CFG_EMBEDDED" != "no" ]; then
+    if [ -n "$CFG_ARCH" ]; then
+        CFG_EMBEDDED=$CFG_ARCH
+    fi
+
+    case "$CFG_EMBEDDED" in
+    x86)
+        CFG_ARCH=i386
+        ;;
+    x86_64)
+        CFG_ARCH=x86_64
+        ;;
+    ipaq|sharp)
+        CFG_ARCH=arm
+        ;;
+    dm7000)
+        CFG_ARCH=powerpc
+        ;;
+    dm800)
+        CFG_ARCH=mips
+        ;;
+    sh4al)
+        CFG_ARCH=sh4a
+        ;;
+    arm*)
+        CFG_ARCH=arm
+        ;;
+    *)
+        CFG_ARCH="$CFG_EMBEDDED"
+        ;;
+    esac
+elif [ "$XPLATFORM_MINGW" = "yes" ]; then
+    [ -z "$CFG_ARCH" ] && CFG_ARCH="windows"
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    CFG_ARCH=integrity
+elif [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    CFG_ARCH=symbian
+elif [ "$PLATFORM_MAC" = "yes" ] || [ -z "$CFG_ARCH" ]; then
+    CFG_ARCH=$CFG_HOST_ARCH
+fi
+
+# for compatibility
+COMPAT_ARCH=
+case "$CFG_ARCH" in
+arm*)
+    # previously, armv6 was a different arch
+    CFG_ARCH=arm
+    COMPAT_ARCH=armv6
+    ;;
+esac
+
+if [ -d "$relpath/src/corelib/arch/$CFG_ARCH" ]; then
+    if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    '$CFG_ARCH' is supported"
+    fi
+else
+    if [ "$OPT_VERBOSE" = "yes" ]; then
+        echo "    '$CFG_ARCH' is unsupported, using 'generic'"
+    fi
+    CFG_ARCH=generic
+fi
+if [ "$CFG_HOST_ARCH" != "$CFG_ARCH" ]; then
+    if [ -d "$relpath/src/corelib/arch/$CFG_HOST_ARCH" ]; then
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    '$CFG_HOST_ARCH' is supported"
+        fi
+    else
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            echo "    '$CFG_HOST_ARCH' is unsupported, using 'generic'"
+        fi
+        CFG_HOST_ARCH=generic
+    fi
+fi
+
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo "System architecture: '$CFG_ARCH'"
+    if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+	echo "Host architecture: '$CFG_HOST_ARCH'"
+    fi
+fi
+
+#-------------------------------------------------------------------------------
+# tests that don't need qmake (must be run before displaying help)
+#-------------------------------------------------------------------------------
+
+# process CFG_MAC_ARCHS
+if [ "$PLATFORM_MAC" = "yes" ]; then
+#   check -arch arguments for validity.
+    ALLOWED="x86 ppc x86_64 ppc64 i386 arm armv6 armv7"
+    # Save the list so we can re-write it using only valid values
+    CFG_MAC_ARCHS_IN="$CFG_MAC_ARCHS"
+    CFG_MAC_ARCHS=
+    for i in $CFG_MAC_ARCHS_IN
+    do 
+        if echo "$ALLOWED" | grep -w -v "$i" > /dev/null 2>&1; then
+            echo "Unknown architecture: \"$i\". Supported architectures: x86[i386] ppc x86_64 ppc64 arm armv6 armv7";
+            exit 2;
+        fi
+        if [ "$i" = "i386" -o "$i" = "x86" ]; then
+            # These are synonymous values
+            # CFG_MAC_ARCHS requires x86 while GCC requires i386
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS x86"
+            MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -arch i386"
+        else
+            CFG_MAC_ARCHS="$CFG_MAC_ARCHS $i"
+            MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -arch $i"
+        fi
+    done
+fi
+
+# pass on $CFG_SDK to the configure tests.
+if [ '!' -z "$CFG_SDK" ]; then
+    MAC_CONFIG_TEST_COMMANDLINE="$MAC_CONFIG_TEST_COMMANDLINE -sdk $CFG_SDK"
+fi
+
+# find the default framework value
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$PLATFORM" != "macx-xlc" ]; then
+    if [ "$CFG_FRAMEWORK" = "auto" ]; then
+        CFG_FRAMEWORK="$CFG_SHARED"
+    elif [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_SHARED" = "no" ]; then
+	echo
+	echo "WARNING: Using static linking will disable the use of Mac frameworks."
+	echo
+        CFG_FRAMEWORK="no"
+    fi
+else
+    CFG_FRAMEWORK=no
+fi
+
+QMAKE_CONF_COMPILER=`getXQMakeConf QMAKE_CXX`
+TEST_COMPILER="$CXX"
+
+[ -z "$TEST_COMPILER" ] && TEST_COMPILER=$QMAKE_CONF_COMPILER
+if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    #for Symbian we don't need this checking
+    if [ -z "$TEST_COMPILER" ]; then
+        echo "ERROR: Cannot set the compiler for the configuration tests"
+        exit 1
+    fi
+fi
+
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    TEST_COMPILER="nacl-gcc"
+fi
+
+SYSROOT_FLAG=
+if [ -n "$CFG_SYSROOT" ]; then
+    if compilerSupportsFlag $TEST_COMPILER -c --sysroot="$CFG_SYSROOT"; then
+	[ "$OPT_VERBOSE" = "yes" ] && echo "Setting sysroot to: $CFG_SYSROOT"
+	SYSROOT_FLAG="--sysroot=$CFG_SYSROOT"
+    else
+	echo >&2 "The compiler doesn't support the --sysroot flag, I can't set the sysroot"
+	exit 1
+    fi
+fi
+export SYSROOT_FLAG    # used by config.tests/unix/compile.test
+
+# auto-detect precompiled header support
+if [ "$CFG_PRECOMPILE" = "auto" ]; then
+    if [ `echo "$CFG_MAC_ARCHS" | wc -w` -gt 1 ]; then
+       CFG_PRECOMPILE=no
+    elif "$unixtests/precomp.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+       CFG_PRECOMPILE=no
+    else
+       CFG_PRECOMPILE=yes
+    fi
+elif [ "$CFG_PRECOMPILE" = "yes" ] && [ `echo "$CFG_MAC_ARCHS" | wc -w` -gt 1 ]; then
+    echo
+    echo "WARNING: Using universal binaries disables precompiled headers."
+    echo
+    CFG_PRECOMPILE=no
+fi
+
+if [ "$XPLATFORM_MINGW" = "yes" ]; then
+    CFG_MAC_DWARF2=no
+    CFG_MAC_XARCH=no
+fi
+
+#auto-detect DWARF2 on the mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_DWARF2" = "auto" ]; then
+    if "$mactests/dwarf2.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests" $MAC_CONFIG_TEST_COMMANDLINE; then
+        CFG_MAC_DWARF2=no
+    else
+        CFG_MAC_DWARF2=yes
+    fi
+fi
+
+# auto-detect support for -Xarch on the mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_XARCH" = "auto" ]; then
+    if "$mactests/xarch.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests" ; then
+        CFG_MAC_XARCH=no
+    else
+        CFG_MAC_XARCH=yes
+    fi
+fi
+
+# don't autodetect support for separate debug info on objcopy when
+# cross-compiling as lots of toolchains seems to have problems with this
+if [ "$QT_CROSS_COMPILE" = "yes" ] && [ "$CFG_SEPARATE_DEBUG_INFO" = "auto" ]; then
+    CFG_SEPARATE_DEBUG_INFO="no"
+fi
+
+# auto-detect support for separate debug info in objcopy
+if [ "$CFG_SEPARATE_DEBUG_INFO" != "no" ] && [ "$CFG_SHARED" = "yes" ]; then
+    TEST_COMPILER_CFLAGS=`getXQMakeConf QMAKE_CFLAGS`
+    TEST_COMPILER_CXXFLAGS=`getXQMakeConf QMAKE_CXXFLAGS`
+    TEST_OBJCOPY=`getXQMakeConf QMAKE_OBJCOPY`
+    COMPILER_WITH_FLAGS="$TEST_COMPILER $TEST_COMPILER_CXXFLAGS"
+    COMPILER_WITH_FLAGS=`echo "$COMPILER_WITH_FLAGS" | sed -e "s%\\$\\$QMAKE_CFLAGS%$TEST_COMPILER_CFLAGS%g"`
+    if "$unixtests/objcopy.test" "$COMPILER_WITH_FLAGS" "$TEST_OBJCOPY" "$OPT_VERBOSE"; then
+       CFG_SEPARATE_DEBUG_INFO=no
+    else
+       case "$PLATFORM" in
+       hpux-*)
+           # binutils on HP-UX is buggy; default to no.
+           CFG_SEPARATE_DEBUG_INFO=no
+           ;;
+       *)
+           CFG_SEPARATE_DEBUG_INFO=yes
+           ;;
+       esac
+    fi
+fi
+
+# auto-detect -fvisibility support
+if [ "$CFG_REDUCE_EXPORTS" = "auto" ]; then
+    if "$unixtests/fvisibility.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+       CFG_REDUCE_EXPORTS=no
+    else
+       CFG_REDUCE_EXPORTS=yes
+    fi
+fi
+
+# auto-detect -fstack-protector-strong support (for QNX only currently)
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    if compilerSupportsFlag $TEST_COMPILER -fstack-protector-strong; then
+       CFG_STACK_PROTECTOR_STRONG=yes
+    else
+       CFG_STACK_PROTECTOR_STRONG=no
+    fi
+else
+   CFG_STACK_PROTECTOR_STRONG=no
+fi
+
+# detect the availability of the -Bsymbolic-functions linker optimization
+if [ "$CFG_REDUCE_RELOCATIONS" != "no" ]; then
+    if "$unixtests/bsymbolic_functions.test" "$TEST_COMPILER" "$OPT_VERBOSE"; then
+        CFG_REDUCE_RELOCATIONS=no
+    else
+        CFG_REDUCE_RELOCATIONS=yes
+    fi
+fi
+
+# auto-detect GNU make support
+if [ "$CFG_USE_GNUMAKE" = "auto" ] && "$MAKE" -v | grep "GNU Make" >/dev/null 2>&1; then
+   CFG_USE_GNUMAKE=yes
+fi
+
+# If -opengl wasn't specified, don't try to auto-detect
+if [ "$PLATFORM_QWS" = "yes" ] && [ "$CFG_OPENGL" = "auto" ]; then
+        CFG_OPENGL=no
+fi
+
+# mac
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        CFG_OPENGL=desktop
+    fi
+fi
+
+# find the default framework value
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$PLATFORM" != "macx-xlc" ]; then
+    if [ "$CFG_FRAMEWORK" = "auto" ]; then
+        CFG_FRAMEWORK="$CFG_SHARED"
+    elif [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_SHARED" = "no" ]; then
+	echo
+	echo "WARNING: Using static linking will disable the use of Mac frameworks."
+	echo
+        CFG_FRAMEWORK="no"
+    fi
+else
+    CFG_FRAMEWORK=no
+fi
+
+# Print a warning if configure was called with the 10.4u SDK option on Snow Leopard
+# with the default mkspec. The 10.4u SDK does not support gcc 4.2.
+if [ "$PLATFORM_MAC" = "yes" ] && [ '!' -z "$CFG_SDK" ]; then
+    # get the darwin version. 10.0.0 and up means snow leopard.
+    VERSION=`uname -r | tr '.' ' ' | awk '{print $1}'`
+    if [ "$VERSION" -gt 9 ] && [ `basename "$CFG_SDK"` == "MacOSX10.4u.sdk" ] && [ "$PLATFORM" == "macx-g++" ]; then
+        echo
+        echo "WARNING: The 10.4u SDK does not support gcc 4.2. Configure with -platform macx-g++40. "
+        echo
+    fi
+fi
+
+# x11 tests are done after qmake is built
+
+
+#setup the build parts
+if [ -z "$CFG_BUILD_PARTS" ]; then
+    CFG_BUILD_PARTS="$QT_DEFAULT_BUILD_PARTS"
+
+    # don't build tools by default when cross-compiling
+    if [ "$PLATFORM" != "$XPLATFORM" ]; then
+	CFG_BUILD_PARTS=`echo "$CFG_BUILD_PARTS" | sed "s, tools,,g"`
+    fi
+fi
+for nobuild in $CFG_NOBUILD_PARTS; do
+    CFG_BUILD_PARTS=`echo "$CFG_BUILD_PARTS" | sed "s, $nobuild,,g"`
+done
+if echo $CFG_BUILD_PARTS | grep -v libs >/dev/null 2>&1; then
+#    echo
+#    echo "WARNING: libs is a required part of the build."
+#    echo
+    CFG_BUILD_PARTS="$CFG_BUILD_PARTS libs"
+fi
+
+#-------------------------------------------------------------------------------
+# post process QT_INSTALL_* variables
+#-------------------------------------------------------------------------------
+
+#prefix
+if [ -z "$QT_INSTALL_PREFIX" ]; then
+    if [ "$CFG_DEV" = "yes" ]; then
+        QT_INSTALL_PREFIX="$outpath" # In Development, we use sandboxed builds by default
+    elif [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+        if [ "$PLATFORM_QPA" = "yes" ]; then
+	QT_INSTALL_PREFIX="/usr/local/Trolltech/QtLighthouse-${QT_VERSION}"
+        else
+	QT_INSTALL_PREFIX="/usr/local/Trolltech/QtEmbedded-${QT_VERSION}"
+        fi
+        if [ "$PLATFORM" != "$XPLATFORM" ]; then
+            case "$XPLATFORM" in
+            *dkm*)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}-dkm" # VxWorks DKM
+                ;;
+            *rtp*)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}-rtp" # VxWorks RTP
+                ;;
+            *)
+                QT_INSTALL_PREFIX="${QT_INSTALL_PREFIX}-${CFG_ARCH}"
+                ;;
+            esac
+        fi
+    elif [ -d "$EPOCROOT" ] && [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+            QT_INSTALL_PREFIX="$EPOCROOT/epoc32/"
+            QT_INSTALL_LIBS="$EPOCROOT/epoc32/release/armv5/lib/"
+        fi
+    else
+        QT_INSTALL_PREFIX="/usr/local/Trolltech/Qt-${QT_VERSION}" # the default install prefix is /usr/local/Trolltech/Qt-$QT_VERSION
+    fi
+fi
+QT_INSTALL_PREFIX=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_PREFIX"`
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    [ -z "$QT_HOST_PREFIX" ] && QT_HOST_PREFIX="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS=
+    [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS=
+    [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS=
+    [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS=
+    [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="\\\\resource\\\\qt$QT_LIBINFIX\\\\plugins"
+    [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="\\\\resource\\\\qt$QT_LIBINFIX\\\\imports"
+    [ -z "$QT_INSTALL_DATA" ] && QT_INSTALL_DATA=
+    [ -z "$QT_INSTALL_TRANSLATIONS" ] && QT_INSTALL_TRANSLATIONS="\\\\resource\\\\qt$QT_LIBINFIX\\\\translations"
+    [ -z "$QT_INSTALL_SETTINGS" ] && QT_INSTALL_SETTINGS=
+    [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES=
+    [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS=
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    [ -z "$QT_HOST_PREFIX" ] && QT_HOST_PREFIX="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS="$QT_INSTALL_PREFIX/doc"
+    [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS="$QT_INSTALL_PREFIX/include"
+    [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS="$QT_INSTALL_PREFIX/lib"
+    [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS="$QT_INSTALL_PREFIX/bin"
+    [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="$QT_INSTALL_PREFIX/plugins"
+    [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="$QT_INSTALL_PREFIX/imports"
+    [ -z "$QT_INSTALL_DATA" ] && QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_TRANSLATIONS" ] && QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+    [ -z "$QT_INSTALL_SETTINGS" ] && QT_INSTALL_SETTINGS="$QT_INSTALL_PREFIX"
+    [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES="$QT_INSTALL_PREFIX/examples"
+    [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS="$QT_INSTALL_PREFIX/demos"
+else
+    #docs
+    if [ -z "$QT_INSTALL_DOCS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_DOCS="/Developer/Documentation/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS="$QT_INSTALL_PREFIX/doc" #fallback
+
+    fi
+    QT_INSTALL_DOCS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DOCS"`
+
+    #headers
+    if [ -z "$QT_INSTALL_HEADERS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        if [ "$CFG_FRAMEWORK" = "yes" ]; then
+		    QT_INSTALL_HEADERS=
+                fi
+            fi
+        fi
+        [ -z "$QT_INSTALL_HEADERS" ] && QT_INSTALL_HEADERS="$QT_INSTALL_PREFIX/include"
+
+    fi
+    QT_INSTALL_HEADERS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_HEADERS"`
+
+    #libs
+    if [ -z "$QT_INSTALL_LIBS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        if [ "$CFG_FRAMEWORK" = "yes" ]; then
+                   QT_INSTALL_LIBS="/Library/Frameworks"
+                fi
+            fi
+        fi
+        [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS="$QT_INSTALL_PREFIX/lib" #fallback
+    fi
+    QT_INSTALL_LIBS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_LIBS"`
+
+    #bins
+    if [ -z "$QT_INSTALL_BINS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_BINS="/Developer/Applications/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_BINS" ] && QT_INSTALL_BINS="$QT_INSTALL_PREFIX/bin" #fallback
+
+    fi
+    QT_INSTALL_BINS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_BINS"`
+
+    #plugins
+    if [ -z "$QT_INSTALL_PLUGINS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_PLUGINS="/Developer/Applications/Qt/plugins"
+            fi
+        fi
+        [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="$QT_INSTALL_PREFIX/plugins" #fallback
+    fi
+    QT_INSTALL_PLUGINS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_PLUGINS"`
+
+    #imports
+    if [ -z "$QT_INSTALL_IMPORTS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_IMPORTS="/Developer/Applications/Qt/imports"
+            fi
+        fi
+        [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="$QT_INSTALL_PREFIX/imports" #fallback
+    fi
+    QT_INSTALL_IMPORTS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_IMPORTS"`
+
+    #data
+    if [ -z "$QT_INSTALL_DATA" ]; then #default
+        QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+    fi
+    QT_INSTALL_DATA=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DATA"`
+
+    #translations
+    if [ -z "$QT_INSTALL_TRANSLATIONS" ]; then #default
+        QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+    fi
+    QT_INSTALL_TRANSLATIONS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_TRANSLATIONS"`
+
+    #settings
+    if [ -z "$QT_INSTALL_SETTINGS" ]; then #default
+        if [ "$PLATFORM_MAC" = "yes" ]; then
+	    QT_INSTALL_SETTINGS=/Library/Preferences/Qt
+        else
+	    QT_INSTALL_SETTINGS=/etc/xdg
+        fi
+    fi
+    QT_INSTALL_SETTINGS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_SETTINGS"`
+
+    #examples
+    if [ -z "$QT_INSTALL_EXAMPLES" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_EXAMPLES="/Developer/Examples/Qt"
+            fi
+        fi
+        [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES="$QT_INSTALL_PREFIX/examples" #fallback
+    fi
+    QT_INSTALL_EXAMPLES=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_EXAMPLES"`
+
+    #demos
+    if [ -z "$QT_INSTALL_DEMOS" ]; then #default
+        if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+	    if [ "$PLATFORM_MAC" = "yes" ]; then
+	        QT_INSTALL_DEMOS="/Developer/Examples/Qt/Demos"
+            fi
+        fi
+        [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS="$QT_INSTALL_PREFIX/demos"
+    fi
+    QT_INSTALL_DEMOS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DEMOS"`
+fi
+
+#-------------------------------------------------------------------------------
+# help - interactive parts of the script _after_ this section please
+#-------------------------------------------------------------------------------
+
+# next, emit a usage message if something failed.
+if [ "$OPT_HELP" = "yes" ]; then
+    [ "x$ERROR" = "xyes" ] && echo
+    if [ "$CFG_NIS" = "no" ]; then
+        NSY=" "
+        NSN="*"
+    else
+        NSY="*"
+        NSN=" "
+    fi
+    if [ "$CFG_CUPS" = "no" ]; then
+        CUY=" "
+        CUN="*"
+    else
+        CUY="*"
+        CUN=" "
+    fi
+    if [ "$CFG_ICONV" = "no" ]; then
+        CIY=" "
+        CIN="*"
+    else
+        CIY="*"
+        CIN=" "
+    fi
+    if [ "$CFG_LARGEFILE" = "no" ]; then
+        LFSY=" "
+        LFSN="*"
+    else
+        LFSY="*"
+        LFSN=" "
+    fi
+    if [ "$CFG_STL" = "auto" ] || [ "$CFG_STL" = "yes" ]; then
+        SHY="*"
+        SHN=" "
+    else
+        SHY=" "
+        SHN="*"
+    fi
+    if [ "$CFG_IPV6" = "auto" ]; then
+        I6Y="*"
+        I6N=" "
+    fi
+    if [ "$CFG_PRECOMPILE" = "auto" ] || [ "$CFG_PRECOMPILE" = "no" ]; then
+        PHY=" "
+        PHN="*"
+    else
+        PHY="*"
+        PHN=" "
+    fi
+
+    cat <<EOF
+Usage:  $relconf [-h] [-prefix <dir>] [-prefix-install] [-bindir <dir>] [-libdir <dir>]
+        [-docdir <dir>] [-headerdir <dir>] [-plugindir <dir> ] [-importdir <dir>] [-datadir <dir>]
+        [-translationdir <dir>] [-sysconfdir <dir>] [-examplesdir <dir>]
+        [-demosdir <dir>] [-buildkey <key>] [-release] [-debug]
+        [-debug-and-release] [-developer-build] [-shared] [-static] [-no-fast] [-fast] [-no-largefile]
+        [-largefile] [-no-exceptions] [-exceptions] [-no-accessibility]
+        [-accessibility] [-no-stl] [-stl] [-no-sql-<driver>] [-sql-<driver>]
+        [-plugin-sql-<driver>] [-system-sqlite] [-no-qt3support] [-qt3support]
+        [-platform] [-D <string>] [-I <string>] [-L <string>] [-help]
+        [-qt-zlib] [-system-zlib] [-no-gif] [-no-libtiff] [-qt-libtiff] [-system-libtiff]
+        [-no-libpng] [-qt-libpng] [-system-libpng] [-no-libmng] [-qt-libmng]
+        [-system-libmng] [-no-libjpeg] [-qt-libjpeg] [-system-libjpeg] [-make <part>]
+        [-nomake <part>] [-R <string>]  [-l <string>] [-no-rpath]  [-rpath] [-continue]
+        [-verbose] [-v] [-silent] [-no-nis] [-nis] [-no-cups] [-cups] [-no-iconv]
+        [-iconv] [-no-pch] [-pch] [-no-dbus] [-dbus] [-dbus-linked] [-no-gui]
+        [-no-separate-debug-info] [-no-mmx] [-no-3dnow] [-no-sse] [-no-sse2]
+        [-no-sse3] [-no-ssse3] [-no-sse4.1] [-no-sse4.2] [-no-avx] [-no-neon]
+        [-qtnamespace <namespace>] [-qtlibinfix <infix>] [-separate-debug-info] [-armfpa]
+        [-no-optimized-qmake] [-optimized-qmake] [-no-xmlpatterns] [-xmlpatterns]
+        [-no-multimedia] [-multimedia] [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend]
+        [-no-media-backend] [-media-backend] [-no-audio-backend] [-audio-backend] 
+        [-no-openssl] [-openssl] [-openssl-linked]
+        [-no-gtkstyle] [-gtkstyle] [-no-svg] [-svg] [-no-webkit] [-webkit] [-webkit-debug]
+        [-no-javascript-jit] [-javascript-jit]
+        [-no-script] [-script] [-no-scripttools] [-scripttools] 
+        [-no-declarative] [-declarative] [-no-declarative-debug] [-declarative-debug]
+        [additional platform specific options (see below)]
+
+
+Installation options:
+
+    -qpa [name] ......... This will enable the QPA build.
+                          QPA is a window system agnostic implementation of Qt.
+                          If [name] is given, sets the default QPA platform (e.g xcb, cocoa).
+
+ These are optional, but you may specify install directories.
+
+    -prefix <dir> ...... This will install everything relative to <dir>
+                         (default $QT_INSTALL_PREFIX)
+EOF
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+cat <<EOF
+
+    -hostprefix [dir] .. Tools and libraries needed when developing
+                         applications are installed in [dir]. If [dir] is
+                         not given, the current build directory will be used.
+EOF
+fi
+cat <<EOF
+
+  * -prefix-install .... Force a sandboxed "local" installation of
+                         Qt. This will install into
+                         $QT_INSTALL_PREFIX, if this option is
+                         disabled then some platforms will attempt a
+                         "system" install by placing default values
+                         in a system location other than PREFIX.
+
+ You may use these to separate different parts of the install:
+
+    -bindir <dir> ......... Executables will be installed to <dir>
+                            (default PREFIX/bin)
+    -libdir <dir> ......... Libraries will be installed to <dir>
+                            (default PREFIX/lib)
+    -docdir <dir> ......... Documentation will be installed to <dir>
+                            (default PREFIX/doc)
+    -headerdir <dir> ...... Headers will be installed to <dir>
+                            (default PREFIX/include)
+    -plugindir <dir> ...... Plugins will be installed to <dir>
+                            (default PREFIX/plugins)
+    -importdir <dir> ...... Imports for QML will be installed to <dir>
+                            (default PREFIX/imports)
+    -datadir <dir> ........ Data used by Qt programs will be installed to <dir>
+                            (default PREFIX)
+    -translationdir <dir> . Translations of Qt programs will be installed to <dir>
+                            (default PREFIX/translations)
+    -sysconfdir <dir> ..... Settings used by Qt programs will be looked for in <dir>
+                            (default PREFIX/etc/settings)
+    -examplesdir <dir> .... Examples will be installed to <dir>
+                            (default PREFIX/examples)
+    -demosdir <dir> ....... Demos will be installed to <dir>
+                            (default PREFIX/demos)
+
+ You may use these options to turn on strict plugin loading.
+
+    -buildkey <key> .... Build the Qt library and plugins using the specified
+                         <key>.  When the library loads plugins, it will only
+                         load those that have a matching key.
+
+Configure options:
+
+ The defaults (*) are usually acceptable. A plus (+) denotes a default value
+ that needs to be evaluated. If the evaluation succeeds, the feature is
+ included. Here is a short explanation of each option:
+
+ *  -release ........... Compile and link Qt with debugging turned off.
+    -debug ............. Compile and link Qt with debugging turned on.
+    -debug-and-release . Compile and link two versions of Qt, with and without
+                         debugging turned on (Mac only).
+
+    -developer-build ... Compile and link Qt with Qt developer options (including auto-tests exporting)
+
+    -opensource ........ Compile and link the Open-Source Edition of Qt.
+    -commercial ........ Compile and link the Commercial Edition of Qt.
+
+
+ *  -shared ............ Create and use shared Qt libraries.
+    -static ............ Create and use static Qt libraries.
+
+ *  -no-fast ........... Configure Qt normally by generating Makefiles for all
+                         project files.
+    -fast .............. Configure Qt quickly by generating Makefiles only for
+                         library and subdirectory targets.  All other Makefiles
+                         are created as wrappers, which will in turn run qmake.
+
+    -no-largefile ...... Disables large file support.
+ +  -largefile ......... Enables Qt to access files larger than 4 GB.
+
+ *  -no-system-proxies . Do not use system network proxies by default.
+    -system-proxies .... Use system network proxies by default.
+
+EOF
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    EXCN="*"
+    EXCY=" "
+else
+    EXCN=" "
+    EXCY="*"
+fi
+if [ "$CFG_DBUS" = "no" ]; then
+    DBY=" "
+    DBN="+"
+else
+    DBY="+"
+    DBN=" "
+fi
+
+    cat << EOF
+ $EXCN  -no-exceptions ..... Disable exceptions on compilers that support it.
+ $EXCY  -exceptions ........ Enable exceptions on compilers that support it.
+
+    -no-accessibility .. Do not compile Accessibility support.
+ *  -accessibility ..... Compile Accessibility support.
+
+ $SHN  -no-stl ............ Do not compile STL support.
+ $SHY  -stl ............... Compile STL support.
+
+    -no-sql-<driver> ... Disable SQL <driver> entirely.
+    -qt-sql-<driver> ... Enable a SQL <driver> in the QtSql library, by default
+                         none are turned on.
+    -plugin-sql-<driver> Enable SQL <driver> as a plugin to be linked to
+                         at run time.
+
+                         Possible values for <driver>:
+                         [ $CFG_SQL_AVAILABLE ]
+
+    -system-sqlite ..... Use sqlite from the operating system.
+
+    -no-qt3support ..... Disables the Qt 3 support functionality.
+ *  -qt3support ........ Enables the Qt 3 support functionality.
+
+    -no-xmlpatterns .... Do not build the QtXmlPatterns module.
+ +  -xmlpatterns ....... Build the QtXmlPatterns module.
+                         QtXmlPatterns is built if a decent C++ compiler
+                         is used and exceptions are enabled.
+
+    -no-multimedia ..... Do not build the QtMultimedia module.
+ +  -multimedia ........ Build the QtMultimedia module.
+
+    -no-audio-backend .. Do not build the platform audio backend into QtMultimedia.
+ +  -audio-backend ..... Build the platform audio backend into QtMultimedia if available.
+
+    -no-phonon ......... Do not build the Phonon module.
+ +  -phonon ............ Build the Phonon module.
+                         Phonon is built if a decent C++ compiler is used.
+    -no-phonon-backend.. Do not build the platform phonon plugin.
+ +  -phonon-backend..... Build the platform phonon plugin.
+
+    -no-svg ............ Do not build the SVG module.
+ +  -svg ............... Build the SVG module.
+
+    -no-webkit ......... Do not build the WebKit module.
+ +  -webkit ............ Build the WebKit module.
+                         WebKit is built if a decent C++ compiler is used.
+    -webkit-debug ...... Build the WebKit module with debug symbols.
+
+    -no-javascript-jit . Do not build the JavaScriptCore JIT compiler.
+ +  -javascript-jit .... Build the JavaScriptCore JIT compiler.
+
+    -no-script ......... Do not build the QtScript module.
+ +  -script ............ Build the QtScript module.
+
+    -no-scripttools .... Do not build the QtScriptTools module.
+ +  -scripttools ....... Build the QtScriptTools module.
+
+    -no-declarative ..... Do not build the declarative module.
+ +  -declarative ....... Build the declarative module.
+
+    -no-declarative-debug ..... Do not build the declarative debugging support.
+ +  -declarative-debug ....... Build the declarative debugging support.
+
+    -platform target ... The operating system and compiler you are building
+                         on ($PLATFORM).
+
+                         See the README file for a list of supported
+                         operating systems and compilers.
+EOF
+
+if [ "${PLATFORM_QWS}" != "yes" -a "${PLATFORM_QPA}" != "yes" ]; then
+cat << EOF
+    -graphicssystem <sys> Sets an alternate graphics system. Available options are:
+                           raster - Software rasterizer
+                           opengl - Rendering via OpenGL, Experimental!
+                           openvg - Rendering via OpenVG, Experimental!
+
+EOF
+fi
+
+cat << EOF
+
+    -no-mmx ............ Do not compile with use of MMX instructions.
+    -no-3dnow .......... Do not compile with use of 3DNOW instructions.
+    -no-sse ............ Do not compile with use of SSE instructions.
+    -no-sse2 ........... Do not compile with use of SSE2 instructions.
+    -no-sse3 ........... Do not compile with use of SSE3 instructions.
+    -no-ssse3 .......... Do not compile with use of SSSE3 instructions.
+    -no-sse4.1.......... Do not compile with use of SSE4.1 instructions.
+    -no-sse4.2.......... Do not compile with use of SSE4.2 instructions.
+    -no-avx ............ Do not compile with use of AVX instructions.
+    -no-neon ........... Do not compile with use of NEON instructions.
+
+    -qtnamespace <name>  Wraps all Qt library code in 'namespace <name> {...}'.
+    -qtlibinfix <infix>  Renames all libQt*.so to libQt*<infix>.so.
+
+    -D <string> ........ Add an explicit define to the preprocessor.
+    -I <string> ........ Add an explicit include path.
+    -L <string> ........ Add an explicit library path.
+
+    -help, -h .......... Display this information.
+
+Third Party Libraries:
+
+    -qt-zlib ........... Use the zlib bundled with Qt.
+ +  -system-zlib ....... Use zlib from the operating system.
+                         See http://www.gzip.org/zlib
+
+    -no-gif ............ Do not compile GIF reading support.
+
+    -no-libtiff ........ Do not compile TIFF support.
+    -qt-libtiff ........ Use the libtiff bundled with Qt.
+ +  -system-libtiff .... Use libtiff from the operating system.
+                         See http://www.libtiff.org
+
+    -no-libpng ......... Do not compile PNG support.
+    -qt-libpng ......... Use the libpng bundled with Qt.
+ +  -system-libpng ..... Use libpng from the operating system.
+                         See http://www.libpng.org/pub/png
+
+    -no-libmng ......... Do not compile MNG support.
+    -qt-libmng ......... Use the libmng bundled with Qt.
+ +  -system-libmng ..... Use libmng from the operating system.
+                         See http://www.libmng.com
+
+    -no-libjpeg ........ Do not compile JPEG support.
+    -qt-libjpeg ........ Use the libjpeg bundled with Qt.
+ +  -system-libjpeg .... Use libjpeg from the operating system.
+                         See http://www.ijg.org
+
+    -no-openssl ........ Do not compile support for OpenSSL.
+ +  -openssl ........... Enable run-time OpenSSL support.
+    -openssl-linked .... Enabled linked OpenSSL support.
+
+    -ptmalloc .......... Override the system memory allocator with ptmalloc.
+                         (Experimental.)
+
+Additional options:
+
+    -make <part> ....... Add part to the list of parts to be built at make time.
+                         ($QT_DEFAULT_BUILD_PARTS)
+    -nomake <part> ..... Exclude part from the list of parts to be built.
+
+    -R <string> ........ Add an explicit runtime library path to the Qt
+                         libraries.
+    -l <string> ........ Add an explicit library.
+
+    -no-rpath .......... Do not use the library install path as a runtime
+                         library path.
+ +  -rpath ............. Link Qt libraries and executables using the library
+                         install path as a runtime library path. Equivalent
+                         to -R install_libpath
+
+    -continue .......... Continue as far as possible if an error occurs.
+
+    -verbose, -v ....... Print verbose information about each step of the
+                         configure process.
+
+    -silent ............ Reduce the build output so that warnings and errors
+                         can be seen more easily.
+
+ *  -no-optimized-qmake ... Do not build qmake optimized.
+    -optimized-qmake ...... Build qmake optimized.
+
+    -no-gui ............ Don't build the Qt GUI library
+
+ $NSN  -no-nis ............ Do not compile NIS support.
+ $NSY  -nis ............... Compile NIS support.
+
+ $CUN  -no-cups ........... Do not compile CUPS support.
+ $CUY  -cups .............. Compile CUPS support.
+                         Requires cups/cups.h and libcups.so.2.
+
+ $CIN  -no-iconv .......... Do not compile support for iconv(3).
+ $CIY  -iconv ............. Compile support for iconv(3).
+
+ $PHN  -no-pch ............ Do not use precompiled header support.
+ $PHY  -pch ............... Use precompiled header support.
+
+ $DBN  -no-dbus ........... Do not compile the QtDBus module.
+ $DBY  -dbus .............. Compile the QtDBus module and dynamically load libdbus-1.
+    -dbus-linked ....... Compile the QtDBus module and link to libdbus-1.
+
+    -reduce-relocations ..... Reduce relocations in the libraries through extra
+                              linker optimizations (Qt/X11 and Qt for Embedded Linux only;
+                              experimental; needs GNU ld >= 2.18).
+EOF
+
+if [ "$CFG_SEPARATE_DEBUG_INFO" = "auto" ]; then
+    if [ "$QT_CROSS_COMPILE" = "yes" ]; then
+        SBY=""
+        SBN="*"
+    else
+        SBY="*"
+        SBN=" "
+    fi
+elif [ "$CFG_SEPARATE_DEBUG_INFO" = "yes" ]; then
+    SBY="*"
+    SBN=" "
+else
+    SBY=" "
+    SBN="*"
+fi
+
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+
+    cat << EOF
+
+ $SBN  -no-separate-debug-info . Do not store debug information in a separate file.
+ $SBY  -separate-debug-info .... Strip debug information into a separate file.
+
+EOF
+
+fi # X11/QWS
+
+if [ "$PLATFORM_X11" = "yes" ]; then
+    if [ "$CFG_SM" = "no" ]; then
+        SMY=" "
+        SMN="*"
+    else
+        SMY="*"
+        SMN=" "
+    fi
+    if [ "$CFG_XSHAPE" = "no" ]; then
+        SHY=" "
+        SHN="*"
+    else
+        SHY="*"
+        SHN=" "
+    fi
+    if [ "$CFG_XVIDEO" = "no" ]; then
+        XVY=" "
+        XVN="*"
+    else
+        XVY="*"
+        XVN=" "
+    fi
+    if [ "$CFG_XINERAMA" = "no" ]; then
+        XAY=" "
+        XAN="*"
+    else
+        XAY="*"
+        XAN=" "
+    fi
+    if [ "$CFG_FONTCONFIG" = "no" ]; then
+        FCGY=" "
+        FCGN="*"
+    else
+        FCGY="*"
+        FCGN=" "
+    fi
+    if [ "$CFG_XCURSOR" = "no" ]; then
+        XCY=" "
+        XCN="*"
+    else
+        XCY="*"
+        XCN=" "
+    fi
+    if [ "$CFG_XFIXES" = "no" ]; then
+        XFY=" "
+        XFN="*"
+    else
+        XFY="*"
+        XFN=" "
+    fi
+    if [ "$CFG_XRANDR" = "no" ]; then
+        XZY=" "
+        XZN="*"
+    else
+        XZY="*"
+        XZN=" "
+    fi
+    if [ "$CFG_XRENDER" = "no" ]; then
+        XRY=" "
+        XRN="*"
+    else
+        XRY="*"
+        XRN=" "
+    fi
+    if [ "$CFG_MITSHM" = "no" ]; then
+        XMY=" "
+        XMN="*"
+    else
+        XMY="*"
+        XMN=" "
+    fi
+    if [ "$CFG_XINPUT" = "no" ]; then
+        XIY=" "
+        XIN="*"
+    else
+        XIY="*"
+        XIN=" "
+    fi
+    if [ "$CFG_XKB" = "no" ]; then
+        XKY=" "
+        XKN="*"
+    else
+        XKY="*"
+        XKN=" "
+    fi
+    if [ "$CFG_IM" = "no" ]; then
+        IMY=" "
+        IMN="*"
+    else
+        IMY="*"
+        IMN=" "
+    fi
+    cat << EOF
+
+Qt/X11 only:
+
+    -no-gtkstyle ....... Do not build the GTK theme integration.
+ +  -gtkstyle .......... Build the GTK theme integration.
+
+ *  -no-nas-sound ...... Do not compile in NAS sound support.
+    -system-nas-sound .. Use NAS libaudio from the operating system.
+                         See http://radscan.com/nas.html
+
+    -egl ............... Use EGL instead of GLX to manage contexts.
+                         When building for desktop OpenGL, this option will
+                         make Qt use EGL to manage contexts rather than the
+                         GLX, which is the default. Note: For OpenGL ES, EGL
+                         is always used.
+
+    -no-opengl ......... Do not support OpenGL.
+ +  -opengl <api> ...... Enable OpenGL support.
+                         With no parameter, this will auto-detect the "best"
+                         OpenGL API to use. If desktop OpenGL is available, it
+                         will be used. Use desktop, es1, or es2 for <api>
+                         to force the use of the Desktop (OpenGL 1.x or 2.x),
+                         OpenGL ES 1.x Common profile, or 2.x APIs instead.
+
+     -no-openvg ........ Do not support OpenVG.
+ +   -openvg ........... Enable OpenVG support.
+                         Requires EGL support, typically supplied by an OpenGL
+                         or other graphics implementation.
+
+ $SMN  -no-sm ............. Do not support X Session Management.
+ $SMY  -sm ................ Support X Session Management, links in -lSM -lICE.
+
+ $SHN  -no-xshape ......... Do not compile XShape support.
+ $SHY  -xshape ............ Compile XShape support.
+                         Requires X11/extensions/shape.h.
+
+ $XVN  -no-xvideo ......... Do not compile XVideo support.
+ $XVY  -xvideo ............ Compile XVideo support.
+                         Requires X11/extensions/Xv.h & Xvlib.h.
+
+ $SHN  -no-xsync .......... Do not compile XSync support.
+ $SHY  -xsync ............. Compile XSync support.
+                         Requires X11/extensions/sync.h.
+
+ $XAN  -no-xinerama ....... Do not compile Xinerama (multihead) support.
+ $XAY  -xinerama .......... Compile Xinerama support.
+                         Requires X11/extensions/Xinerama.h and libXinerama.
+			 By default, Xinerama support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XCN  -no-xcursor ........ Do not compile Xcursor support.
+ $XCY  -xcursor ........... Compile Xcursor support.
+                         Requires X11/Xcursor/Xcursor.h and libXcursor.
+			 By default, Xcursor support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XFN  -no-xfixes ......... Do not compile Xfixes support.
+ $XFY  -xfixes ............ Compile Xfixes support.
+                         Requires X11/extensions/Xfixes.h and libXfixes.
+			 By default, Xfixes support will be compiled if
+                         available and the shared libraries are dynamically
+                         loaded at runtime.
+
+ $XZN  -no-xrandr ......... Do not compile Xrandr (resize and rotate) support.
+ $XZY  -xrandr ............ Compile Xrandr support.
+                         Requires X11/extensions/Xrandr.h and libXrandr.
+
+ $XRN  -no-xrender ........ Do not compile Xrender support.
+ $XRY  -xrender ........... Compile Xrender support.
+                         Requires X11/extensions/Xrender.h and libXrender.
+
+ $XMN  -no-mitshm ......... Do not compile MIT-SHM support.
+ $XMY  -mitshm ............ Compile MIT-SHM support.
+                         Requires sys/ipc.h, sys/shm.h and X11/extensions/XShm.h
+
+ $FCGN  -no-fontconfig ..... Do not compile FontConfig (anti-aliased font) support.
+ $FCGY  -fontconfig ........ Compile FontConfig support.
+                         Requires fontconfig/fontconfig.h, libfontconfig,
+                         freetype.h and libfreetype.
+
+ $XIN  -no-xinput ......... Do not compile Xinput support.
+ $XIY  -xinput ............ Compile Xinput support. This also enabled tablet support
+                         which requires IRIX with wacom.h and libXi or
+                         XFree86 with X11/extensions/XInput.h and libXi.
+
+ $XKN  -no-xkb ............ Do not compile XKB (X KeyBoard extension) support.
+ $XKY  -xkb ............... Compile XKB support.
+
+EOF
+fi
+
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    cat << EOF
+
+    -no-slog2 .......... Do not compile with slog2 support.
+    -slog2 ............. Compile with slog2 support.
+
+EOF
+
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    cat << EOF
+
+Qt/Mac only:
+
+    -Fstring ........... Add an explicit framework path.
+    -fw string ......... Add an explicit framework.
+
+    -cocoa ............. [Deprecated] Cocoa is now enabled by default.
+
+    -carbon .............Build the Carbon version of Qt. 64-bit archs
+                         are not supported by carbon and will be built
+                         with cocoa
+
+ *  -framework ......... Build Qt as a series of frameworks and
+                         link tools against those frameworks.
+    -no-framework ...... Do not build Qt as a series of frameworks.
+
+ *  -dwarf2 ............ Enable dwarf2 debugging symbols.
+    -no-dwarf2 ......... Disable dwarf2 debugging symbols.
+
+    -universal ......... Equivalent to -arch "ppc x86"
+
+    -arch <arch> ....... Build Qt for <arch>
+                         Example values for <arch>: x86 ppc x86_64 ppc64
+                         Multiple -arch arguments can be specified.
+
+    -sdk <sdk> ......... Build Qt using Apple provided SDK <sdk>. This option requires gcc 4.
+                         To use a different SDK with gcc 3.3, set the SDKROOT environment variable.
+
+    -harfbuzz .......... Use HarfBuzz to do text layout instead of Core Text when possible.
+                         It is only available to Cocoa builds.
+ *  -no-harfbuzz ....... Disable HarfBuzz on Mac. It can still be enabled by setting
+                         QT_ENABLE_HARFBUZZ environment variable.
+
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    cat << EOF
+Qt for Embedded Linux:
+
+    -embedded <arch> .... This will enable the embedded build, you must have a
+                          proper license for this switch to work.
+                          Example values for <arch>: arm mips x86 generic
+EOF
+fi
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    cat << EOF
+Qt for QPA only:
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    cat << EOF
+
+    -xplatform target ... The target platform when cross-compiling.
+
+    -device-option <key=value> ... Add device specific options for the device mkspec
+                                   (experimental)
+
+    -no-feature-<feature> Do not compile in <feature>.
+    -feature-<feature> .. Compile in <feature>. The available features
+                          are described in src/corelib/global/qfeatures.txt
+
+    -armfpa ............. Target platform uses the ARM-FPA floating point format.
+    -no-armfpa .......... Target platform does not use the ARM-FPA floating point format.
+
+                          The floating point format is usually autodetected by configure. Use this
+                          to override the detected value.
+
+    -little-endian ...... Target platform is little endian (LSB first).
+    -big-endian ......... Target platform is big endian (MSB first).
+
+    -host-little-endian . Host platform is little endian (LSB first).
+    -host-big-endian .... Host platform is big endian (MSB first).
+
+                          You only need to specify the endianness when
+                          cross-compiling, otherwise the host
+                          endianness will be used.
+
+    -no-freetype ........ Do not compile in Freetype2 support.
+    -qt-freetype ........ Use the libfreetype bundled with Qt.
+ *  -system-freetype .... Use libfreetype from the operating system.
+                          See http://www.freetype.org/
+
+    -qconfig local ...... Use src/corelib/global/qconfig-local.h rather than the
+                          default ($CFG_QCONFIG).
+
+    -no-opengl .......... Do not support OpenGL.
+    -opengl <api> ....... Enable OpenGL ES support
+                          With no parameter, this will attempt to auto-detect OpenGL ES 1.x
+                          or 2.x, or regular desktop OpenGL.
+                          Use es1 or es2 for <api> to override auto-detection.
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    cat << EOF
+
+    -depths <list> ...... Comma-separated list of supported bit-per-pixel
+                          depths, from: 1, 4, 8, 12, 15, 16, 18, 24, 32 and 'all'.
+
+    -qt-decoration-<style> ....Enable a decoration <style> in the QtGui library,
+                               by default all available decorations are on.
+			       Possible values for <style>: [ $CFG_DECORATION_AVAILABLE ]
+    -plugin-decoration-<style> Enable decoration <style> as a plugin to be
+                               linked to at run time.
+			       Possible values for <style>: [ $CFG_DECORATION_PLUGIN_AVAILABLE ]
+    -no-decoration-<style> ....Disable decoration <style> entirely.
+                               Possible values for <style>: [ $CFG_DECORATION_AVAILABLE ]
+
+    -qt-gfx-<driver> ... Enable a graphics <driver> in the QtGui library.
+                         Possible values for <driver>: [ $CFG_GFX_AVAILABLE ]
+    -plugin-gfx-<driver> Enable graphics <driver> as a plugin to be
+                         linked to at run time.
+                         Possible values for <driver>: [ $CFG_GFX_PLUGIN_AVAILABLE ]
+    -no-gfx-<driver> ... Disable graphics <driver> entirely.
+                         Possible values for <driver>: [ $CFG_GFX_AVAILABLE ]
+
+    -qt-kbd-<driver> ... Enable a keyboard <driver> in the QtGui library.
+                         Possible values for <driver>: [ $CFG_KBD_AVAILABLE ]
+
+    -plugin-kbd-<driver> Enable keyboard <driver> as a plugin to be linked to
+                         at runtime.
+                         Possible values for <driver>: [ $CFG_KBD_PLUGIN_AVAILABLE ]
+
+    -no-kbd-<driver> ... Disable keyboard <driver> entirely.
+                         Possible values for <driver>: [ $CFG_KBD_AVAILABLE ]
+
+    -qt-mouse-<driver> ... Enable a mouse <driver> in the QtGui library.
+                           Possible values for <driver>: [ $CFG_MOUSE_AVAILABLE ]
+    -plugin-mouse-<driver> Enable mouse <driver> as a plugin to be linked to
+                           at runtime.
+                           Possible values for <driver>: [ $CFG_MOUSE_PLUGIN_AVAILABLE ]
+    -no-mouse-<driver> ... Disable mouse <driver> entirely.
+                           Possible values for <driver>: [ $CFG_MOUSE_AVAILABLE ]
+
+    -iwmmxt ............ Compile using the iWMMXt instruction set
+                         (available on some XScale CPUs).
+EOF
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" -o "$PLATFORM_X11" = "yes" ]; then
+    if [ "$CFG_GLIB" = "no" ]; then
+        GBY=" "
+        GBN="+"
+    else
+        GBY="+"
+        GBN=" "
+    fi
+    cat << EOF
+ $GBN  -no-glib ........... Do not compile Glib support.
+ $GBY  -glib .............. Compile Glib support.
+
+EOF
+fi
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    cat << EOF
+
+Qt for Symbian only:
+    -no-s60 ............ Do not compile in S60 support.
+ +  -s60 ............... Compile with support for the S60 UI Framework.
+    -no-style-s60....... Disable s60 style
+ +  -qt-style-s60....... Enable s60 style in the Qt Library
+
+    -no-usedeffiles .... Disable the usage of DEF files.
+ *  -usedeffiles ....... Enable the usage of DEF files.
+EOF
+fi
+   [ "x$ERROR" = "xyes" ] && exit 1
+   exit 0
+fi # Help
+
+
+# -----------------------------------------------------------------------------
+# LICENSING, INTERACTIVE PART
+# -----------------------------------------------------------------------------
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    Platform="Qt for Embedded Linux"
+elif [ "$PLATFORM_QPA" = "yes" ]; then
+    Platform="Qt Lighthouse"
+elif [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    Platform="Qt for INTEGRITY"
+elif [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    Platform="Qt for Symbian"
+elif [ "$PLATFORM_MAC" = "yes" ]; then
+    Platform="Qt for Mac OS X"
+elif [ "$XPLATFORM_MINGW" = "yes" ]; then
+    Platform="Qt for Windows"
+elif [ -n "`getXQMakeConf grep QMAKE_LIBS_X11`" ]; then
+    PLATFORM_X11=yes
+    Platform="Qt for Linux/X11"
+fi
+
+echo
+echo "This is the $Platform ${EditionString} Edition."
+echo
+
+if [ "$Edition" = "NokiaInternalBuild" ]; then
+    echo "Detected -nokia-developer option"
+    echo "Nokia employees and agents are allowed to use this software under"
+    echo "the authority of Nokia Corporation and/or its subsidiary(-ies)"
+elif [ "$Edition" = "OpenSource" ]; then
+    while true; do
+        echo "You are licensed to use this software under the terms of"
+        echo "the Lesser GNU General Public License (LGPL) versions 2.1."
+        if [ -f "$relpath/LICENSE.GPL3" ]; then
+            echo "You are also licensed to use this software under the terms of"
+            echo "the GNU General Public License (GPL) versions 3."
+            affix="either"
+        else
+            affix="the"
+        fi
+        echo
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+            echo "You have already accepted the terms of the $LicenseType license."
+            acceptance=yes
+        else
+            if [ -f "$relpath/LICENSE.GPL3" ]; then
+                echo "Type '3' to view the GNU General Public License version 3."
+            fi
+            echo "Type 'L' to view the Lesser GNU General Public License version 2.1."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of $affix license? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ] || [ "$acceptance" = "y" ]; then
+            break
+        elif [ "$acceptance" = "no" ]; then
+            echo "You are not licensed to use this software."
+            echo
+            exit 1
+        elif [ "$acceptance" = "3" ]; then
+            more "$relpath/LICENSE.GPL3"
+        elif [ "$acceptance" = "L" ]; then
+            more "$relpath/LICENSE.LGPL"
+        fi
+    done
+elif [ "$Edition" = "Preview" ]; then
+    TheLicense=`head -n 1 "$relpath/LICENSE.PREVIEW.COMMERCIAL"`
+    while true; do
+
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+            echo "You have already accepted the terms of the $LicenseType license."
+            acceptance=yes
+        else
+            echo "You are licensed to use this software under the terms of"
+            echo "the $TheLicense"
+            echo
+            echo "Type '?' to read the Preview License."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of the license? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ]; then
+            break
+        elif [ "$acceptance" = "no" ] ;then
+            echo "You are not licensed to use this software."
+            echo
+            exit 0
+        elif [ "$acceptance" = "?" ]; then
+            more "$relpath/LICENSE.PREVIEW.COMMERCIAL"
+        fi
+    done
+elif [ "$Edition" != "OpenSource" ]; then
+    if [ -n "$ExpiryDate" ]; then
+        ExpiryDate=`echo $ExpiryDate | sed -e "s,-,,g" | tr -d "\n\r"`
+        [ -z "$ExpiryDate" ] && ExpiryDate="0"
+        Today=`date +%Y%m%d`
+        if [ "$Today" -gt "$ExpiryDate" ]; then
+            case "$LicenseType" in
+            Commercial|Academic|Educational)
+                if [ "$QT_PACKAGEDATE" -gt "$ExpiryDate" ]; then
+                    echo
+                    echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                    echo
+                    echo "  Your support and upgrade period has expired."
+                    echo
+                    echo "  You are no longer licensed to use this software. Please"
+                    echo "  use the contact form at http://www.qt.io/contact-us to"
+                    echo "  purchase license, or install the Qt Open Source Edition"
+                    echo "  if you intend to develop free software."
+                    echo
+                    echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                    echo
+                    exit 1
+                else
+                    echo
+                    echo "WARNING  WARNING  WARNING  WARNING"
+                    echo
+                    echo "  Your support and upgrade period has expired."
+                    echo
+                    echo "  You may continue to use your last licensed release"
+                    echo "  of Qt under the terms of your existing license"
+                    echo "  agreement. But you are not entitled to technical"
+                    echo "  support, nor are you entitled to use any more recent"
+                    echo "  Qt releases."
+                    echo
+                    echo "  Please use the contact form at http://www.qt.io/contact-us"
+                    echo "  to renew your support and upgrades for this license."
+                    echo
+                    echo "WARNING  WARNING  WARNING  WARNING"
+                    echo
+                    sleep 3
+                fi
+                ;;
+            Evaluation|*)
+                echo
+                echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                echo
+                echo "  Your Evaluation license has expired."
+                echo
+                echo "  You are no longer licensed to use this software. Please"
+                echo "  use the contact form at http://www.qt.io/contact-us to"
+                echo "  purchase license, or install the Qt Open Source Edition"
+                echo "  if you intend to develop free software."
+                echo
+                echo "NOTICE  NOTICE  NOTICE  NOTICE"
+                echo
+                exit 1
+                ;;
+            esac
+        fi
+    fi
+    TheLicense=`head -n 1 "$outpath/LICENSE"`
+    while true; do
+        if [ "$OPT_CONFIRM_LICENSE" = "yes" ]; then
+	    echo "You have already accepted the terms of the $TheLicense."
+            acceptance=yes
+        else
+            echo "You are licensed to use this software under the terms of"
+            echo "the $TheLicense."
+            echo
+            echo "Type '?' to view the $TheLicense."
+            echo "Type 'yes' to accept this license offer."
+            echo "Type 'no' to decline this license offer."
+            echo
+            echo $ECHO_N "Do you accept the terms of the $TheLicense? $ECHO_C"
+            read acceptance
+        fi
+        echo
+        if [ "$acceptance" = "yes" ]; then
+            break
+        elif [ "$acceptance" = "no" ]; then
+            echo "You are not licensed to use this software."
+            echo
+            exit 1
+        else [ "$acceptance" = "?" ]
+            more "$outpath/LICENSE"
+        fi
+    done
+fi
+
+# this should be moved somewhere else
+case "$PLATFORM" in
+aix-*)
+    AIX_VERSION=`uname -v`
+    if [ "$AIX_VERSION" -lt "5" ]; then
+	QMakeVar add QMAKE_LIBS_X11 -lbind
+    fi
+    ;;
+*)
+    ;;
+esac
+
+#-------------------------------------------------------------------------------
+# generate qconfig.cpp
+#-------------------------------------------------------------------------------
+[ -d "$outpath/src/corelib/global" ] || mkdir -p "$outpath/src/corelib/global"
+
+LICENSE_USER_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_lcnsuser=$Licensee"`
+LICENSE_PRODUCTS_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_lcnsprod=$Edition"`
+PREFIX_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_prfxpath=$QT_INSTALL_PREFIX"`
+DOCUMENTATION_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_docspath=$QT_INSTALL_DOCS"`
+HEADERS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_hdrspath=$QT_INSTALL_HEADERS"`
+LIBRARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_libspath=$QT_INSTALL_LIBS"`
+BINARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_binspath=$QT_INSTALL_BINS"`
+PLUGINS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_plugpath=$QT_INSTALL_PLUGINS"`
+IMPORTS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_impspath=$QT_INSTALL_IMPORTS"`
+DATA_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_datapath=$QT_INSTALL_DATA"`
+TRANSLATIONS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_trnspath=$QT_INSTALL_TRANSLATIONS"`
+SETTINGS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_stngpath=$QT_INSTALL_SETTINGS"`
+EXAMPLES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_xmplpath=$QT_INSTALL_EXAMPLES"`
+DEMOS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_demopath=$QT_INSTALL_DEMOS"`
+
+TODAY=`date +%Y-%m-%d`
+cat > "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* License Info */
+static const char qt_configure_licensee_str          [256 + 12] = "$LICENSE_USER_STR";
+static const char qt_configure_licensed_products_str [256 + 12] = "$LICENSE_PRODUCTS_STR";
+
+/* Installation date */
+static const char qt_configure_installation          [12+11]    = "qt_instdate=$TODAY";
+EOF
+
+
+if [ ! -z "$QT_HOST_PREFIX" ]; then
+    HOSTPREFIX_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_prfxpath=$QT_HOST_PREFIX"`
+    HOSTDOCUMENTATION_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_docspath=$QT_HOST_PREFIX/doc"`
+    HOSTHEADERS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_hdrspath=$QT_HOST_PREFIX/include"`
+    HOSTLIBRARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_libspath=$QT_HOST_PREFIX/lib"`
+    HOSTBINARIES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_binspath=$QT_HOST_PREFIX/bin"`
+    HOSTPLUGINS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_plugpath=$QT_HOST_PREFIX/plugins"`
+    HOSTIMPORTS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_impspath=$QT_HOST_PREFIX/IMPORTS"`
+    HOSTDATA_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_datapath=$QT_HOST_PREFIX"`
+    HOSTTRANSLATIONS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_trnspath=$QT_HOST_PREFIX/translations"`
+    HOSTSETTINGS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_stngpath=$QT_INSTALL_SETTINGS"`
+    HOSTEXAMPLES_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_xmplpath=$QT_INSTALL_EXAMPLES"`
+    HOSTDEMOS_PATH_STR=`"$relpath/config.tests/unix/padstring" 268 "qt_demopath=$QT_INSTALL_DEMOS"`
+
+    cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+
+#if defined(QT_BOOTSTRAPPED) || defined(QT_BUILD_QMAKE)
+/* Installation Info */
+static const char qt_configure_prefix_path_str       [256 + 12] = "$HOSTPREFIX_PATH_STR";
+static const char qt_configure_documentation_path_str[256 + 12] = "$HOSTDOCUMENTATION_PATH_STR";
+static const char qt_configure_headers_path_str      [256 + 12] = "$HOSTHEADERS_PATH_STR";
+static const char qt_configure_libraries_path_str    [256 + 12] = "$HOSTLIBRARIES_PATH_STR";
+static const char qt_configure_binaries_path_str     [256 + 12] = "$HOSTBINARIES_PATH_STR";
+static const char qt_configure_plugins_path_str      [256 + 12] = "$HOSTPLUGINS_PATH_STR";
+static const char qt_configure_imports_path_str      [256 + 12] = "$HOSTIMPORTS_PATH_STR";
+static const char qt_configure_data_path_str         [256 + 12] = "$HOSTDATA_PATH_STR";
+static const char qt_configure_translations_path_str [256 + 12] = "$HOSTTRANSLATIONS_PATH_STR";
+static const char qt_configure_settings_path_str     [256 + 12] = "$HOSTSETTINGS_PATH_STR";
+static const char qt_configure_examples_path_str     [256 + 12] = "$HOSTEXAMPLES_PATH_STR";
+static const char qt_configure_demos_path_str        [256 + 12] = "$HOSTDEMOS_PATH_STR";
+#else // QT_BOOTSTRAPPED
+EOF
+fi
+
+cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* Installation Info */
+static const char qt_configure_prefix_path_str       [256 + 12] = "$PREFIX_PATH_STR";
+static const char qt_configure_documentation_path_str[256 + 12] = "$DOCUMENTATION_PATH_STR";
+static const char qt_configure_headers_path_str      [256 + 12] = "$HEADERS_PATH_STR";
+static const char qt_configure_libraries_path_str    [256 + 12] = "$LIBRARIES_PATH_STR";
+static const char qt_configure_binaries_path_str     [256 + 12] = "$BINARIES_PATH_STR";
+static const char qt_configure_plugins_path_str      [256 + 12] = "$PLUGINS_PATH_STR";
+static const char qt_configure_imports_path_str      [256 + 12] = "$IMPORTS_PATH_STR";
+static const char qt_configure_data_path_str         [256 + 12] = "$DATA_PATH_STR";
+static const char qt_configure_translations_path_str [256 + 12] = "$TRANSLATIONS_PATH_STR";
+static const char qt_configure_settings_path_str     [256 + 12] = "$SETTINGS_PATH_STR";
+static const char qt_configure_examples_path_str     [256 + 12] = "$EXAMPLES_PATH_STR";
+static const char qt_configure_demos_path_str        [256 + 12] = "$DEMOS_PATH_STR";
+EOF
+
+if [ ! -z "$QT_HOST_PREFIX" ]; then
+    cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+#endif // QT_BOOTSTRAPPED
+
+EOF
+fi
+
+cat >> "$outpath/src/corelib/global/qconfig.cpp.new" <<EOF
+/* strlen( "qt_lcnsxxxx" ) == 12 */
+#define QT_CONFIGURE_LICENSEE qt_configure_licensee_str + 12;
+#define QT_CONFIGURE_LICENSED_PRODUCTS qt_configure_licensed_products_str + 12;
+#define QT_CONFIGURE_PREFIX_PATH qt_configure_prefix_path_str + 12;
+#define QT_CONFIGURE_DOCUMENTATION_PATH qt_configure_documentation_path_str + 12;
+#define QT_CONFIGURE_HEADERS_PATH qt_configure_headers_path_str + 12;
+#define QT_CONFIGURE_LIBRARIES_PATH qt_configure_libraries_path_str + 12;
+#define QT_CONFIGURE_BINARIES_PATH qt_configure_binaries_path_str + 12;
+#define QT_CONFIGURE_PLUGINS_PATH qt_configure_plugins_path_str + 12;
+#define QT_CONFIGURE_IMPORTS_PATH qt_configure_imports_path_str + 12;
+#define QT_CONFIGURE_DATA_PATH qt_configure_data_path_str + 12;
+#define QT_CONFIGURE_TRANSLATIONS_PATH qt_configure_translations_path_str + 12;
+#define QT_CONFIGURE_SETTINGS_PATH qt_configure_settings_path_str + 12;
+#define QT_CONFIGURE_EXAMPLES_PATH qt_configure_examples_path_str + 12;
+#define QT_CONFIGURE_DEMOS_PATH qt_configure_demos_path_str + 12;
+EOF
+
+# avoid unecessary rebuilds by copying only if qconfig.cpp has changed
+if cmp -s "$outpath/src/corelib/global/qconfig.cpp" "$outpath/src/corelib/global/qconfig.cpp.new"; then
+    rm -f "$outpath/src/corelib/global/qconfig.cpp.new"
+else
+    [ -f "$outpath/src/corelib/global/qconfig.cpp" ] && chmod +w "$outpath/src/corelib/global/qconfig.cpp"
+    mv "$outpath/src/corelib/global/qconfig.cpp.new" "$outpath/src/corelib/global/qconfig.cpp"
+    chmod -w "$outpath/src/corelib/global/qconfig.cpp"
+fi
+
+# -----------------------------------------------------------------------------
+if [ "$LicenseType" = "Evaluation" ]; then
+    EVALKEY=`"$relpath/config.tests/unix/padstring" 524 "qt_qevalkey=$LicenseKeyExt"`
+elif echo "$D_FLAGS" | grep QT_EVAL >/dev/null 2>&1; then
+    EVALKEY=`"$relpath/config.tests/unix/padstring" 524 "qt_qevalkey="`
+fi
+
+if [ -n "$EVALKEY" ]; then
+    rm -f "$outpath/src/corelib/global/qconfig_eval.cpp"
+    cat > "$outpath/src/corelib/global/qconfig_eval.cpp" <<EOF
+/* Evaluation license key */
+static const volatile char qt_eval_key_data                   [512 + 12] = "$EVALKEY";
+EOF
+    chmod -w "$outpath/src/corelib/global/qconfig_eval.cpp"
+fi
+
+
+# -----------------------------------------------------------------------------
+# build qmake
+# -----------------------------------------------------------------------------
+
+# symlink includes
+if [ -n "$PERL" ] && [ -x "$relpath/bin/syncqt" ]; then
+    SYNCQT_OPTS=
+    [ "$CFG_DEV" = "yes" ] && SYNCQT_OPTS="$SYNCQT_OPTS -check-includes"
+    if [ "$OPT_SHADOW" = "yes" ]; then
+        "$outpath/bin/syncqt" $SYNCQT_OPTS || exit 1
+    elif [ "$CFG_DEV" = "yes" ] || [ ! -d $relpath/include ] || [ -d $relpath/.git ]; then
+        QTDIR="$relpath" perl "$outpath/bin/syncqt" $SYNCQT_OPTS || exit 1
+    fi
+fi
+
+# $1: input variable name (awk regexp)
+# $2: optional output variable name
+# $3: optional value transformation (sed command)
+# relies on $QMAKESPEC, $COMPILER_CONF and $mkfile being set correctly, as the latter
+# is where the resulting variable is written to
+setBootstrapVariable()
+{
+    getQMakeConf "$1" | echo ${2-$1} = `if [ -n "$3" ]; then sed "$3"; else cat; fi` >> "$mkfile"
+}
+
+# build qmake
+if true; then ###[ '!' -f "$outpath/bin/qmake" ];
+    echo "Creating qmake. Please wait..."
+
+    OLD_QCONFIG_H=
+    QCONFIG_H="$outpath/src/corelib/global/qconfig.h"
+    QMAKE_QCONFIG_H="${QCONFIG_H}.qmake"
+    if [ -f "$QCONFIG_H" ]; then
+         OLD_QCONFIG_H=$QCONFIG_H
+         mv -f "$OLD_QCONFIG_H" "${OLD_QCONFIG_H}.old"
+    fi
+
+    # create temporary qconfig.h for compiling qmake, if it doesn't exist
+    # when building qmake, we use #defines for the install paths,
+    # however they are real functions in the library
+    if [ '!' -f "$QMAKE_QCONFIG_H" ]; then
+        mkdir -p "$outpath/src/corelib/global"
+        [ -f "$QCONFIG_H" ] && chmod +w "$QCONFIG_H"
+        echo "/* All features enabled while building qmake */" >"$QMAKE_QCONFIG_H"
+    fi
+
+    mv -f "$QMAKE_QCONFIG_H" "$QCONFIG_H"
+
+    #mkspecs/default is used as a (gasp!) default mkspec so QMAKESPEC needn't be set once configured
+    rm -rf mkspecs/default
+    ln -s `echo $XQMAKESPEC | sed "s,^${relpath}/mkspecs/,,"` mkspecs/default
+    # fix makefiles
+    for mkfile in GNUmakefile Makefile; do
+        EXTRA_LFLAGS=
+        EXTRA_CFLAGS=
+        in_mkfile="${mkfile}.in"
+        if [ "$mkfile" = "Makefile" ]; then
+#           if which qmake >/dev/null 2>&1 && [ -f qmake/qmake.pro ]; then
+#               (cd qmake && qmake) >/dev/null 2>&1 && continue
+#           fi
+            in_mkfile="${mkfile}.unix"
+        fi
+        in_mkfile="$relpath/qmake/$in_mkfile"
+        mkfile="$outpath/qmake/$mkfile"
+        if [ -f "$mkfile" ]; then
+            [ "$CFG_DEV" = "yes" ] && "$WHICH" chflags >/dev/null 2>&1 && chflags nouchg "$mkfile"
+            rm -f "$mkfile"
+        fi
+        [ -f "$in_mkfile" ] || continue
+
+        echo "########################################################################" > "$mkfile"
+        echo "## This file was autogenerated by configure, all changes will be lost ##" >> "$mkfile"
+        echo "########################################################################" >> "$mkfile"
+        EXTRA_OBJS=
+        EXTRA_SRCS=
+        EXTRA_CFLAGS="\$(QMAKE_CFLAGS)"
+        EXTRA_CXXFLAGS="\$(QMAKE_CXXFLAGS)"
+        EXTRA_LFLAGS="\$(QMAKE_LFLAGS)"
+
+        if [ "$PLATFORM" = "irix-cc" ] || [ "$PLATFORM" = "irix-cc-64" ]; then
+	    EXTRA_LFLAGS="$EXTRA_LFLAGS -lm"
+        fi
+
+	[ -n "$CC" ] && echo "CC = $CC" >> "$mkfile"
+	[ -n "$CXX" ] && echo "CXX = $CXX" >> "$mkfile"
+        [ "$CFG_SILENT" = "yes" ] && CC_TRANSFORM='s,^,\@,' || CC_TRANSFORM=
+        [ -z "$CC" ] && setBootstrapVariable QMAKE_CC CC "$CC_TRANSFORM"
+        [ -z "$CXX" ] && setBootstrapVariable QMAKE_CXX CXX "$CC_TRANSFORM"
+        setBootstrapVariable QMAKE_CFLAGS
+        setBootstrapVariable QMAKE_CXXFLAGS
+        setBootstrapVariable QMAKE_LFLAGS
+
+        if [ $QT_EDITION = "QT_EDITION_OPENSOURCE" ]; then
+            EXTRA_CFLAGS="$EXTRA_CFLAGS -DQMAKE_OPENSOURCE_EDITION"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS -DQMAKE_OPENSOURCE_EDITION"
+        fi
+        if [ "$CFG_RELEASE_QMAKE" = "yes" ]; then
+            setBootstrapVariable QMAKE_CFLAGS_RELEASE
+            setBootstrapVariable QMAKE_CXXFLAGS_RELEASE
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QMAKE_CFLAGS_RELEASE)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(QMAKE_CXXFLAGS_RELEASE)"
+        elif [ "$CFG_DEBUG" = "yes" ]; then
+            setBootstrapVariable QMAKE_CFLAGS_DEBUG
+            setBootstrapVariable QMAKE_CXXFLAGS_DEBUG
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(QMAKE_CFLAGS_DEBUG)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(QMAKE_CXXFLAGS_DEBUG)"
+        fi
+
+        if [ -n "$RPATH_FLAGS" ] && [ -n "`getQMakeConf 'QMAKE_(LFLAGS_)?RPATH'`" ]; then
+            setBootstrapVariable "QMAKE_(LFLAGS_)?RPATH" QMAKE_LFLAGS_RPATH
+            for rpath in $RPATH_FLAGS; do
+                EXTRA_LFLAGS="\$(QMAKE_LFLAGS_RPATH)\"$rpath\" $EXTRA_LFLAGS"
+            done
+        fi
+        if [ "$BUILD_ON_MAC" = "yes" ]; then
+            case "$PLATFORM" in
+            *macx-clang-libc++)
+                # Avoid overriding the default configuration settings when building with clang/libc++
+                ;;
+            *)
+                # For all other configurations require a minimum of 10.5
+                echo "export MACOSX_DEPLOYMENT_TARGET = 10.5" >> "$mkfile"
+                ;;
+            esac
+
+            echo "CARBON_LFLAGS =-framework ApplicationServices" >>"$mkfile"
+            echo "CARBON_CFLAGS =-fconstant-cfstrings" >>"$mkfile"
+            EXTRA_LFLAGS="$EXTRA_LFLAGS \$(CARBON_LFLAGS)"
+            EXTRA_CFLAGS="$EXTRA_CFLAGS \$(CARBON_CFLAGS)"
+            EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(CARBON_CFLAGS)"
+            EXTRA_OBJS="qsettings_mac.o qcore_mac.o"
+            EXTRA_SRCS="\"$relpath/src/corelib/io/qsettings_mac.cpp\" \"$relpath/src/corelib/kernel/qcore_mac.cpp\""
+	    if echo "$CFG_MAC_ARCHS" | grep x86 > /dev/null 2>&1; then # matches both x86 and x86_64
+		X86_CFLAGS="-arch i386"
+		X86_LFLAGS="-arch i386"
+		EXTRA_CFLAGS="$X86_CFLAGS $EXTRA_CFLAGS"
+		EXTRA_CXXFLAGS="$X86_CFLAGS $EXTRA_CXXFLAGS"
+                EXTRA_LFLAGS="$EXTRA_LFLAGS $X86_LFLAGS"
+            fi
+	    if echo "$CFG_MAC_ARCHS" | grep ppc > /dev/null 2>&1; then # matches both ppc and ppc64
+		PPC_CFLAGS="-arch ppc"
+		PPC_LFLAGS="-arch ppc"
+		EXTRA_CFLAGS="$PPC_CFLAGS $EXTRA_CFLAGS"
+		EXTRA_CXXFLAGS="$PPC_CFLAGS $EXTRA_CXXFLAGS"
+                EXTRA_LFLAGS="$EXTRA_LFLAGS $PPC_LFLAGS"
+            fi
+	    if [ '!' -z "$CFG_SDK" ]; then
+		echo "SDK_LFLAGS =-Wl,-syslibroot,$CFG_SDK" >>"$mkfile"
+		echo "SDK_CFLAGS =-isysroot $CFG_SDK" >>"$mkfile"
+		EXTRA_CFLAGS="$EXTRA_CFLAGS \$(SDK_CFLAGS)"
+		EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS \$(SDK_CFLAGS)"
+		EXTRA_LFLAGS="$EXTRA_LFLAGS \$(SDK_LFLAGS)"
+            fi
+        fi
+        [ "$CFG_EMBEDDED" != "no" ] && EXTRA_CFLAGS="$EXTRA_CFLAGS -DQWS"
+        if [ '!' -z "$D_FLAGS" ]; then
+            for DEF in $D_FLAGS; do
+                EXTRA_CFLAGS="$EXTRA_CFLAGS \"-D${DEF}\""
+            done
+        fi
+        QMAKE_BIN_DIR="$QT_INSTALL_BINS"
+        [ -z "$QMAKE_BIN_DIR" ] && QMAKE_BIN_DIR="${QT_INSTALL_PREFIX}/bin"
+        QMAKE_DATA_DIR="$QT_INSTALL_DATA"
+        [ -z "$QMAKE_DATA_DIR" ] && QMAKE_DATA_DIR="${QT_INSTALL_PREFIX}"
+        echo >>"$mkfile"
+	adjrelpath=`echo "$relpath" | sed 's/ /\\\\\\\\ /g'`
+	adjoutpath=`echo "$outpath" | sed 's/ /\\\\\\\\ /g'`
+	adjqmakespec=`echo "$QMAKESPEC" | sed 's/ /\\\\\\\\ /g'`
+        sed -e "s,@SOURCE_PATH@,$adjrelpath,g" -e "s,@BUILD_PATH@,$adjoutpath,g" \
+            -e "s,@QMAKE_CFLAGS@,$EXTRA_CFLAGS,g" -e "s,@QMAKE_LFLAGS@,$EXTRA_LFLAGS,g" \
+            -e "s,@QMAKE_CXXFLAGS@,$EXTRA_CXXFLAGS,g" \
+            -e "s,@QT_INSTALL_BINS@,\$(INSTALL_ROOT)$QMAKE_BIN_DIR,g" \
+            -e "s,@QT_INSTALL_DATA@,\$(INSTALL_ROOT)$QMAKE_DATA_DIR,g" \
+            -e "s,@QMAKE_QTOBJS@,$EXTRA_OBJS,g" -e "s,@QMAKE_QTSRCS@,$EXTRA_SRCS,g" \
+	    -e "s,@QMAKESPEC@,$adjqmakespec,g" "$in_mkfile" >>"$mkfile"
+
+        if "$WHICH" makedepend >/dev/null 2>&1 && grep 'depend:' "$mkfile" >/dev/null 2>&1; then
+            (cd "$outpath/qmake" && "$MAKE" -f "$mkfile" depend) >/dev/null 2>&1
+	    sed "s,^.*/\([^/]*.o\):,\1:,g" "$mkfile" >"$mkfile.tmp"
+	    sed "s,$outpath,$adjoutpath,g" "$mkfile.tmp" >"$mkfile"
+	    rm "$mkfile.tmp"
+        fi
+    done
+
+    QMAKE_BUILD_ERROR=no
+    (cd "$outpath/qmake"; "$MAKE") || QMAKE_BUILD_ERROR=yes
+    [ '!' -z "$QCONFIG_H" ] && mv -f "$QCONFIG_H" "$QMAKE_QCONFIG_H" #move qmake's qconfig.h to qconfig.h.qmake
+    [ '!' -z "$OLD_QCONFIG_H" ] && mv -f "${OLD_QCONFIG_H}.old" "$OLD_QCONFIG_H" #put back qconfig.h
+    [ "$QMAKE_BUILD_ERROR" = "yes" ] && exit 2
+fi # Build qmake
+
+#-------------------------------------------------------------------------------
+# write out device config before we run the test.
+#-------------------------------------------------------------------------------
+DEVICE_VARS_OUTFILE="$outpath/mkspecs/qdevice.pri"
+if cmp -s "$DEVICE_VARS_FILE" "$DEVICE_VARS_OUTFILE"; then
+    rm -f "$DEVICE_VARS_FILE"
+else
+    mv -f $DEVICE_VARS_FILE "$DEVICE_VARS_OUTFILE"
+    DEVICE_VARS_FILE="$DEVICE_VARS_OUTFILE"
+fi
+
+if [ -z "$PKG_CONFIG" ]; then
+    # See if PKG_CONFIG is set in the mkspec or device options
+    (echo TEMPLATE = subdirs
+     echo 'message($$PKG_CONFIG)') > "$outpath/dummy.pro"
+    echo "QT_BUILD_TREE = $outpath" > "$outpath/.qmake.cache.pkgconfig"
+    PKG_CONFIG=`"$outpath/bin/qmake" -cache "$outpath/.qmake.cache.pkgconfig" -spec "$XQMAKESPEC" "$outpath/dummy.pro" -o /dev/null 2>&1 > /dev/null | sed -n -e 's,Project MESSAGE: \(.*\),\1,p'`
+    rm "$outpath/.qmake.cache.pkgconfig" "$outpath/dummy.pro"
+fi
+if [ -z "$PKG_CONFIG" ]; then
+    PKG_CONFIG=`"$WHICH" pkg-config 2>/dev/null`
+fi
+
+# Work out if we can use pkg-config
+if [ "$QT_CROSS_COMPILE" = "yes" ]; then
+    if [ "$QT_FORCE_PKGCONFIG" = "yes" ]; then
+        echo >&2 ""
+        echo >&2 "You have asked to use pkg-config and are cross-compiling."
+        echo >&2 "Please make sure you have a correctly set-up pkg-config"
+        echo >&2 "environment!"
+        echo >&2 ""
+        if [ -z "$PKG_CONFIG_PATH" ]; then
+            echo >&2 ""
+            echo >&2 "Warning: PKG_CONFIG_PATH has not been set.  This could mean"
+            echo >&2 "the host compiler's .pc files will be used. This is probably"
+            echo >&2 "not what you want."
+            echo >&2 ""
+        elif [ -z "$PKG_CONFIG_SYSROOT" ] && [ -z "$PKG_CONFIG_SYSROOT_DIR" ]; then
+            echo >&2 ""
+            echo >&2 "Warning: PKG_CONFIG_SYSROOT/PKG_CONFIG_SYSROOT_DIR has not"
+            echo >&2 "been set. This means your toolchain's .pc files must contain"
+            echo >&2 "the paths to the toolchain's libraries & headers. If configure"
+            echo >&2 "tests are failing, please check these files."
+            echo >&2 ""
+        fi
+    else
+        echo >&2 ""
+        echo >&2 "You have not explicitly asked to use pkg-config and are cross-compiling."
+        echo >&2 "pkg-config will not be used to automatically query cflag/lib parameters for"
+        echo >&2 "dependencies"
+        echo >&2 ""
+        PKG_CONFIG=""
+    fi
+fi
+
+if [ ! -n "$PKG_CONFIG" ]; then
+    QT_CONFIG="$QT_CONFIG no-pkg-config"
+fi
+
+#-------------------------------------------------------------------------------
+# tests that need qmake
+#-------------------------------------------------------------------------------
+
+# parameters: path, name, extra args
+compileTest()
+{
+    path=config.tests/$1
+    name=$2
+    shift 2
+    "$unixtests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" "$path" "$name" $I_FLAGS $L_FLAGS $l_FLAGS $MAC_CONFIG_TEST_COMMANDLINE "$@"
+}
+
+# detect availability of float math.h functions
+if compileTest unix/floatmath "floatmath"; then
+    CFG_USE_FLOATMATH=yes
+else
+    CFG_USE_FLOATMATH=no
+fi
+
+# detect mmx support
+if [ "${CFG_MMX}" = "auto" ]; then
+    if compileTest unix/mmx "mmx" "-mmmx"; then
+	CFG_MMX=yes
+    else
+	CFG_MMX=no
+    fi
+fi
+
+# detect 3dnow support
+if [ "${CFG_MMX}" = "auto" ]; then
+    CFG_3DNOW=no
+fi
+if [ "${CFG_3DNOW}" = "auto" ]; then
+    if compileTest unix/3dnow "3dnow" "-m3dnow"; then
+	CFG_3DNOW=yes
+    else
+	CFG_3DNOW=no
+    fi
+fi
+
+# detect sse support
+if [ "${CFG_MMX}" = "auto" ]; then
+    CFG_SSE=no
+fi
+if [ "${CFG_SSE}" = "auto" ]; then
+    if compileTest unix/sse "sse" "-msse"; then
+	CFG_SSE=yes
+    else
+	CFG_SSE=no
+    fi
+fi
+
+# detect sse2 support
+if [ "${CFG_SSE}" = "auto" ]; then
+    CFG_SSE2=no
+fi
+if [ "${CFG_SSE2}" = "auto" ]; then
+    if compileTest unix/sse2 "sse2" "-msse2"; then
+       CFG_SSE2=yes
+    else
+       CFG_SSE2=no
+    fi
+fi
+
+# detect sse3 support
+if [ "${CFG_SSE2}" = "no" ]; then
+    CFG_SSE3=no
+fi
+if [ "${CFG_SSE3}" = "auto" ]; then
+    if compileTest unix/sse3 "sse3" "-msse3"; then
+       CFG_SSE3=yes
+    else
+       CFG_SSE3=no
+    fi
+fi
+
+# detect ssse3 support
+if [ "${CFG_SSE3}" = "no" ]; then
+    CFG_SSSE3=no
+fi
+if [ "${CFG_SSSE3}" = "auto" ]; then
+    if compileTest unix/ssse3 "ssse3" "-mssse3"; then
+       CFG_SSSE3=yes
+    else
+       CFG_SSSE3=no
+    fi
+fi
+
+# detect sse4.1 support
+if [ "${CFG_SSSE3}" = "no" ]; then
+    CFG_SSE4_1=no
+fi
+if [ "${CFG_SSE4_1}" = "auto" ]; then
+    if compileTest unix/sse4_1 "sse4_1" "-msse4.1"; then
+       CFG_SSE4_1=yes
+    else
+       CFG_SSE4_1=no
+    fi
+fi
+
+# detect sse4.2 support
+if [ "${CFG_SSE4_1}" = "no" ]; then
+    CFG_SSE4_2=no
+fi
+if [ "${CFG_SSE4_2}" = "auto" ]; then
+    if compileTest unix/sse4_2 "sse4_2" "-msse4.2"; then
+       CFG_SSE4_2=yes
+    else
+       CFG_SSE4_2=no
+    fi
+fi
+
+# detect avx support
+if [ "${CFG_SSE4_2}" = "no" ]; then
+    CFG_AVX=no
+fi
+if [ "${CFG_AVX}" = "auto" ]; then
+    if compileTest unix/avx "avx" "-mavx"; then
+       CFG_AVX=yes
+    else
+       CFG_AVX=no
+    fi
+fi
+
+# check iWMMXt support
+if [ "$CFG_IWMMXT" = "yes" ]; then
+    compileTest unix/iwmmxt "iwmmxt" "-mcpu=iwmmxt"
+    if [ $? != "0" ]; then
+        echo "The iWMMXt functionality test failed!"
+	echo " Please make sure your compiler supports iWMMXt intrinsics!"
+	exit 1
+    fi
+fi
+
+# detect neon support
+if [ "$CFG_ARCH" = "arm" ] && [ "${CFG_NEON}" = "auto" ]; then
+    if compileTest unix/neon "neon" "-mfpu=neon"; then
+	CFG_NEON=yes
+    else
+	CFG_NEON=no
+    fi
+fi
+
+[ "$XPLATFORM_MINGW" = "yes" ] && QMakeVar add styles "windowsxp windowsvista"
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    QMakeVar set styles "windows s60"   #overwrite previous default
+    CFG_LIBFREETYPE=no
+    CFG_ZLIB=yes
+
+    if [ "$CFG_LARGEFILE" = auto ]; then
+        CFG_LARGEFILE=no
+    fi
+    if [ "$CFG_PHONON" = auto ]; then
+        CFG_PHONON=yes
+    fi
+
+    if test -z "$EPOCROOT"; then
+        echo "Please export EPOCROOT. It should point to the sdk install dir"
+        exit 1
+    fi
+    if test ! -d "$EPOCROOT/epoc32"; then
+        echo "Could not find the 'epoc32' dir in your EPOCROOT."
+        exit 1
+    fi
+
+    if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+        # Raptor does not support configure tests.
+
+        # the main commands needed to compile;
+        (mkdir -p config.tests/symbian/rcomp
+            cd config.tests/symbian/rcomp
+            rm -f rcomp_test.rsg
+            touch rcomp_test.rpp rcomp_test.rsc rcomp_test.rss
+            rcomp -u -m045,046,047 -s./rcomp_test.rpp -o./rcomp_test.rsc -h./rcomp_test.rsg -i./rcomp_test.rss 2>&1 > /dev/null
+            if test ! -f rcomp_test.rsg; then
+                echo "Finding a working rcomp in your PATH failed."
+                echo "Fatal error. Make sure you have the epoc tools working and in your PATH";
+                exit 1;
+            fi
+        )
+
+        # compile a simple main that uses printf
+        if ! "$symbiantests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/symbian/simple "simple" $L_FLAGS $I_FLAGS $l_FLAGS
+        then
+            echo "Testing your compiler failed. Could not compile a simple application."
+            echo "Fatal error; Rerun configure with -verbose to get more details."
+            exit 1;
+        fi
+    fi
+fi
+# Adjust all variables for INTEGRITY
+if [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    QMakeVar set gfx-drivers "integrityfb"
+    QMakeVar set kbd-drivers "integrity"
+    QMakeVar set mouse-drivers "integrity"
+    CFG_TIFF="no"
+    CFG_KBD_ON="integrity"
+    CFG_MOUSE_ON="integrity"
+    CFG_GFX_ON="integrityfb"
+    CFG_LARGEFILE="no"
+    CFG_STL="yes"
+    CFG_OPENSSL="no"
+    CFG_GLIB="no"
+    CFG_SHARED="no"
+    if [ "$CFG_SCRIPT" != "yes" ]; then
+      CFG_SCRIPT="no"
+    fi
+    CFG_BUILD_PARTS="libs examples demos"
+    CFG_GIF="no"
+fi
+
+# check IPC support
+if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    # Raptor does not support configure tests.
+    if ! compileTest unix/ipc_sysv "ipc_sysv" ; then
+        # SYSV IPC is not supported - check POSIX IPC
+        if compileTest unix/ipc_posix "ipc_posix" ; then
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_POSIX_IPC"
+        else
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SYSTEMSEMAPHORE QT_NO_SHAREDMEMORY"
+            if [ "$PLATFORM_QWS" = "yes" ]; then
+                QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SEMAPHORE QT_NO_QWS_MULTIPROCESS QT_NO_QWS_SHARE_FONTS"
+            fi
+        fi
+    fi
+fi
+
+# detect zlib
+if [ "$CFG_ZLIB" = "no" ]; then
+    # Note: Qt no longer support builds without zlib
+    # So we force a "no" to be "auto" here.
+    # If you REALLY really need no zlib support, you can still disable
+    # it by doing the following:
+    #   add "no-zlib" to mkspecs/qconfig.pri
+    #   #define QT_NO_COMPRESS (probably by adding to src/corelib/global/qconfig.h)
+    #
+    # There's no guarantee that Qt will build under those conditions
+
+    CFG_ZLIB=auto
+    ZLIB_FORCED=yes
+fi
+if [ "$CFG_ZLIB" = "auto" ]; then
+    if compileTest unix/zlib "zlib"; then
+       CFG_ZLIB=system
+    else
+       CFG_ZLIB=yes
+    fi
+fi
+
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    if [ "$CFG_SLOG2" != "no" ]; then
+        if compileTest unix/slog2 "slog2"; then
+            CFG_SLOG2=yes
+            QMAKE_CONFIG="$QMAKE_CONFIG slog2"
+        else
+            CFG_SLOG2=no
+        fi
+    fi
+fi
+
+if [ "$CFG_LARGEFILE" = "auto" ]; then
+    #Large files should be enabled for all Linux systems
+    CFG_LARGEFILE=yes
+fi
+
+
+if [ "$CFG_S60" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        CFG_S60=yes
+    else
+        CFG_S60=no
+    fi
+fi
+
+if [ "$CFG_QS60STYLE" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        CFG_QS60STYLE=qt
+    else
+        CFG_QS60STYLE=no
+    fi
+fi
+
+if [ "$CFG_SYMBIAN_DEFFILES" = "auto" ]; then
+    # elf2e32 crashes when using def files together with gcce.
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ] && [ "$CFG_DEV" = "no" ] && [ "$XPLATFORM" != "symbian-gcce" ]; then
+        CFG_SYMBIAN_DEFFILES=yes
+    else
+        CFG_SYMBIAN_DEFFILES=no
+    fi
+fi
+
+# detect how jpeg should be built
+if [ "$CFG_JPEG" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_JPEG=plugin
+    else
+        CFG_JPEG=yes
+    fi
+fi
+# detect jpeg
+if [ "$CFG_LIBJPEG" = "auto" ]; then
+    if compileTest unix/libjpeg "libjpeg"; then
+       CFG_LIBJPEG=system
+    else
+       CFG_LIBJPEG=qt
+    fi
+fi
+
+# detect how gif should be built
+if [ "$CFG_GIF" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_GIF=plugin
+    else
+        CFG_GIF=yes
+    fi
+fi
+
+# detect how tiff should be built
+if [ "$CFG_TIFF" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_TIFF=plugin
+    else
+        CFG_TIFF=yes
+    fi
+fi
+
+# detect tiff
+if [ "$CFG_LIBTIFF" = "auto" ]; then
+    if compileTest unix/libtiff "libtiff"; then
+        CFG_LIBTIFF=system
+    else
+        CFG_LIBTIFF=qt
+    fi
+fi
+
+# detect how mng should be built
+if [ "$CFG_MNG" = "auto" ]; then
+    if [ "$CFG_SHARED" = "yes" ]; then
+        CFG_MNG=plugin
+    else
+        CFG_MNG=yes
+    fi
+fi
+# detect mng
+if [ "$CFG_LIBMNG" = "auto" ]; then
+    if compileTest unix/libmng "libmng"; then
+       CFG_LIBMNG=system
+    else
+       CFG_LIBMNG=qt
+    fi
+fi
+
+# detect png
+if [ "$CFG_LIBPNG" = "auto" ]; then
+    if compileTest unix/libpng "libpng"; then
+       CFG_LIBPNG=system
+    else
+       CFG_LIBPNG=qt
+    fi
+fi
+
+# detect accessibility
+if [ "$CFG_ACCESSIBILITY" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        # accessibility is currently unsupported
+        CFG_ACCESSIBILITY=no
+    else
+        CFG_ACCESSIBILITY=yes
+    fi
+fi
+
+# auto-detect SQL-modules support
+for _SQLDR in $CFG_SQL_AVAILABLE; do
+        case $_SQLDR in
+        mysql)
+            if [ "$CFG_SQL_mysql" != "no" ]; then
+		[ -z "$CFG_MYSQL_CONFIG" ] && CFG_MYSQL_CONFIG=`"$WHICH" mysql_config`
+                if [ -x "$CFG_MYSQL_CONFIG" ]; then
+                    QT_CFLAGS_MYSQL=`$CFG_MYSQL_CONFIG --include 2>/dev/null`
+                    QT_LFLAGS_MYSQL_R=`$CFG_MYSQL_CONFIG --libs_r 2>/dev/null`
+                    QT_LFLAGS_MYSQL=`$CFG_MYSQL_CONFIG --libs 2>/dev/null`
+		    QT_MYSQL_VERSION=`$CFG_MYSQL_CONFIG --version 2>/dev/null`
+                    QT_MYSQL_VERSION_MAJOR=`echo $QT_MYSQL_VERSION | cut -d . -f 1`
+                fi
+                if [ -n "$QT_MYSQL_VERSION" ] && [ "$QT_MYSQL_VERSION_MAJOR" -lt 4 ]; then
+                    if [ "$CFG_SQL_mysql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "This version of MySql is not supported ($QT_MYSQL_VERSION)."
+                        echo " You need MySql 4 or higher."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_mysql="no"
+			QT_LFLAGS_MYSQL=""
+			QT_LFLAGS_MYSQL_R=""
+			QT_CFLAGS_MYSQL=""
+                    fi
+                else
+                    if compileTest unix/mysql_r "MySQL (thread-safe)" $QT_LFLAGS_MYSQL_R $QT_CFLAGS_MYSQL; then
+                        QMakeVar add CONFIG use_libmysqlclient_r
+                        if [ "$CFG_SQL_mysql" = "auto" ]; then
+                            CFG_SQL_mysql=plugin
+                        fi
+                        QT_LFLAGS_MYSQL="$QT_LFLAGS_MYSQL_R"
+                    elif compileTest unix/mysql "MySQL (thread-unsafe)" $QT_LFLAGS_MYSQL $QT_CFLAGS_MYSQL; then
+                        if [ "$CFG_SQL_mysql" = "auto" ]; then
+                            CFG_SQL_mysql=plugin
+                        fi
+                    else
+                        if [ "$CFG_SQL_mysql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                            echo "MySQL support cannot be enabled due to functionality tests!"
+                            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                            echo " If you believe this message is in error you may use the continue"
+                            echo " switch (-continue) to $0 to continue."
+                            exit 101
+                        else
+                            CFG_SQL_mysql=no
+			    QT_LFLAGS_MYSQL=""
+			    QT_LFLAGS_MYSQL_R=""
+			    QT_CFLAGS_MYSQL=""
+                        fi
+                    fi
+                fi
+            fi
+            ;;
+        psql)
+            if [ "$CFG_SQL_psql" != "no" ]; then
+                [ -z "$CFG_PSQL_CONFIG" ] && CFG_PSQL_CONFIG=`"$WHICH" pg_config`
+                # Be careful not to use native pg_config when cross building.
+                if [ "$XPLATFORM_MINGW" != "yes" ] && [ -x "$CFG_PSQL_CONFIG" ]; then
+                    QT_CFLAGS_PSQL=`$CFG_PSQL_CONFIG --includedir 2>/dev/null`
+                    QT_LFLAGS_PSQL=`$CFG_PSQL_CONFIG --libdir 2>/dev/null`
+                fi
+                [ -z "$QT_CFLAGS_PSQL" ] || QT_CFLAGS_PSQL="-I$QT_CFLAGS_PSQL"
+                [ -z "$QT_LFLAGS_PSQL" ] || QT_LFLAGS_PSQL="-L$QT_LFLAGS_PSQL"
+                # But, respect PSQL_LIBS if set
+                [ -z "$PSQL_LIBS" ] || QT_LFLAGS_PSQL="$PSQL_LIBS"
+                if compileTest unix/psql "PostgreSQL" $QT_LFLAGS_PSQL $QT_CFLAGS_PSQL; then
+                    if [ "$CFG_SQL_psql" = "auto" ]; then
+                        CFG_SQL_psql=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_psql" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "PostgreSQL support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_psql=no
+                        QT_CFLAGS_PSQL=""
+                        QT_LFLAGS_PSQL=""
+                    fi
+                fi
+            fi
+        ;;
+        odbc)
+            if [ "$CFG_SQL_odbc" != "no" ]; then
+                if ( [ "$PLATFORM_MAC" != "yes" ] || [ "$XPLATFORM_MINGW" = "yes" ] ) && compileTest unix/odbc "ODBC"; then
+                    if [ "$CFG_SQL_odbc" = "auto" ]; then
+                        CFG_SQL_odbc=plugin
+                    fi
+                else
+                    if compileTest unix/iodbc "iODBC"; then
+                        QT_LFLAGS_ODBC="-liodbc"
+                        if [ "$CFG_SQL_odbc" = "auto" ]; then
+                            CFG_SQL_odbc=plugin
+                        fi
+                    else
+                        if [ "$CFG_SQL_odbc" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                            echo "ODBC support cannot be enabled due to functionality tests!"
+                            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                            echo " If you believe this message is in error you may use the continue"
+                            echo " switch (-continue) to $0 to continue."
+                            exit 101
+                        else
+                            CFG_SQL_odbc=no
+                        fi
+                    fi
+                fi
+            fi
+            ;;
+        oci)
+            if [ "$CFG_SQL_oci" != "no" ]; then
+                if compileTest unix/oci "OCI"; then
+                    if [ "$CFG_SQL_oci" = "auto" ]; then
+                        CFG_SQL_oci=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_oci" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "Oracle (OCI) support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_oci=no
+                    fi
+                fi
+            fi
+            ;;
+        tds)
+            if [ "$CFG_SQL_tds" != "no" ]; then
+                [ -z "$SYBASE" ] || QT_LFLAGS_TDS="-L$SYBASE/lib"
+                [ -z "$SYBASE_LIBS" ] || QT_LFLAGS_TDS="$QT_LFLAGS_TDS $SYBASE_LIBS"
+                if compileTest unix/tds "TDS" $QT_LFLAGS_TDS; then
+                    if [ "$CFG_SQL_tds" = "auto" ]; then
+                        CFG_SQL_tds=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_tds" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "TDS support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_tds=no
+                    fi
+                fi
+            fi
+            ;;
+        db2)
+            if [ "$CFG_SQL_db2" != "no" ]; then
+                if compileTest unix/db2 "DB2"; then
+                    if [ "$CFG_SQL_db2" = "auto" ]; then
+                        CFG_SQL_db2=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_db2" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "ODBC support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_db2=no
+                    fi
+                fi
+            fi
+            ;;
+        ibase)
+            if [ "$CFG_SQL_ibase" != "no" ]; then
+                if compileTest unix/ibase "InterBase"; then
+                    if [ "$CFG_SQL_ibase" = "auto" ]; then
+                        CFG_SQL_ibase=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_ibase" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "InterBase support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_ibase=no
+                    fi
+                fi
+            fi
+            ;;
+        sqlite2)
+            if [ "$CFG_SQL_sqlite2" != "no" ]; then
+                if compileTest unix/sqlite2 "SQLite2"; then
+                    if [ "$CFG_SQL_sqlite2" = "auto" ]; then
+                        CFG_SQL_sqlite2=plugin
+                    fi
+                else
+                    if [ "$CFG_SQL_sqlite2" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                        echo "SQLite2 support cannot be enabled due to functionality tests!"
+                        echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                        echo " If you believe this message is in error you may use the continue"
+                        echo " switch (-continue) to $0 to continue."
+                        exit 101
+                    else
+                        CFG_SQL_sqlite2=no
+                    fi
+                fi
+            fi
+            ;;
+        sqlite)
+            if [ "$CFG_SQL_sqlite" = "auto" ]; then # the default
+                if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+                    # sqlite on symbian is typically not build in Qt but deployed as a pre-existing sis file and should be marked as driver.
+                    # Configuration parameters should be set
+                    CFG_SQL_sqlite=qt
+                    QT_LFLAGS_SQLITE=-lsqlite3
+                    QMAKE_CONFIG="$QMAKE_CONFIG system-sqlite"
+                fi
+            fi
+            if [ "$CFG_SQL_sqlite" != "no" ]; then
+                SQLITE_AUTODETECT_FAILED="no"
+                if [ "$CFG_SQLITE" = "system" ]; then
+                    if [ -n "$PKG_CONFIG" ]; then
+                        QT_CFLAGS_SQLITE=`$PKG_CONFIG --cflags sqlite3 2>/dev/null`
+                        QT_LFLAGS_SQLITE=`$PKG_CONFIG --libs sqlite3 2>/dev/null`
+                    else
+                        QT_CFLAGS_SQLITE=
+                        QT_LFLAGS_SQLITE="-lsqlite3 -lz"
+                    fi
+                    if compileTest unix/sqlite "SQLite" $QT_LFLAGS_SQLITE $QT_CFLAGS_SQLITE; then
+                        if [ "$CFG_SQL_sqlite" = "auto" ]; then
+                            CFG_SQL_sqlite=plugin
+                        fi
+                        QMAKE_CONFIG="$QMAKE_CONFIG system-sqlite"
+                    else
+                        SQLITE_AUTODETECT_FAILED="yes"
+                        CFG_SQL_sqlite=no
+                    fi
+                elif [ -f "$relpath/src/3rdparty/sqlite/sqlite3.h" ]; then
+                    if [ "$CFG_SQL_sqlite" = "auto" ]; then
+                            CFG_SQL_sqlite=plugin
+                    fi
+                else
+                    SQLITE_AUTODETECT_FAILED="yes"
+                    CFG_SQL_sqlite=no
+                fi
+
+                if [ "$SQLITE_AUTODETECT_FAILED" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "SQLite support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                fi
+            fi
+            ;;
+        *)
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo "unknown SQL driver: $_SQLDR"
+            fi
+            ;;
+        esac
+done
+
+# auto-detect NIS support
+if [ "$CFG_NIS" != "no" ]; then
+    if compileTest unix/nis "NIS"; then
+        CFG_NIS=yes
+    else
+        if [ "$CFG_NIS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "NIS support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_NIS=no
+        fi
+    fi
+fi
+
+# auto-detect CUPS support
+if [ "$CFG_CUPS" != "no" ]; then
+    if compileTest unix/cups "Cups"; then
+        CFG_CUPS=yes
+    else
+        if [ "$CFG_CUPS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "Cups support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_CUPS=no
+        fi
+    fi
+fi
+
+# auto-detect iconv(3) support
+if [ "$CFG_ICONV" != "no" ]; then
+    if [ "$PLATFORM_QWS" = "yes" ] || [ "$PLATFORM_QPA" = "yes" -a "$CFG_ICONV" = "auto" ]; then
+        CFG_ICONV=no
+    elif compileTest "unix/iconv" "POSIX iconv"; then
+        CFG_ICONV=yes
+    elif compileTest "unix/sun-libiconv" "SUN libiconv"; then
+        CFG_ICONV=sun
+    elif compileTest "unix/gnu-libiconv" "GNU libiconv"; then
+        CFG_ICONV=gnu
+    else
+        if [ "$CFG_ICONV" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "Iconv support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_ICONV=no
+        fi
+    fi
+fi
+
+# auto-detect libdbus-1 support
+if [ "$CFG_DBUS" != "no" ]; then
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --atleast-version="$MIN_DBUS_1_VERSION" dbus-1 2>/dev/null; then
+        QT_CFLAGS_DBUS=`$PKG_CONFIG --cflags dbus-1 2>/dev/null`
+        QT_LIBS_DBUS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
+    fi
+    if compileTest unix/dbus "D-Bus" $QT_CFLAGS_DBUS $QT_LIBS_DBUS; then
+        [ "$CFG_DBUS" = "auto" ] && CFG_DBUS=yes
+        QMakeVar set QT_CFLAGS_DBUS "$QT_CFLAGS_DBUS"
+        QMakeVar set QT_LIBS_DBUS "$QT_LIBS_DBUS"
+    else
+        if [ "$CFG_DBUS" = "auto" ]; then
+            CFG_DBUS=no
+        elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            # CFG_DBUS is "yes" or "linked" here
+
+            echo "The QtDBus module cannot be enabled because libdbus-1 version $MIN_DBUS_1_VERSION was not found."
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_MULTIMEDIA" = "auto" ]; then
+    CFG_MULTIMEDIA="$CFG_GUI"
+fi
+
+if [ "$CFG_MULTIMEDIA" = "yes" ] && [ "$CFG_GUI" = "no" ]; then
+    echo "QtMultimedia requested, but it can't be built without QtGui"
+    exit 1
+fi
+
+# Generate a CRC of the namespace for using in constants for the Carbon port.
+# This should mean that you really *can* load two Qt's and have our custom
+# Carbon events work.
+if [ "$PLATFORM_MAC" = "yes" -a ! -z "$QT_NAMESPACE" ]; then
+    QT_NAMESPACE_MAC_CRC=`"$mactests/crc.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/mac/crc $QT_NAMESPACE $L_FLAGS $I_FLAGS $l_FLAGS $MAC_CONFIG_TEST_COMMANDLINE`
+fi
+
+# X11/QWS/Lighthouse
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+
+    # auto-detect Glib support
+    if [ "$CFG_GLIB" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_GLIB=`$PKG_CONFIG --cflags glib-2.0 gthread-2.0 2>/dev/null`
+            QT_LIBS_GLIB=`$PKG_CONFIG --libs glib-2.0 gthread-2.0 2>/dev/null`
+        fi
+        if compileTest unix/glib "Glib" $QT_CFLAGS_GLIB $QT_LIBS_GLIB $X11TESTS_FLAGS ; then
+            CFG_GLIB=yes
+            QMakeVar set QT_CFLAGS_GLIB "$QT_CFLAGS_GLIB"
+            QMakeVar set QT_LIBS_GLIB "$QT_LIBS_GLIB"
+        else
+            if [ "$CFG_GLIB" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Glib support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_GLIB=no
+            fi
+        fi
+    fi
+
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_PHONON" = "auto" ]; then
+            CFG_PHONON=no
+        fi
+        if [ "$CFG_PHONON" != "no" ]; then
+            echo "Phonon enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable Phonon"
+            exit 1
+        fi
+    fi
+
+    # Auto-detect GStreamer support (needed for Phonon)
+    if [ "$CFG_PHONON" != "no" ]; then
+        if [ "$CFG_GLIB" = "yes" -a "$CFG_GSTREAMER" != "no" ]; then
+            if [ -n "$PKG_CONFIG" ]; then
+                QT_CFLAGS_GSTREAMER=`$PKG_CONFIG --cflags gstreamer-0.10 gstreamer-plugins-base-0.10 2>/dev/null`
+                QT_LIBS_GSTREAMER=`$PKG_CONFIG --libs gstreamer-0.10 gstreamer-plugins-base-0.10 2>/dev/null`
+            fi
+            if compileTest unix/gstreamer "GStreamer" $QT_CFLAGS_GSTREAMER $QT_LIBS_GSTREAMER $X11TESTS_FLAGS; then
+                CFG_GSTREAMER=yes
+                QMakeVar set QT_CFLAGS_GSTREAMER "$QT_CFLAGS_GSTREAMER"
+                QMakeVar set QT_LIBS_GSTREAMER "$QT_LIBS_GSTREAMER"
+            else
+                if [ "$CFG_GSTREAMER" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "Gstreamer support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                else
+                    CFG_GSTREAMER=no
+                fi
+            fi
+        elif [ "$CFG_GLIB" = "no" ]; then
+            CFG_GSTREAMER=no
+        fi
+    else
+        CFG_GSTREAMER=no
+    fi
+
+    if [ "$CFG_PHONON" != "no" ]; then
+        if [ "$CFG_PHONON_BACKEND" != "no" ]; then
+            if [ "$CFG_GSTREAMER" = "yes" ]; then
+                CFG_PHONON=yes
+            else
+                if [ "$CFG_PHONON" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                    echo "Phonon support cannot be enabled due to functionality tests!"
+                    echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                    echo " If you believe this message is in error you may use the continue"
+                    echo " switch (-continue) to $0 to continue."
+                    exit 101
+                else
+                    CFG_PHONON=no
+                fi
+            fi
+        else
+            CFG_PHONON=yes
+        fi
+    fi
+
+    # auto-detect icd support
+    if [ "$CFG_GLIB" = "yes" -a "$CFG_ICD" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_CONNSETTINGS=`$PKG_CONFIG --cflags connsettings icd2 2>/dev/null`
+            QT_LIBS_CONNSETTINGS=`$PKG_CONFIG --libs connsettings icd2 2>/dev/null`
+        fi
+        if compileTest unix/icd "ICD" $QT_CFLAGS_CONNSETTINGS $QT_LIBS_CONNSETTINGS; then
+            [ "$CFG_ICD" = "auto" ] && CFG_ICD=yes
+            QMakeVar set QT_CFLAGS_CONNSETTINGS "$QT_CFLAGS_CONNSETTINGS"
+            QMakeVar set QT_LIBS_CONNSETTINGS "$QT_LIBS_CONNSETTINGS"
+        else
+            if [ "$CFG_ICD" = "auto" ]; then
+                CFG_ICD=no
+            elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                # CFG_ICD is "yes"
+
+                echo "The ICD Bearer Management plugin cannot be enabled because connsettings was not found."
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            fi
+        fi
+    elif [ "$CFG_GLIB" = "no" ]; then
+        CFG_ICD=no
+    fi
+
+    # auto-detect libicu support
+    if [ "$CFG_ICU" != "no" ]; then
+        if compileTest unix/icu "ICU"; then
+            [ "$CFG_ICU" = "auto" ] && CFG_ICU=yes
+        else
+            if [ "$CFG_ICU" = "auto" ]; then
+                CFG_ICU=no
+            elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                # CFG_ICU is "yes"
+
+                echo "The ICU library support cannot be enabled."
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            fi
+        fi
+    fi
+
+    # Auto-detect PulseAudio support
+    if [ "$CFG_PULSEAUDIO" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_PULSEAUDIO=`$PKG_CONFIG --cflags libpulse '>=' 0.9.10 libpulse-mainloop-glib 2>/dev/null`
+            QT_LIBS_PULSEAUDIO=`$PKG_CONFIG --libs libpulse '>=' 0.9.10 libpulse-mainloop-glib 2>/dev/null`
+        fi
+        if compileTest unix/pulseaudio "PulseAudio" $QT_CFLAGS_PULSEAUDIO $QT_LIBS_PULSEAUDIO $X11TESTS_FLAGS; then
+            CFG_PULSEAUDIO=yes
+            QMakeVar set QT_CFLAGS_PULSEAUDIO "$QT_CFLAGS_PULSEAUDIO"
+            QMakeVar set QT_LIBS_PULSEAUDIO "$QT_LIBS_PULSEAUDIO"
+        else
+            if [ "$CFG_PULSEAUDIO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "PulseAudio support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+		CFG_PULSEAUDIO=no
+            fi
+        fi
+    fi
+fi # X11/QWS/Lighthouse
+
+# X11
+if [ "$PLATFORM_X11" = "yes" -a "$CFG_GUI" != "no" ]; then
+    x11tests="$relpath/config.tests/x11"
+    X11TESTS_FLAGS=
+
+    # work around broken X11 headers when using GCC 2.95 or later
+    NOTYPE=no
+    "$x11tests/notype.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath" && NOTYPE=yes
+    if [ $NOTYPE = "yes" ]; then
+	QMakeVar add QMAKE_CXXFLAGS -fpermissive
+        X11TESTS_FLAGS="$X11TESTS_FLAGS -fpermissive"
+    fi
+
+    # Check we actually have X11 :-)
+    compileTest x11/xlib "XLib" $X11TESTS_FLAGS
+    if [ $? != "0" ]; then
+        echo "Basic XLib functionality test failed!"
+        echo " You might need to modify the include and library search paths by editing"
+        echo " QMAKE_INCDIR_X11 and QMAKE_LIBDIR_X11 in ${XQMAKESPEC}."
+        exit 1
+    fi
+fi
+
+# X11/MINGW/SYMBIAN OpenGL
+if [ "$PLATFORM_X11" = "yes" -o "$XPLATFORM_MINGW" = "yes" -o "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL=no
+        fi
+        if [ "$CFG_OPENGL" != "no" ]; then
+            echo "OpenGL enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable OpenGL"
+            exit 1
+        fi
+    fi
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        if compileTest x11/opengl "OpenGL" $X11TESTS_FLAGS; then
+            CFG_OPENGL=desktop
+        elif compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+            if [ "$CFG_EGL" = "no" ]; then
+                CFG_EGL=auto
+            fi
+        elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+            if [ "$CFG_EGL" = "no" ]; then
+                CFG_EGL=auto
+            fi
+        else
+            if [ "$CFG_OPENGL" = "yes" ]; then
+                echo "All the OpenGL functionality tests failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_OPENGL=no
+        fi
+        case "$PLATFORM" in
+        hpux*)
+            # HP-UX have buggy glx headers; check if we really need to define the GLXFBConfig struct.
+            if [ "$CFG_OPENGL" = "desktop" ]; then
+                compileTest x11/glxfbconfig "OpenGL" $X11TESTS_FLAGS
+                if [ $? != "0" ]; then
+                    QMakeVar add DEFINES QT_DEFINE_GLXFBCONFIG_STRUCT
+                fi
+            fi
+            ;;
+        *)
+            ;;
+        esac
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES1, QMAKE_LIBDIR_OPENGL_ES1 and QMAKE_LIBS_OPENGL_ES1 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        if [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+            # Raptor does not support configure tests.
+            compileTest unix/opengles2 "OpenGL ES 2.x"
+            if [ $? != "0" ]; then
+                echo "The OpenGL ES 2.0 functionality test failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL_ES2, QMAKE_LIBDIR_OPENGL_ES2 and QMAKE_LIBS_OPENGL_ES2 in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+        fi
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        compileTest x11/opengl "OpenGL" $X11TESTS_FLAGS
+        if [ $? != "0" ]; then
+            echo "The OpenGL functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        case "$PLATFORM" in
+        hpux*)
+            # HP-UX have buggy glx headers; check if we really need to define the GLXFBConfig struct.
+            compileTest x11/glxfbconfig "OpenGL" $X11TESTS_FLAGS
+            if [ $? != "0" ]; then
+                QMakeVar add DEFINES QT_DEFINE_GLXFBCONFIG_STRUCT
+            fi
+            ;;
+        *)
+            ;;
+        esac
+    fi
+
+    # if opengl is disabled and the user specified graphicssystem gl, disable it...
+    if [ "$CFG_GRAPHICS_SYSTEM" = "opengl" ] && [ "$CFG_OPENGL" = "no" ]; then
+	echo "OpenGL Graphics System is disabled due to missing OpenGL support..."
+	CFG_GRAPHICS_SYSTEM=default
+    fi
+fi # X11/MINGW OpenGL
+
+# X11
+if [ "$PLATFORM_X11" = "yes" ]; then
+    # auto-detect Xcursor support
+    if [ "$CFG_XCURSOR" != "no" ]; then
+        if compileTest x11/xcursor "Xcursor" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XCURSOR" != "runtime" ]; then
+		CFG_XCURSOR=yes;
+	    fi
+	else
+	    if [ "$CFG_XCURSOR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xcursor support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XCURSOR=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xfixes support
+    if [ "$CFG_XFIXES" != "no" ]; then
+        if compileTest x11/xfixes "Xfixes" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XFIXES" != "runtime" ]; then
+		CFG_XFIXES=yes;
+	    fi
+	else
+	    if [ "$CFG_XFIXES" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xfixes support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XFIXES=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xrandr support (resize and rotate extension)
+    if [ "$CFG_XRANDR" != "no" ]; then
+        if compileTest x11/xrandr "Xrandr" $X11TESTS_FLAGS; then
+            if [ "$CFG_XRANDR" != "runtime" ]; then
+	    CFG_XRANDR=yes
+            fi
+	else
+	    if [ "$CFG_XRANDR" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xrandr support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRANDR=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xrender support
+    if [ "$CFG_XRENDER" != "no" ]; then
+        if compileTest x11/xrender "Xrender" $X11TESTS_FLAGS; then
+	    CFG_XRENDER=yes
+	else
+	    if [ "$CFG_XRENDER" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xrender support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XRENDER=no
+	    fi
+	fi
+    fi
+
+    # Additional check to decide if WebKit support will be included
+    if [ "$CFG_XRENDER" = "no" ] && [ "$CFG_WEBKIT" != "no" ]; then
+        echo "Warning: -no-xrender will disable the QtWebkit module."
+        CFG_WEBKIT="no"
+    fi
+
+    # auto-detect MIT-SHM support
+    if [ "$CFG_MITSHM" != "no" ]; then
+        if compileTest x11/mitshm "mitshm" $X11TESTS_FLAGS; then
+	    CFG_MITSHM=yes
+	else
+	    if [ "$CFG_MITSHM" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "MITSHM support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_MITSHM=no
+	    fi
+	fi
+    fi
+
+    # auto-detect FontConfig support
+    if [ "$CFG_FONTCONFIG" != "no" ]; then
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists fontconfig --exists freetype2 2>/dev/null; then
+        QT_CFLAGS_FONTCONFIG=`$PKG_CONFIG --cflags fontconfig --cflags freetype2 2>/dev/null`
+        QT_LIBS_FONTCONFIG=`$PKG_CONFIG --libs fontconfig --libs freetype2 2>/dev/null`
+    else
+        QT_CFLAGS_FONTCONFIG=
+        QT_LIBS_FONTCONFIG="-lfreetype -lfontconfig"
+    fi
+    if compileTest x11/fontconfig "FontConfig" $X11TESTS_FLAGS $QT_CFLAGS_FONTCONFIG $QT_LIBS_FONTCONFIG; then
+	    CFG_FONTCONFIG=yes
+        QMakeVar set QMAKE_CFLAGS_X11 "$QT_CFLAGS_FONTCONFIG \$\$QMAKE_CFLAGS_X11"
+        QMakeVar set QMAKE_LIBS_X11 "$QT_LIBS_FONTCONFIG \$\$QMAKE_LIBS_X11"
+	    CFG_LIBFREETYPE=system
+	else
+	    if [ "$CFG_FONTCONFIG" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "FontConfig support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_FONTCONFIG=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Session Management support
+    if [ "$CFG_SM" = "auto" ]; then
+        if compileTest x11/sm "Session Management" $X11TESTS_FLAGS; then
+	    CFG_SM=yes
+	else
+	    if [ "$CFG_SM" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Session Management support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_SM=no
+	    fi
+	fi
+    fi
+
+    # auto-detect SHAPE support
+    if [ "$CFG_XSHAPE" != "no" ]; then
+        if compileTest x11/xshape "XShape" $X11TESTS_FLAGS; then
+	    CFG_XSHAPE=yes
+	else
+	    if [ "$CFG_XSHAPE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XShape support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XSHAPE=no
+	    fi
+	fi
+    fi
+
+    # auto-detect XVideo support
+    if [ "$CFG_XVIDEO" != "no" ]; then
+        if compileTest x11/xvideo "XVideo" $X11TESTS_FLAGS; then
+	    CFG_XVIDEO=yes
+	else
+	    if [ "$CFG_XVIDEO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XVideo support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XVIDEO=no
+	    fi
+	fi
+    fi
+
+    # auto-detect XSync support
+    if [ "$CFG_XSYNC" != "no" ]; then
+        if compileTest x11/xsync "XSync" $X11TESTS_FLAGS; then
+	    CFG_XSYNC=yes
+	else
+	    if [ "$CFG_XSYNC" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "XSync support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XSYNC=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xinerama support
+    if [ "$CFG_XINERAMA" != "no" ]; then
+        if compileTest x11/xinerama "Xinerama" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XINERAMA" != "runtime" ]; then
+		CFG_XINERAMA=yes
+	    fi
+	else
+	    if [ "$CFG_XINERAMA" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+		echo "Xinerama support cannot be enabled due to functionality tests!"
+		echo " Turn on verbose messaging (-v) to $0 to see the final report."
+		echo " If you believe this message is in error you may use the continue"
+		echo " switch (-continue) to $0 to continue."
+		exit 101
+	    else
+		CFG_XINERAMA=no
+	    fi
+	fi
+    fi
+
+    # auto-detect Xinput support
+    if [ "$CFG_XINPUT" != "no" ]; then
+        if compileTest x11/xinput "XInput" $X11TESTS_FLAGS; then
+	    if [ "$CFG_XINPUT" != "runtime" ]; then
+		CFG_XINPUT=yes
+	    fi
+        else
+            if [ "$CFG_XINPUT" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Tablet and Xinput support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_XINPUT=no
+            fi
+        fi
+    fi
+
+    # auto-detect XKB support
+    if [ "$CFG_XKB" != "no" ]; then
+        if compileTest x11/xkb "XKB" $X11TESTS_FLAGS; then
+            CFG_XKB=yes
+        else
+            if [ "$CFG_XKB" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "XKB support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_XKB=no
+            fi
+        fi
+    fi
+
+    if [ "$CFG_GLIB" = "yes" -a "$CFG_QGTKSTYLE" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_QGTKSTYLE=`$PKG_CONFIG --cflags gtk+-2.0 ">=" 2.10 atk 2>/dev/null`
+            QT_LIBS_QGTKSTYLE=`$PKG_CONFIG --libs gobject-2.0 2>/dev/null`
+        fi
+        if [ -n "$QT_CFLAGS_QGTKSTYLE" ] ; then
+            CFG_QGTKSTYLE=yes
+            QMakeVar set QT_CFLAGS_QGTKSTYLE "$QT_CFLAGS_QGTKSTYLE"
+            QMakeVar set QT_LIBS_QGTKSTYLE "$QT_LIBS_QGTKSTYLE"
+        else
+            if [ "$CFG_QGTKSTYLE" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+                echo "Gtk theme support cannot be enabled due to functionality tests!"
+                echo " Turn on verbose messaging (-v) to $0 to see the final report."
+                echo " If you believe this message is in error you may use the continue"
+                echo " switch (-continue) to $0 to continue."
+                exit 101
+            else
+                CFG_QGTKSTYLE=no
+            fi
+        fi
+    elif [ "$CFG_GLIB" = "no" ]; then
+        CFG_QGTKSTYLE=no
+    fi
+fi # X11
+
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_PHONON" != "no" ]; then
+        # Always enable Phonon (unless it was explicitly disabled)
+        CFG_PHONON=yes
+    fi
+
+    if [ "$CFG_COREWLAN" = "auto" ]; then
+        if compileTest mac/corewlan "CoreWlan"; then
+            CFG_COREWLAN=yes
+        else
+            CFG_COREWLAN=no
+        fi
+    fi
+fi
+
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_OPENGL" = "auto" ] || [ "$CFG_OPENGL" = "yes" ]; then
+        if compileTest unix/opengldesktop "OpenGL" $X11TESTS_FLAGS; then
+            CFG_OPENGL=desktop
+        elif compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+        elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+        else
+            if [ "$CFG_OPENGL" = "yes" ]; then
+                echo "All the OpenGL functionality tests failed!"
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_OPENGL=no
+        fi
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES1, QMAKE_LIBDIR_OPENGL_ES1 and QMAKE_LIBS_OPENGL_ES1 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists glesv2 2>/dev/null; then
+            QMAKE_INCDIR_OPENGL_ES2=`$PKG_CONFIG --variable=includedir glesv2 2>/dev/null`
+            QMAKE_LIBDIR_OPENGL_ES2=`$PKG_CONFIG --variable=libdir glesv2 2>/dev/null`
+            QMAKE_LIBS_OPENGL_ES2=`$PKG_CONFIG --libs glesv2 2>/dev/null`
+            QMAKE_CFLAGS_OPENGL_ES2=`$PKG_CONFIG --cflags glesv2 2>/dev/null`
+            QMakeVar set QMAKE_INCDIR_OPENGL_ES2 "$QMAKE_INCDIR_OPENGL_ES2"
+            QMakeVar set QMAKE_LIBDIR_OPENGL_ES2 "$QMAKE_LIBDIR_OPENGL_ES2"
+            QMakeVar set QMAKE_LIBS_OPENGL_ES2 "$QMAKE_LIBS_OPENGL_ES2"
+        fi
+
+        compileTest unix/opengles2 "OpenGL ES 2.x" $QMAKE_LIBS_OPENGL_ES2 $QMAKE_CFLAGS_OPENGL_ES2
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 2.0 functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL_ES2, QMAKE_LIBDIR_OPENGL_ES2 and QMAKE_LIBS_OPENGL_ES2 in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        compileTest unix/opengldesktop "OpenGL" $X11TESTS_FLAGS
+        if [ $? != "0" ]; then
+            echo "The OpenGL functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    fi
+
+    # auto-detect FontConfig support
+    if [ "$CFG_FONTCONFIG" != "no" ]; then
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists fontconfig --exists freetype2 2>/dev/null; then
+            QT_CFLAGS_FONTCONFIG=`$PKG_CONFIG --cflags fontconfig --cflags freetype2 2>/dev/null`
+            QT_LIBS_FONTCONFIG=`$PKG_CONFIG --libs fontconfig --libs freetype2 2>/dev/null`
+        else
+            QT_CFLAGS_FONTCONFIG=
+            QT_LIBS_FONTCONFIG="-lfreetype -lfontconfig"
+        fi
+        if compileTest x11/fontconfig "FontConfig" $X11TESTS_FLAGS $QT_CFLAGS_FONTCONFIG $QT_LIBS_FONTCONFIG; then
+                QT_CONFIG="$QT_CONFIG fontconfig"
+                QMakeVar set QMAKE_CFLAGS_FONTCONFIG "$QT_CFLAGS_FONTCONFIG"
+                QMakeVar set QMAKE_LIBS_FONTCONFIG "$QT_LIBS_FONTCONFIG"
+                CFG_LIBFREETYPE=system
+        fi
+
+    fi
+
+    if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists wayland-client 2>/dev/null; then
+        QMAKE_CFLAGS_WAYLAND=`$PKG_CONFIG --cflags wayland-client 2>/dev/null`
+        QMAKE_LIBS_WAYLAND=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+        QMAKE_INCDIR_WAYLAND=`$PKG_CONFIG --variable=includedir wayland-client 2>/dev/null`
+        QMAKE_LIBDIR_WAYLAND=`$PKG_CONFIG --variable=libdir wayland-client 2>/dev/null`
+
+        if [ -n "$PKG_CONFIG" ] && $PKG_CONFIG --exists xkbcommon 2>/dev/null; then
+            QMAKE_CFLAGS_WAYLAND="$QMAKE_CFLAGS_WAYLAND `$PKG_CONFIG --cflags xkbcommon 2>/dev/null`"
+            QMAKE_LIBS_WAYLAND="$QMAKE_LIBS_WAYLAND `$PKG_CONFIG --libs xkbcommon 2>/dev/null`"
+        else
+            QMAKE_DEFINES_WAYLAND=QT_NO_WAYLAND_XKB
+        fi
+    fi
+
+    # QMake variables set here override those in the mkspec. Therefore we only set the variables here if they are not zero.
+    if [ -n "$QMAKE_CFLAGS_WAYLAND" ] || [ -n "$QMAKE_LIBS_WAYLAND" ]; then
+        QMakeVar set QMAKE_CFLAGS_WAYLAND "$QMAKE_CFLAGS_WAYLAND"
+        QMakeVar set QMAKE_INCDIR_WAYLAND "$QMAKE_INCDIR_WAYLAND"
+        QMakeVar set QMAKE_LIBS_WAYLAND "$QMAKE_LIBS_WAYLAND"
+        QMakeVar set QMAKE_LIBDIR_WAYLAND "$QMAKE_LIBDIR_WAYLAND"
+        QMakeVar set QMAKE_DEFINES_WAYLAND " $QMAKE_DEFINES_WAYLAND"
+    fi
+
+    if compileTest qpa/wayland "Wayland" $QMAKE_CFLAGS_WAYLAND $QMAKE_LIBS_WAYLAND; then
+        QT_CONFIG="$QT_CONFIG wayland"
+    fi
+
+fi
+
+
+# QWS
+if [ "$PLATFORM_QWS" = "yes" ]; then
+
+    # auto-detect OpenGL support (es1 = OpenGL ES 1.x Common, es2 = OpenGL ES 2.x)
+    if [ "$CFG_GUI" = "no" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL=no
+        fi
+        if [ "$CFG_OPENGL" != "no" ]; then
+            echo "OpenGL enabled, but GUI disabled."
+            echo " You might need to either enable the GUI or disable OpenGL"
+            exit 1
+        fi
+    fi
+    if [ "$CFG_OPENGL" = "yes" ]; then
+        CFG_EGL=auto
+        if compileTest unix/opengles2 "OpenGL ES 2.x"; then
+            CFG_OPENGL=es2
+    elif compileTest unix/opengles1 "OpenGL ES 1.x"; then
+            CFG_OPENGL=es1
+        else
+            echo "All the OpenGL ES functionality tests failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+    elif [ "$CFG_OPENGL" = "es1" ]; then
+        # OpenGL ES 1.x
+        compileTest unix/opengles1 "OpenGL ES 1.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 1.x functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        CFG_EGL=yes
+    elif [ "$CFG_OPENGL" = "es2" ]; then
+        #OpenGL ES 2.x
+        compileTest unix/opengles2 "OpenGL ES 2.x"
+        if [ $? != "0" ]; then
+            echo "The OpenGL ES 2.0 functionality test failed!"
+            echo " You might need to modify the include and library search paths by editing"
+            echo " QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in"
+            echo " ${XQMAKESPEC}."
+            exit 1
+        fi
+        CFG_EGL=yes
+    elif [ "$CFG_OPENGL" = "desktop" ]; then
+        # Desktop OpenGL support
+        echo "Desktop OpenGL support is not avaliable on Qt for Embedded Linux"
+        exit 1
+    fi
+fi
+
+if [ "$PLATFORM_QWS" = "yes" ]; then
+
+    # screen drivers
+    for screen in ${CFG_GFX_ON} ${CFG_GFX_PLUGIN}; do
+       if [ "${screen}" = "ahi" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           compileTest qws/ahi "Ahi"
+           if [ $? != "0" ]; then
+               echo "The Ahi screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+       if [ "${screen}" = "svgalib" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           compileTest qws/svgalib "SVGAlib"
+           if [ $? != "0" ]; then
+               echo "The SVGAlib screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+       if [ "${screen}" = "directfb" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+           if test -n "$PKG_CONFIG" && "$PKG_CONFIG" --exists directfb 2>/dev/null; then
+               QT_CFLAGS_DIRECTFB=`$PKG_CONFIG --cflags directfb 2>/dev/null`
+               QT_LIBS_DIRECTFB=`$PKG_CONFIG --libs directfb 2>/dev/null`
+           elif directfb-config --version >/dev/null 2>&1; then
+               QT_CFLAGS_DIRECTFB=`directfb-config --cflags 2>/dev/null`
+               QT_LIBS_DIRECTFB=`directfb-config --libs 2>/dev/null`
+           fi
+
+           # QMake variables set here override those in the mkspec. Therefore we only set the variables here if they are not zero.
+           if [ -n "$QT_CFLAGS_DIRECTFB" ] || [ -n "$QT_LIBS_DIRECTFB" ]; then
+               QMakeVar set QT_CFLAGS_DIRECTFB "$QT_CFLAGS_DIRECTFB"
+               QMakeVar set QT_LIBS_DIRECTFB "$QT_LIBS_DIRECTFB"
+           fi
+           if [ "$CFG_QT3SUPPORT" = "yes" ]; then
+               QMakeVar set QT_DEFINES_DIRECTFB "QT3_SUPPORT"
+           fi
+
+           compileTest qws/directfb "DirectFB" $QT_CFLAGS_DIRECTFB $QT_LIBS_DIRECTFB
+           if [ $? != "0" ]; then
+               echo "The DirectFB screen driver functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QT_CFLAGS_DIRECTFB and QT_LIBS_DIRECTFB in"
+               echo " ${XQMAKESPEC}."
+               exit 1
+           fi
+       fi
+
+    done
+
+    # mouse drivers
+    for mouse in ${CFG_MOUSE_ON} ${CFG_MOUSE_PLUGIN}; do
+	if [ "${mouse}" = "tslib" ] && [ "${CFG_CONFIGURE_EXIT_ON_ERROR}" = "yes" ]; then
+            compileTest unix/tslib "tslib"
+            if [ $? != "0" ]; then
+               echo "The tslib functionality test failed!"
+               echo " You might need to modify the include and library search paths by editing"
+               echo " QMAKE_INCDIR and QMAKE_LIBDIR in"
+               echo " ${XQMAKESPEC}."
+		exit 1
+	    fi
+	fi
+    done
+
+    CFG_QGTKSTYLE=no
+
+    # sound
+    compileTest qws/sound "sound"
+    if [ $? != "0" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SOUND"
+    fi
+
+fi # QWS
+
+EGL_VARIANT=none
+# EGL Support
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" ]; then
+    if [ "$CFG_EGL" != "no" ]; then
+        # detect EGL support
+        if compileTest "unix/egl" "EGL (EGL/egl.h)"; then
+            # EGL specified by QMAKE_*_EGL, included with <EGL/egl.h>
+            EGL_VARIANT=regular
+            CFG_EGL=yes
+        fi
+
+        # Prefer this variant for ES1
+        if [ "$CFG_OPENGL" = "es1" -o "$EGL_VARIANT" = "none" ]; then
+            if compileTest "unix/egl4gles1" "EGL (GLES/egl.h)"; then
+                # EGL specified by QMAKE_*_EGL, included with <GLES/egl.h>
+                EGL_VARIANT=gles
+                CFG_EGL=yes
+                CFG_EGL_GLES_INCLUDES=yes
+            fi
+        fi
+
+        if [ "$EGL_VARIANT" = "none" ]; then
+            if [ "$CFG_EGL" = "yes" ]; then
+                echo "The EGL functionality test failed!"
+                echo " EGL is required for OpenGL ES to manage contexts & surfaces."
+                echo " You might need to modify the include and library search paths by editing"
+                echo " QMAKE_INCDIR_EGL, QMAKE_LIBDIR_EGL and QMAKE_LIBS_EGL in"
+                echo " ${XQMAKESPEC}."
+                exit 1
+            fi
+            CFG_EGL=no
+            # If QtOpenGL would be built against OpenGL ES, disable it as we can't to that if EGL is missing
+            if [ "$CFG_OPENGL" = "es1" -o "$CFG_OPENGL" = "es2" ]; then
+                CFG_OPENGL=no
+            fi
+        fi
+    fi
+fi
+
+[ "$XPLATFORM_MINGW" = "yes" ] && [ "$CFG_PHONON" != "no" ] && CFG_PHONON="yes"
+
+# freetype support
+[ "x$CFG_EMBEDDED" != "xno" ] && CFG_LIBFREETYPE="$CFG_QWS_FREETYPE"
+[ "x$PLATFORM_MAC" = "xyes" ] && CFG_LIBFREETYPE=no
+[ "$XPLATFORM_MINGW" = "yes" ] && [ "$CFG_LIBFREETYPE" = "auto" ] && CFG_LIBFREETYPE=no
+if [ "$CFG_LIBFREETYPE" = "auto" ]; then
+    if compileTest unix/freetype "FreeType"; then
+        CFG_LIBFREETYPE=system
+    else
+        CFG_LIBFREETYPE=yes
+    fi
+fi
+
+if [ "$CFG_ENDIAN" = "auto" ]; then
+    if [ "$XPLATFORM_MINGW" = "yes" ]; then
+        CFG_ENDIAN="Q_LITTLE_ENDIAN"
+    elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+        CFG_ENDIAN="Q_LITTLE_ENDIAN"
+    elif [ "$PLATFORM_MAC" = "yes" ] && [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+        true #leave as auto
+    else
+        "$unixtests/endian.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath" "$SYSROOT_FLAG"
+	F="$?"
+        if [ "$F" -eq 0 ]; then
+            CFG_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$F" -eq 1 ]; then
+            CFG_ENDIAN="Q_BIG_ENDIAN"
+        else
+            echo
+	    echo "The target system byte order could not be detected!"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    echo "You can use the -little-endian or -big-endian switch to"
+	    echo "$0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ]; then
+	true #leave as auto
+    else
+        "$unixtests/endian.test" "$QMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+	F="$?"
+        if [ "$F" -eq 0 ]; then
+            CFG_HOST_ENDIAN="Q_LITTLE_ENDIAN"
+        elif [ "$F" -eq 1 ]; then
+            CFG_HOST_ENDIAN="Q_BIG_ENDIAN"
+        else
+            echo
+	    echo "The host system byte order could not be detected!"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    echo "You can use the -host-little-endian or -host-big-endian switch to"
+	    echo "$0 to continue."
+            exit 101
+        fi
+    fi
+fi
+
+if [ "$CFG_ARMFPA" != "auto" ]; then
+    if [ "$CFG_ARMFPA" = "yes" ]; then
+        if [ "$CFG_ENDIAN" = "Q_LITTLE_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE_SWAPPED"
+        else
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG_SWAPPED"
+        fi
+    else
+        CFG_DOUBLEFORMAT="normal"
+    fi
+fi
+
+
+if [ "$CFG_DOUBLEFORMAT" = "auto" ]; then
+    if [ "$PLATFORM_QWS" != "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+        CFG_DOUBLEFORMAT=normal
+    else
+        "$unixtests/doubleformat.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+	F="$?"
+        if [ "$F" -eq 10 ] && [ "$CFG_ENDIAN" = "Q_LITTLE_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT=normal
+        elif [ "$F" -eq 11 ] && [ "$CFG_ENDIAN" = "Q_BIG_ENDIAN" ]; then
+            CFG_DOUBLEFORMAT=normal
+        elif [ "$F" -eq 10 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE"
+        elif [ "$F" -eq 11 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG"
+        elif [ "$F" -eq 12 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_LITTLE_SWAPPED"
+            CFG_ARMFPA="yes"
+        elif [ "$F" -eq 13 ]; then
+            CFG_DOUBLEFORMAT="Q_DOUBLE_BIG_SWAPPED"
+            CFG_ARMFPA="yes"
+        else
+            echo
+	    echo "The system floating point format could not be detected."
+	    echo "This may cause data to be generated in a wrong format"
+	    echo "Turn on verbose messaging (-v) to see the final report."
+	    # we do not fail on this since this is a new test, and if it fails,
+	    # the old behavior should be correct in most cases
+            CFG_DOUBLEFORMAT=normal
+        fi
+    fi
+fi
+
+HAVE_STL=no
+if [ "$XPLATFORM_SYMBIAN" = "yes" ] || [ "$XPLATFORM_INTEGRITY" = "yes" ] || compileTest unix/stl "STL"; then
+    HAVE_STL=yes
+fi
+
+if [ "$CFG_STL" != "no" ]; then
+    if [ "$HAVE_STL" = "yes" ]; then
+        CFG_STL=yes
+    else
+        if [ "$CFG_STL" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "STL support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_STL=no
+        fi
+    fi
+fi
+
+# find if the platform supports IPv6
+if [ "$CFG_IPV6" != "no" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        #IPV6 should always be enabled for Symbian release
+        CFG_IPV6=yes
+    elif compileTest unix/ipv6 "IPv6"; then
+        CFG_IPV6=yes
+    else
+        if [ "$CFG_IPV6" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "IPv6 support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_IPV6=no
+        fi
+    fi
+fi
+
+# detect POSIX clock_gettime()
+if [ "$CFG_CLOCK_GETTIME" = "auto" ]; then
+    if compileTest unix/clock-gettime "POSIX clock_gettime()"; then
+	CFG_CLOCK_GETTIME=yes
+    else
+	CFG_CLOCK_GETTIME=no
+    fi
+fi
+
+# detect POSIX monotonic clocks
+if [ "$CFG_CLOCK_GETTIME" = "yes" ] && [ "$CFG_CLOCK_MONOTONIC" = "auto" ]; then
+    if compileTest unix/clock-monotonic "POSIX Monotonic Clock"; then
+	CFG_CLOCK_MONOTONIC=yes
+    else
+	CFG_CLOCK_MONOTONIC=no
+    fi
+elif [ "$CFG_CLOCK_GETTIME" = "no" ]; then
+    CFG_CLOCK_MONOTONIC=no
+fi
+
+# detect mremap
+if [ "$CFG_MREMAP" = "auto" ]; then
+    if compileTest unix/mremap "mremap"; then
+	CFG_MREMAP=yes
+    else
+	CFG_MREMAP=no
+    fi
+fi
+
+# find if the platform provides getaddrinfo (ipv6 dns lookups)
+if [ "$CFG_GETADDRINFO" != "no" ]; then
+    if compileTest unix/getaddrinfo "getaddrinfo"; then
+        CFG_GETADDRINFO=yes
+    else
+	if [ "$CFG_GETADDRINFO" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "getaddrinfo support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+	else
+	    CFG_GETADDRINFO=no
+	fi
+    fi
+fi
+
+# find if the platform provides inotify
+if [ "$CFG_INOTIFY" != "no" ]; then
+    if compileTest unix/inotify "inotify"; then
+        CFG_INOTIFY=yes
+    else
+	if [ "$CFG_INOTIFY" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "inotify support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+	else
+	    CFG_INOTIFY=no
+	fi
+    fi
+fi
+
+# find if the platform provides if_nametoindex (ipv6 interface name support)
+if [ "$CFG_IPV6IFNAME" != "no" ]; then
+    if compileTest unix/ipv6ifname "IPv6 interface name"; then
+        CFG_IPV6IFNAME=yes
+    else
+        if [ "$CFG_IPV6IFNAME" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "IPv6 interface name support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+	    CFG_IPV6IFNAME=no
+	fi
+    fi
+fi
+
+# find if the platform provides getifaddrs (network interface enumeration)
+if [ "$CFG_GETIFADDRS" != "no" ]; then
+    if compileTest unix/getifaddrs "getifaddrs"; then
+        CFG_GETIFADDRS=yes
+    else
+        if [ "$CFG_GETIFADDRS" = "yes" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "getifaddrs support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+	    CFG_GETIFADDRS=no
+	fi
+    fi
+fi
+
+# detect OpenSSL
+if [ "$CFG_OPENSSL" != "no" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest unix/openssl "OpenSSL"; then
+        if [ "$CFG_OPENSSL" = "auto" ]; then
+            CFG_OPENSSL=yes
+        fi
+    else
+        if ( [ "$CFG_OPENSSL" = "yes" ] || [ "$CFG_OPENSSL" = "linked" ] ) && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "OpenSSL support cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_OPENSSL=no
+        fi
+    fi
+else
+    if [ "$CFG_OPENSSL" = "auto" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+        #OpenSSl should be enabled for Symbian release
+        CFG_OPENSSL=yes
+    fi
+fi
+
+# detect OpenVG support
+if [ "$CFG_OPENVG" != "no" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest "unix/openvg" "OpenVG"; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+    elif compileTest unix/openvg "OpenVG" -config openvg_on_opengl; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_ON_OPENGL=yes
+    elif compileTest unix/openvg "OpenVG (lc includes)" -config lower_case_includes; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_LC_INCLUDES=yes
+    elif compileTest unix/openvg "OpenVG (lc includes)" -config "openvg_on_opengl lower_case_includes"; then
+        if [ "$CFG_OPENVG" = "auto" ]; then
+            CFG_OPENVG=yes
+        fi
+        CFG_OPENVG_LC_INCLUDES=yes
+        CFG_OPENVG_ON_OPENGL=yes
+    else
+        if [ "$CFG_OPENVG" != "auto" ] && [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
+            echo "$CFG_OPENVG was specified for OpenVG but cannot be enabled due to functionality tests!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        else
+            CFG_OPENVG=no
+        fi
+    fi
+    if [ "$CFG_OPENVG" = "yes" ] && compileTest "unix/shivavg" "ShivaVG" $CONFIG_ARG; then
+        CFG_OPENVG_SHIVA=yes
+    fi
+fi
+
+# if openvg is disabled and the user specified graphicssystem vg, disable it...
+if [ "$CFG_GRAPHICS_SYSTEM" = "openvg" ] && [ "$CFG_OPENVG" = "no" ]; then
+    echo "OpenVG Graphics System is disabled due to missing OpenVG support..."
+    CFG_GRAPHICS_SYSTEM=default
+fi
+
+if [ -n "$CFG_RUNTIME_SYSTEM" -a "$CFG_GRAPHICS_SYSTEM" != "runtime" ] || [ "$CFG_RUNTIME_SYSTEM" = "runtime" ]; then
+    echo "Argument to -runtimegraphicssystem is invalid so ignoring..."
+    CFG_RUNTIME_SYSTEM=
+fi
+
+if [ "$CFG_PTMALLOC" != "no" ]; then
+    # build ptmalloc, copy .a file to lib/
+    echo "Building ptmalloc. Please wait..."
+    (cd "$relpath/src/3rdparty/ptmalloc/"; "$MAKE" "clean" ; "$MAKE" "posix"
+     mkdir "$outpath/lib/" ; cp "libptmalloc3.a" "$outpath/lib/")
+
+    QMakeVar add QMAKE_LFLAGS "$outpath/lib/libptmalloc3.a"
+fi
+
+if [ "$CFG_ALSA" = "auto" ] && [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    if compileTest unix/alsa "alsa"; then
+        CFG_ALSA=yes
+    else
+        CFG_ALSA=no
+    fi
+elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "yes" ]; then
+    # Disabled for Symbian release
+    CFG_ALSA=no
+fi
+
+if [ "$CFG_JAVASCRIPTCORE_JIT" = "yes" ] || [ "$CFG_JAVASCRIPTCORE_JIT" = "auto" ]; then 
+    if [ "$CFG_ARCH" = "arm" ]; then
+       compileTest unix/javascriptcore-jit "javascriptcore-jit"
+        if [ $? != "0" ]; then
+           CFG_JAVASCRIPTCORE_JIT=no
+        fi
+    else
+	case "$XPLATFORM" in
+	    symbian-gcce)
+		CFG_JAVASCRIPTCORE_JIT=no
+		;;
+	    linux-icc*)
+		CFG_JAVASCRIPTCORE_JIT=no
+		;;
+	esac
+    fi
+fi
+
+if [ "$CFG_JAVASCRIPTCORE_JIT" = "yes" ]; then
+    QMakeVar set JAVASCRIPTCORE_JIT yes
+elif [ "$CFG_JAVASCRIPTCORE_JIT" = "no" ]; then
+    QMakeVar set JAVASCRIPTCORE_JIT no
+fi
+
+if [ "$CFG_AUDIO_BACKEND" = "auto" ]; then
+    if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+         if "$symbiantests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/symbian/audio "audio" $L_FLAGS $I_FLAGS $l_FLAGS ; then
+            CFG_AUDIO_BACKEND=yes
+         fi
+    else
+        CFG_AUDIO_BACKEND=yes
+    fi
+fi
+
+if [ "$CFG_LARGEFILE" != "yes" ] && [ "$XPLATFORM_MINGW" = "yes" ]; then
+    echo "Warning: largefile support cannot be disabled for win32."
+    CFG_LARGEFILE="yes"
+elif [ "$CFG_LARGEFILE" != "no" ] && [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    echo "Warning: largefile support cannot be enabled for symbian."
+    CFG_LARGEFILE="no"
+fi
+
+#-------------------------------------------------------------------------------
+# ask for all that hasn't been auto-detected or specified in the arguments
+#-------------------------------------------------------------------------------
+
+### fix this: user input should be validated in a loop
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    PROMPT_FOR_DEPTHS="yes"
+else
+    PROMPT_FOR_DEPTHS="no"
+fi
+if [ "$CFG_QWS_DEPTHS" = "prompted" -a "$PROMPT_FOR_DEPTHS" = "yes" ]; then
+    echo
+    echo "Choose pixel-depths to support:"
+    echo
+    echo "   1. 1bpp, black/white"
+    echo "   4. 4bpp, grayscale"
+    echo "   8. 8bpp, paletted"
+    echo "  12. 12bpp, rgb 4-4-4"
+    echo "  15. 15bpp, rgb 5-5-5"
+    echo "  16. 16bpp, rgb 5-6-5"
+    echo "  18. 18bpp, rgb 6-6-6"
+    echo "  24. 24bpp, rgb 8-8-8"
+    echo "  32. 32bpp, argb 8-8-8-8 and rgb 8-8-8"
+    echo " all. All supported depths"
+    echo
+    echo "Your choices (default 8,16,32):"
+    read CFG_QWS_DEPTHS
+    if [ -z "$CFG_QWS_DEPTHS" ] || [ "$CFG_QWS_DEPTHS" = "yes" ]; then
+        CFG_QWS_DEPTHS=8,16,32
+    fi
+fi
+if [ -n "$CFG_QWS_DEPTHS" -a "$PLATFORM_QWS" = "yes" ]; then
+    if [ "$CFG_QWS_DEPTHS" = "all" ]; then
+        CFG_QWS_DEPTHS="1 4 8 12 15 16 18 24 32 generic"
+    fi
+    for D in `echo "$CFG_QWS_DEPTHS" | sed -e 's/,/ /g'`; do
+	case $D in
+	    1|4|8|12|15|16|18|24|32) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_$D";;
+	    generic) QCONFIG_FLAGS="$QCONFIG_FLAGS QT_QWS_DEPTH_GENERIC";;
+	esac
+    done
+fi
+
+# enable dwarf2 support on Mac
+if [ "$CFG_MAC_DWARF2" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG dwarf2"
+fi
+
+# Set the default arch if there are no "-arch" arguments on the configure line
+# For "-carbon" builds: 32 bit x86/ppc.
+# For builds on snow leopard : compiler default (64-bit).
+# For builds on leopard : compiler default (32-bit).
+if [ "$PLATFORM_MAC" = "yes" ]  && [ "$CFG_MAC_ARCHS" = "" ]; then
+    source "$mactests/defaultarch.test" "$TEST_COMPILER" "$OPT_VERBOSE" "$mactests"
+
+	if [ "$CFG_MAC_CARBON" = "yes" ]; then
+		if [ "$QT_MAC_DEFAULT_ARCH" = "x86_64" ]; then
+			CFG_MAC_ARCHS=" x86"
+		elif [ "$QT_MAC_DEFAULT_ARCH" = "ppc64" ]; then
+			CFG_MAC_ARCHS=" ppc"
+		else
+			CFG_MAC_ARCHS=" $QT_MAC_DEFAULT_ARCH"
+		fi
+	else
+		CFG_MAC_ARCHS=" $QT_MAC_DEFAULT_ARCH"
+    fi
+
+    [ "$OPT_VERBOSE" = "yes" ] && echo "Setting Mac architechture to$CFG_MAC_ARCHS."
+fi
+
+# enable Cocoa and/or Carbon on Mac
+#  -carbon on the command line disables Cocoa, except for 64-bit archs
+if [ "$CFG_MAC_CARBON" = "yes" ]; then
+    CFG_MAC_CARBON="YES"
+    CFG_MAC_COCOA="NO"
+
+#    check which archs are in use, enable cocoa if we find a 64-bit one
+    if echo "$CFG_MAC_ARCHS" | grep 64 > /dev/null 2>&1; then
+        CFG_MAC_COCOA="yes";
+        CFG_MAC_CARBON="no";
+        if echo "$CFG_MAC_ARCHS" | grep -w ppc > /dev/null 2>&1; then
+            CFG_MAC_CARBON="yes";
+        fi
+        if echo "$CFG_MAC_ARCHS" | grep -w x86 > /dev/null 2>&1; then
+            CFG_MAC_CARBON="yes";
+        fi
+    fi
+fi
+
+# select Carbon on 10.4 Tiger.
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    VERSION=`uname -r | tr '.' ' ' | awk '{print $1}'`
+    if [ "$VERSION" == 8 ]; then
+        CFG_MAC_COCOA="no";
+        CFG_MAC_CARBON="yes";
+    fi
+fi
+
+# select Carbon when using the 10.4u SDK
+if [ "$PLATFORM_MAC" = "yes" ] && [ -n "$CFG_SDK" ]; then
+    if [ `basename "$CFG_SDK"` == "MacOSX10.4u.sdk" ]; then
+        echo "Carbon on";
+        CFG_MAC_COCOA="no";
+        CFG_MAC_CARBON="yes";
+    fi
+fi
+
+# but disable Cocoa if cross-building for mingw and symbian
+[ "$XPLATFORM_MINGW" = "yes" ] && CFG_MAC_COCOA="no"
+[ "$XPLATFORM_SYMBIAN" = "yes" ] && CFG_MAC_COCOA="no"
+
+# set the global Mac deployment target. This is overridden on an arch-by-arch basis
+# in some cases, see code further down
+case "$PLATFORM,$CFG_MAC_COCOA" in
+*macx-clang-libc++,yes)
+    # Avoid overriding the default configuration setting when building with clang/libc++
+    ;;
+macx*,yes)
+    # Cocoa
+    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.5
+    ;;
+macx*,no)
+    # gcc, Carbon
+    QMakeVar set QMAKE_MACOSX_DEPLOYMENT_TARGET 10.4
+    ;;
+esac
+
+# disable Qt 3 support on VxWorks, Symbian and INTEGRITY
+case "$XPLATFORM" in
+    unsupported/vxworks*|symbian*|unsupported/integrity*)
+	CFG_QT3SUPPORT="no"
+    ;;
+esac
+
+# enable Qt 3 support functionality
+if [ "$CFG_QT3SUPPORT" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG qt3support"
+fi
+
+# enable Phonon
+if [ "$CFG_PHONON" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG phonon"
+    if [ "$CFG_PHONON_BACKEND" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG phonon-backend"
+    fi
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_PHONON"
+fi
+
+# disable accessibility
+if [ "$CFG_ACCESSIBILITY" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ACCESSIBILITY"
+else
+    QT_CONFIG="$QT_CONFIG accessibility"
+fi
+
+# egl stuff does not belong in lighthouse, but rather in plugins
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    CFG_EGL="no"
+fi
+
+# enable egl
+if [ "$CFG_EGL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_EGL"
+else
+    QT_CONFIG="$QT_CONFIG egl"
+    if [ "$CFG_EGL_GLES_INCLUDES" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GLES_EGL"
+    fi
+fi
+
+# enable openvg
+if [ "$CFG_OPENVG" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENVG"
+else
+    QT_CONFIG="$QT_CONFIG openvg"
+    if [ "$CFG_OPENVG_LC_INCLUDES" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_LOWER_CASE_VG_INCLUDES"
+    fi
+    if [ "$CFG_OPENVG_ON_OPENGL" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG openvg_on_opengl"
+    fi
+    if [ "$CFG_OPENVG_SHIVA" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG shivavg"
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_SHIVAVG"
+    fi
+fi
+
+if [ "$CFG_QS60STYLE" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_S60"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_STYLE_S60"
+fi
+
+# Just check if OpenGL is not set by command argumets for Symbian.
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+        if [ "$CFG_OPENGL" = "auto" ]; then
+            CFG_OPENGL="no"
+        fi
+fi
+
+# enable opengl
+if [ "$CFG_OPENGL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENGL"
+else
+    QT_CONFIG="$QT_CONFIG opengl"
+fi
+
+if [ "$CFG_OPENGL" = "es1" ] || [ "$CFG_OPENGL" = "es2" ]; then
+    if [ "$PLATFORM_QWS" = "yes" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS Q_BACKINGSTORE_SUBSURFACES"
+    fi
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES"
+fi
+
+if [ "$CFG_OPENGL" = "es1" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES_1"
+    QT_CONFIG="$QT_CONFIG opengles1"
+fi
+
+if [ "$CFG_OPENGL" = "es2" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_OPENGL_ES_2"
+    QT_CONFIG="$QT_CONFIG opengles2"
+fi
+
+# safe execution environment
+if [ "$CFG_SXE" != "no" ]; then
+    QT_CONFIG="$QT_CONFIG sxe"
+fi
+
+# build up the variables for output
+if [ "$CFG_DEBUG" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}debug"
+    QMAKE_CONFIG="$QMAKE_CONFIG debug"
+elif [ "$CFG_DEBUG" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}release"
+    QMAKE_CONFIG="$QMAKE_CONFIG release"
+fi
+if [ "$CFG_SHARED" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-shared"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG shared"
+    QT_CONFIG="$QT_CONFIG shared"
+elif [ "$CFG_SHARED" = "no" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-static"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG static"
+    QT_CONFIG="$QT_CONFIG static"
+fi
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    QMAKE_OUTDIR="${QMAKE_OUTDIR}-emb-$CFG_EMBEDDED"
+    QMAKE_CONFIG="$QMAKE_CONFIG embedded"
+    QT_CONFIG="$QT_CONFIG embedded"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG qpa"
+    QT_CONFIG="$QT_CONFIG qpa"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qpa"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+
+if [ "$CFG_EMBEDDED" = "nacl" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG nacl pepper"
+    QT_CONFIG="$QT_CONFIG nacl pepper"
+    rm -f "src/.moc/$QMAKE_OUTDIR/allmoc.cpp" # needs remaking if config changes
+fi
+
+if [ "$XPLATFORM_MINGW" != "yes" ]; then
+    # Do not set this here for Windows. Let qmake do it so
+    # debug and release precompiled headers are kept separate.
+    QMakeVar set PRECOMPILED_DIR ".pch/$QMAKE_OUTDIR"
+fi
+if [ "$XPLATFORM_INTEGRITY" = "yes" ]; then
+    QMakeVar set OBJECTS_DIR "$PWD/work"
+    QMakeVar set MOC_DIR "$PWD/work"
+    QMakeVar set RCC_DIR "$PWD/work"
+    QMakeVar set UI_DIR "$PWD/work"
+else
+    QMakeVar set OBJECTS_DIR ".obj/$QMAKE_OUTDIR"
+    QMakeVar set MOC_DIR ".moc/$QMAKE_OUTDIR"
+    QMakeVar set RCC_DIR ".rcc/$QMAKE_OUTDIR"
+    QMakeVar set UI_DIR ".uic/$QMAKE_OUTDIR"
+fi
+if [ "$CFG_LARGEFILE" = "yes" ] && [ "$XPLATFORM_MINGW" != "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG largefile"
+fi
+if [ "$CFG_STL" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STL"
+else
+    QMAKE_CONFIG="$QMAKE_CONFIG stl"
+fi
+if [ "$CFG_USE_GNUMAKE" = "yes" ]; then
+    QMAKE_CONFIG="$QMAKE_CONFIG GNUmake"
+fi
+[ "$CFG_REDUCE_EXPORTS" = "yes" ] && QT_CONFIG="$QT_CONFIG reduce_exports"
+[ "$CFG_STACK_PROTECTOR_STRONG" = "yes" ] && QT_CONFIG="$QT_CONFIG stack-protector-strong"
+[ "$CFG_REDUCE_RELOCATIONS" = "yes" ] && QT_CONFIG="$QT_CONFIG reduce_relocations"
+[ "$CFG_PRECOMPILE" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG precompile_header"
+if [ "$CFG_SEPARATE_DEBUG_INFO" = "yes" ]; then
+    QMakeVar add QMAKE_CFLAGS -g
+    QMakeVar add QMAKE_CXXFLAGS -g
+    QMAKE_CONFIG="$QMAKE_CONFIG separate_debug_info"
+fi
+if [ "$CFG_SEPARATE_DEBUG_INFO_NOCOPY" = "yes" ] ; then
+    QMAKE_CONFIG="$QMAKE_CONFIG separate_debug_info_nocopy"
+fi
+[ "$CFG_MMX" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG mmx"
+[ "$CFG_3DNOW" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG 3dnow"
+[ "$CFG_SSE" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse"
+[ "$CFG_SSE2" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse2"
+[ "$CFG_SSE3" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse3"
+[ "$CFG_SSSE3" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG ssse3"
+[ "$CFG_SSE4_1" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse4_1"
+[ "$CFG_SSE4_2" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG sse4_2"
+[ "$CFG_AVX" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG avx"
+[ "$CFG_IWMMXT" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG iwmmxt"
+[ "$CFG_NEON" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG neon"
+[ "$PLATFORM_MAC" = "yes" ] && QMAKE_CONFIG="$QMAKE_CONFIG $CFG_MAC_ARCHS"
+[ "$CFG_SYSTEM_PROXIES" = "yes" ] && QT_CONFIG="$QT_CONFIG system-proxies"
+if [ "$CFG_IPV6" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG ipv6"
+fi
+if [ "$CFG_CLOCK_GETTIME" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG clock-gettime"
+fi
+if [ "$CFG_CLOCK_MONOTONIC" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG clock-monotonic"
+fi
+if [ "$CFG_MREMAP" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG mremap"
+fi
+if [ "$CFG_GETADDRINFO" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG getaddrinfo"
+fi
+if [ "$CFG_IPV6IFNAME" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG ipv6ifname"
+fi
+if [ "$CFG_GETIFADDRS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG getifaddrs"
+fi
+if [ "$CFG_INOTIFY" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG inotify"
+fi
+if [ "$CFG_LIBJPEG" = "no" ]; then
+    CFG_JPEG="no"
+elif [ "$CFG_LIBJPEG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-jpeg"
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-jpeg"
+elif [ "$CFG_JPEG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG jpeg"
+fi
+if [ "$CFG_LIBMNG" = "no" ]; then
+    CFG_MNG="no"
+elif [ "$CFG_LIBMNG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-mng"
+fi
+if [ "$CFG_MNG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-mng"
+elif [ "$CFG_MNG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG mng"
+fi
+if [ "$CFG_LIBPNG" = "no" ]; then
+    CFG_PNG="no"
+fi
+if [ "$CFG_LIBPNG" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-png"
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-png"
+elif [ "$CFG_PNG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG png"
+fi
+if [ "$CFG_GIF" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-gif"
+elif [ "$CFG_GIF" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG gif"
+fi
+if [ "$CFG_LIBTIFF" = "no" ]; then
+    CFG_TIFF="no"
+elif [ "$CFG_LIBTIFF" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-tiff"
+fi
+if [ "$CFG_TIFF" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-tiff"
+elif [ "$CFG_TIFF" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG tiff"
+fi
+if [ "$CFG_LIBFREETYPE" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-freetype"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_FREETYPE"
+elif [ "$CFG_LIBFREETYPE" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-freetype"
+else
+    QT_CONFIG="$QT_CONFIG freetype"
+fi
+if [ "$CFG_GUI" = "auto" ]; then
+    CFG_GUI="yes"
+fi
+if [ "$CFG_GUI" = "no" ]; then
+    QT_CONFIG="$QT_CONFIG no-gui"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GUI"
+fi
+
+
+if [ "x$PLATFORM_MAC" = "xyes" ] && [ "$XPLATFORM_MINGW" != "yes" ] && [ "$XPLATFORM_SYMBIAN" != "yes" ]; then
+    #On Mac we implicitly link against libz, so we
+    #never use the 3rdparty stuff.
+    [ "$CFG_ZLIB" = "yes" ] && CFG_ZLIB="system"
+fi
+if [ "$CFG_ZLIB" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG zlib"
+elif [ "$CFG_ZLIB" = "system" ]; then
+    QT_CONFIG="$QT_CONFIG system-zlib"
+fi
+
+if [ "$CFG_S60" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG s60"
+fi
+
+if [ "$CFG_SYMBIAN_DEFFILES" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG def_files"
+else
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG def_files_disabled"
+fi
+
+[ "$CFG_NIS" = "yes" ] && QT_CONFIG="$QT_CONFIG nis"
+[ "$CFG_CUPS" = "yes" ] && QT_CONFIG="$QT_CONFIG cups"
+[ "$CFG_ICONV" = "yes" ] && QT_CONFIG="$QT_CONFIG iconv"
+[ "$CFG_ICONV" = "sun" ] && QT_CONFIG="$QT_CONFIG sun-libiconv"
+[ "$CFG_ICONV" = "gnu" ] && QT_CONFIG="$QT_CONFIG gnu-libiconv"
+[ "$CFG_GLIB" = "yes" ] && QT_CONFIG="$QT_CONFIG glib"
+[ "$CFG_GSTREAMER" = "yes" ] && QT_CONFIG="$QT_CONFIG gstreamer"
+[ "$CFG_DBUS" = "yes" ] && QT_CONFIG="$QT_CONFIG dbus"
+[ "$CFG_DBUS" = "linked" ] && QT_CONFIG="$QT_CONFIG dbus dbus-linked"
+[ "$CFG_NAS" = "system" ] && QT_CONFIG="$QT_CONFIG nas"
+[ "$CFG_OPENSSL" = "yes" ] && QT_CONFIG="$QT_CONFIG openssl"
+[ "$CFG_OPENSSL" = "linked" ] && QT_CONFIG="$QT_CONFIG openssl-linked"
+[ "$CFG_MAC_HARFBUZZ" = "yes" ] && QT_CONFIG="$QT_CONFIG harfbuzz"
+
+if [ "$PLATFORM_X11" = "yes" ]; then
+    [ "$CFG_SM" = "yes" ] && QT_CONFIG="$QT_CONFIG x11sm"
+
+    # for some reason, the following libraries are not always built shared,
+    # so *every* program/lib (including Qt) has to link against them
+    if [ "$CFG_XSHAPE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xshape"
+    fi
+    if [ "$CFG_XVIDEO" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xvideo"
+    fi
+    if [ "$CFG_XSYNC" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xsync"
+    fi
+    if [ "$CFG_XINERAMA" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xinerama"
+	QMakeVar set QMAKE_LIBS_X11 '-lXinerama $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XCURSOR" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xcursor"
+	QMakeVar set QMAKE_LIBS_X11 '-lXcursor $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XFIXES" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xfixes"
+	QMakeVar set QMAKE_LIBS_X11 '-lXfixes $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XRANDR" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xrandr"
+        if [ "$CFG_XRENDER" != "yes" ]; then
+            # libXrandr uses 1 function from libXrender, so we always have to have it :/
+	    QMakeVar set QMAKE_LIBS_X11 '-lXrandr -lXrender $$QMAKE_LIBS_X11'
+        else
+	    QMakeVar set QMAKE_LIBS_X11 '-lXrandr $$QMAKE_LIBS_X11'
+        fi
+    fi
+    if [ "$CFG_XRENDER" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xrender"
+	QMakeVar set QMAKE_LIBS_X11 '-lXrender $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_MITSHM" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG mitshm"
+    fi
+    if [ "$CFG_FONTCONFIG" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG fontconfig"
+    fi
+    if [ "$CFG_XINPUT" = "yes" ]; then
+	QMakeVar set QMAKE_LIBS_X11 '-lXi $$QMAKE_LIBS_X11'
+    fi
+    if [ "$CFG_XINPUT" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xinput tablet"
+    fi
+    if [ "$CFG_XKB" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG xkb"
+    fi
+fi
+
+[ '!' -z "$D_FLAGS" ] && QMakeVar add DEFINES "$D_FLAGS"
+[ '!' -z "$L_FLAGS" ] && QMakeVar add QMAKE_LIBDIR_FLAGS "$L_FLAGS"
+[ '!' -z "$l_FLAGS" ] && QMakeVar add LIBS "$l_FLAGS"
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_RPATH" = "yes" ]; then
+       QMAKE_CONFIG="$QMAKE_CONFIG absolute_library_soname"
+    fi
+elif [ -z "`getXQMakeConf 'QMAKE_(LFLAGS_)?RPATH'`" ]; then
+    if [ -n "$RPATH_FLAGS" ]; then
+        echo
+        echo "ERROR: -R cannot be used on this platform as \$QMAKE_LFLAGS_RPATH is"
+        echo "       undefined."
+        echo
+        exit 1
+    elif [ "$CFG_RPATH" = "yes" ]; then
+        RPATH_MESSAGE="        NOTE: This platform does not support runtime library paths, using -no-rpath."
+        CFG_RPATH=no
+    fi
+else
+    if [ "$CFG_RPATH" = "yes" ]; then
+        # set the default rpath to the library installation directory
+        RPATH_FLAGS="\"$QT_INSTALL_LIBS\" $RPATH_FLAGS"
+    fi
+    if [ -n "$RPATH_FLAGS" ]; then
+        # add the user defined rpaths
+	QMakeVar add QMAKE_RPATHDIR "$RPATH_FLAGS"
+    fi
+fi
+
+if [ '!' -z "$I_FLAGS" ]; then
+    # add the user define include paths
+    QMakeVar add QMAKE_CFLAGS "$I_FLAGS"
+    QMakeVar add QMAKE_CXXFLAGS "$I_FLAGS"
+fi
+
+# turn off exceptions for the compilers that support it
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    COMPILER=`echo $XPLATFORM | cut -f 3- -d-`
+elif [ "$XPLATFORM" != "$PLATFORM" ]; then
+    COMPILER=`echo $XPLATFORM | cut -f 2- -d-`
+else
+    COMPILER=`echo $PLATFORM | cut -f 2- -d-`
+fi
+if [ "$CFG_EXCEPTIONS" = "unspecified" -a "$PLATFORM_QWS" = "yes" ]; then
+    CFG_EXCEPTIONS=no
+fi
+
+if [ "$CFG_EXCEPTIONS" != "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG exceptions"
+fi
+
+if [ "$XPLATFORM_MINGW" = "yes" ] || [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # mkspecs/features/win32/default_pre.prf sets "no-rtti".
+    # Follow default behavior of configure.exe by overriding with "rtti"
+    # (also on Symbian).
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG rtti"
+fi
+
+if [ "$CFG_ALSA" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG alsa"
+fi
+
+if [ "$CFG_PULSEAUDIO" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG pulseaudio"
+fi
+
+if [ "$CFG_COREWLAN" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG corewlan"
+fi
+
+if [ "$CFG_ICD" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG icd"
+fi
+
+if [ "$CFG_ICU" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG icu"
+fi
+
+#
+# Some Qt modules are too advanced in C++ for some old compilers
+# Detect here the platforms where they are known to work.
+#
+# See Qt documentation for more information on which features are
+# supported and on which compilers.
+#
+canBuildQtXmlPatterns="yes"
+canBuildWebKit="$HAVE_STL"
+canBuildQtScript="$HAVE_STL"
+canBuildQtConcurrent="yes"
+
+# WebKit and QtScript require stdint.h
+compileTest unix/stdint "Stdint"
+if [ $? != "0" ]; then
+    canBuildWebKit="no"
+    canBuildQtScript="no"
+fi
+
+case "$XPLATFORM" in
+    hpux-g++*)
+	# PA-RISC's assembly is too limited
+	# gcc 3.4 on that platform can't build QtXmlPatterns
+	# the assembly it generates cannot be compiled
+
+	# Check gcc's version
+	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
+	    4*)
+		;;
+	    3.4*)
+		canBuildQtXmlPatterns="no"
+		;;
+	    *)
+		canBuildWebKit="no"
+		canBuildQtXmlPatterns="no"
+		;;
+	esac
+	;;
+    unsupported/vxworks-*-g++*)
+	canBuildWebKit="no"
+	;;
+    unsupported/vxworks-*-dcc*)
+	canBuildWebKit="no"
+	canBuildQtXmlPatterns="no"
+	;;
+    *-g++*)
+	# Check gcc's version
+	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
+	    5*|4*|3.4*)
+		;;
+            3.3*)
+                canBuildWebKit="no"
+                ;;
+	    *)
+		canBuildWebKit="no"
+		canBuildQtXmlPatterns="no"
+		;;
+	esac
+	;;
+    solaris-cc*)
+        # Check the compiler version
+        case `${QMAKE_CONF_COMPILER} -V 2>&1 | awk '{print $4}'` in
+            5.[012345678])
+                canBuildWebKit="no"
+                canBuildQtXmlPatterns="no"
+                canBuildQtConcurrent="no"
+                ;;
+            5.9)
+                canBuildWebKit="no"
+                canBuildQtConcurrent="no"
+                ;;
+            5.1*)
+                canBuildWebKit="no"
+                ;;
+        esac
+        ;;
+    hpux-acc*)
+	canBuildWebKit="no"
+	canBuildQtXmlPatterns="no"
+        canBuildQtConcurrent="no"
+	;;
+    hpuxi-acc*)
+	canBuildWebKit="no"
+	;;
+    aix-xlc*)
+        # Get the xlC version
+        cat > xlcver.c <<EOF
+#include <stdio.h>
+int main()
+{
+    printf("%d.%d\n", __xlC__ >> 8, __xlC__ & 0xFF);
+    return 0;
+}
+EOF
+        xlcver=
+        if ${QMAKE_CONF_COMPILER} -o xlcver xlcver.c >/dev/null 2>/dev/null; then
+            xlcver=`./xlcver 2>/dev/null`
+            rm -f ./xlcver
+        fi
+        if [ "$OPT_VERBOSE" = "yes" ]; then
+            if [ -n "$xlcver" ]; then
+                echo Found IBM xlC version: $xlcver.
+            else
+                echo Could not determine IBM xlC version, assuming oldest supported.
+            fi
+        fi
+
+        case "$xlcver" in
+            [123456].*)
+                canBuildWebKit="no"
+                canBuildQtXmlPatterns="no"
+                canBuildQtConcurrent="no"
+                ;;
+            *)
+                canBuildWebKit="no"
+                canBuildQtConcurrent="no"
+                ;;
+        esac
+        ;;
+    irix-cc*)
+        canBuildWebKit="no"
+        canBuildQtConcurrent="no"
+	;;
+    symbian-gcce)
+        ;;
+    symbian-armcc)
+        ;;
+esac
+
+if [ "$CFG_GUI" = "no" ]; then
+    # WebKit requires QtGui
+    canBuildWebKit="no"
+fi
+
+if [ "$CFG_SHARED" = "no" ]; then
+    echo
+    echo "WARNING: Using static linking will disable the WebKit module."
+    echo
+    canBuildWebKit="no"
+fi
+
+CFG_CONCURRENT="yes"
+if [ "$canBuildQtConcurrent" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CONCURRENT"
+    CFG_CONCURRENT="no"
+else
+    QT_CONFIG="$QT_CONFIG concurrent"
+fi
+
+if [ "$CFG_XMLPATTERNS" = "yes" -a "$CFG_EXCEPTIONS" = "no" ]; then
+    echo "QtXmlPatterns was requested, but it can't be built due to exceptions being disabled."
+    exit 1
+fi
+if [ "$CFG_XMLPATTERNS" = "auto" -a "$CFG_EXCEPTIONS" != "no" ]; then
+    CFG_XMLPATTERNS="$canBuildQtXmlPatterns"
+elif [ "$CFG_EXCEPTIONS" = "no" ]; then
+    CFG_XMLPATTERNS="no"
+fi
+if [ "$CFG_XMLPATTERNS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG xmlpatterns"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XMLPATTERNS"
+fi
+
+if [ "$CFG_MULTIMEDIA" = "no" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MULTIMEDIA"
+else
+    QT_CONFIG="$QT_CONFIG multimedia"
+fi
+
+if [ "$CFG_AUDIO_BACKEND" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG audio-backend"
+fi
+
+if [ "$CFG_SVG" = "auto" ]; then
+    CFG_SVG=$CFG_GUI
+fi
+
+if [ "$CFG_SVG" = "yes" ] && [ "$CFG_GUI" = "no" ]; then
+    echo "QtSvg requested, but it can't be built without QtGui"
+    exit 1
+fi
+
+if [ "$CFG_SVG" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG svg"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SVG"
+fi
+
+if [ "$CFG_WEBKIT" != "no" ]; then
+    CFG_WEBKIT="$canBuildWebKit"
+fi
+
+if [ "$CFG_WEBKIT" != "no" ]; then
+    # This include takes care of adding "webkit" to QT_CONFIG.
+    cp -f "$relpath/src/3rdparty/webkit/Source/WebKit/qt/qt_webkit_version.pri" "$outpath/mkspecs/modules/qt_webkit_version.pri"
+    # The reason we set CFG_WEBKIT, is such that the printed overview of what will be enabled, shows correctly.
+    if [ "$CFG_WEBKIT" = "debug" ]; then
+        QMAKE_CONFIG="$QMAKE_CONFIG webkit-debug"
+    fi
+else
+    rm -f "$outpath/mkspecs/modules/qt_webkit_version.pri"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_WEBKIT"
+fi
+
+if [ "$CFG_SCRIPT" = "yes" -a "$canBuildQtScript" = "no" ]; then
+    echo "Error: QtScript was requested, but it can't be built on this platform."
+    exit 1
+fi
+
+if [ "$CFG_SCRIPT" = "auto" ]; then
+    CFG_SCRIPT="$canBuildQtScript"
+fi
+
+if [ "$CFG_SCRIPT" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG script"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SCRIPT"
+fi
+
+if [ "$CFG_SCRIPTTOOLS" = "yes" -a "$CFG_SCRIPT" = "no" ]; then
+    echo "QtScriptTools was requested, but it can't be built due to QtScript being disabled."
+    exit 1
+fi
+if [ "$CFG_SCRIPTTOOLS" = "auto" -a "$CFG_SCRIPT" != "no" ]; then
+    case "$XPLATFORM" in
+    symbian*)
+        CFG_SCRIPTTOOLS="no"
+        ;;
+    *)
+        CFG_SCRIPTTOOLS="yes"
+        ;;
+    esac
+elif [ "$CFG_SCRIPT" = "no" ]; then
+    CFG_SCRIPTTOOLS="no"
+fi
+
+if [ "$CFG_SCRIPTTOOLS" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG scripttools"
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SCRIPTTOOLS"
+fi
+
+
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    if [ "$CFG_SCRIPT" = "no" -o "$CFG_GUI" = "no" ]; then
+        echo "Error: QtDeclarative was requested, but it can't be built due to QtScript or QtGui being disabled."
+        exit 1
+    fi
+fi
+if [ "$CFG_DECLARATIVE" = "auto" ]; then
+    if [ "$CFG_SCRIPT" = "no" -o "$CFG_GUI" = "no" ]; then
+            CFG_DECLARATIVE=no
+    else
+            CFG_DECLARATIVE=yes
+    fi
+fi
+
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG declarative"
+    if [ "$CFG_DECLARATIVE_DEBUG" = "no" ]; then
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QDECLARATIVE_NO_DEBUG_PROTOCOL"
+    fi
+else
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_DECLARATIVE"
+fi
+
+if [ "$CFG_EXCEPTIONS" = "no" ]; then
+    case "$COMPILER" in
+    g++*)
+	QMakeVar add QMAKE_CFLAGS -fno-exceptions
+	QMakeVar add QMAKE_CXXFLAGS -fno-exceptions
+	QMakeVar add QMAKE_LFLAGS -fno-exceptions
+        ;;
+    cc*)
+        case "$PLATFORM" in
+        irix-cc*)
+	    QMakeVar add QMAKE_CFLAGS -LANG:exceptions=off
+	    QMakeVar add QMAKE_CXXFLAGS -LANG:exceptions=off
+	    QMakeVar add QMAKE_LFLAGS -LANG:exceptions=off
+            ;;
+        *) ;;
+        esac
+        ;;
+    *) ;;
+    esac
+    QMAKE_CONFIG="$QMAKE_CONFIG exceptions_off"
+fi
+
+# On Mac, set the minimum deployment target for the different architechtures 
+# using the Xarch compiler option when supported (10.5 and up).  On 10.4 the
+# deployment version is set to 10.4 globally using the QMAKE_MACOSX_DEPLOYMENT_TARGET
+# env. variable.
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_XARCH" != "no" ]; then
+    case "$PLATFORM" in
+    *macx-clang-libc++)
+        # Avoid overriding the default settings when building clang/libc++.
+        ;;
+    *)
+        if echo "$CFG_MAC_ARCHS" | grep '\<x86\>' > /dev/null 2>&1; then
+            QMakeVar add QMAKE_CFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_CXXFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_LFLAGS "-Xarch_i386 -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86 "-arch i386 -Xarch_i386 -mmacosx-version-min=10.4"
+        fi
+        if echo "$CFG_MAC_ARCHS" | grep '\<ppc\>' > /dev/null 2>&1; then
+            QMakeVar add QMAKE_CFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_LFLAGS "-Xarch_ppc -mmacosx-version-min=10.4"
+            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC "-arch ppc -Xarch_ppc -mmacosx-version-min=10.4"
+        fi
+        if echo "$CFG_MAC_ARCHS" | grep '\<x86_64\>' > /dev/null 2>&1; then
+            QMakeVar add QMAKE_CFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_CXXFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_LFLAGS "-Xarch_x86_64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_X86_64 "-arch x86_64 -Xarch_x86_64 -mmacosx-version-min=10.5"
+        fi
+        if echo "$CFG_MAC_ARCHS" | grep '\<ppc64\>' > /dev/null 2>&1; then
+            QMakeVar add QMAKE_CFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_CXXFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_LFLAGS "-Xarch_ppc64 -mmacosx-version-min=10.5"
+            QMakeVar add QMAKE_OBJECTIVE_CFLAGS_PPC_64 "-arch ppc64 -Xarch_ppc64 -mmacosx-version-min=10.5"
+        fi
+        ;;
+    esac
+fi
+
+#-------------------------------------------------------------------------------
+# generate QT_BUILD_KEY
+#-------------------------------------------------------------------------------
+
+# some compilers generate binary incompatible code between different versions,
+# so we need to generate a build key that is different between these compilers
+COMPAT_COMPILER=
+case "$COMPILER" in
+g++*)
+    # GNU C++
+    COMPILER_VERSION=`${QMAKE_CONF_COMPILER} -dumpversion 2>/dev/null`
+
+    case "$COMPILER_VERSION" in
+    *.*.*)
+        QT_GCC_MAJOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\1,'`
+        QT_GCC_MINOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\2,'`
+        QT_GCC_PATCH_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*,\3,'`
+        ;;
+    *.*)
+        QT_GCC_MAJOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\).*,\1,'`
+        QT_GCC_MINOR_VERSION=`echo $COMPILER_VERSION | sed 's,^\([0-9]*\)\.\([0-9]*\).*,\2,'`
+        QT_GCC_PATCH_VERSION=0
+        ;;
+    *)
+        QT_GCC_MAJOR_VERSION=$COMPILER_VERSION
+        QT_GCC_MINOR_VERSION=0
+        QT_GCC_PATCH_VERSION=0
+        ;;
+    esac
+
+    case "$COMPILER_VERSION" in
+    2.95.*)
+        COMPILER_VERSION="2.95.*"
+        ;;
+    3.*)
+        COMPILER_VERSION="3.*"
+        ;;
+    5*|4.*)
+        COMPILER_VERSION="4"
+        ;;
+    *)
+        ;;
+    esac
+    [ '!' -z "$COMPILER_VERSION" ] && COMPILER="g++-${COMPILER_VERSION}"
+    ;;
+icc*)
+    # The Intel CC compiler on Unix systems matches the ABI of the g++
+    # that is found on PATH
+    COMPAT_COMPILER="icc"
+    COMPILER="g++-4"
+    case "`g++ -dumpversion` 2>/dev/null" in
+    2.95.*)
+        COMPILER="g++-2.95.*"
+        ;;
+    3.*)
+a        COMPILER="g++-3.*"
+        ;;
+    *)
+        ;;
+    esac
+    ;;
+*)
+    #
+    ;;
+esac
+
+# QT_CONFIG can contain the following:
+#
+# Things that affect the Qt API/ABI:
+#
+#   Options:
+#     minimal-config small-config medium-config large-config full-config
+#
+#   Different edition modules:
+#     gui network canvas table xml opengl sql
+#
+# Things that do not affect the Qt API/ABI:
+#     stl
+#     system-jpeg no-jpeg jpeg
+#     system-mng no-mng mng
+#     system-png no-png png
+#     system-zlib no-zlib zlib
+#     system-libtiff no-libtiff
+#     no-gif gif
+#     debug release
+#     dll staticlib
+#
+#     nocrosscompiler
+#     GNUmake
+#     largefile
+#     nis
+#     nas
+#     tablet
+#     ipv6
+#
+#     X11     : x11sm xinerama xcursor xfixes xrandr xrender mitshm fontconfig xkb
+#     Embedded: embedded qpa freetype
+#
+ALL_OPTIONS=
+BUILD_CONFIG=
+BUILD_OPTIONS=
+
+# determine the build options
+for config_option in $QMAKE_CONFIG $QT_CONFIG; do
+    SKIP="yes"
+    case "$config_option" in
+    *-config)
+        # take the last *-config setting.  this is the highest config being used,
+        # and is the one that we will use for tagging plugins
+        BUILD_CONFIG="$config_option"
+        ;;
+
+    *) # skip all other options since they don't affect the Qt API/ABI.
+        ;;
+    esac
+
+    if [ "$SKIP" = "no" ]; then
+        BUILD_OPTIONS="$BUILD_OPTIONS $config_option"
+    fi
+done
+
+# put the options that we are missing into .options
+rm -f .options
+for opt in `echo $ALL_OPTIONS`; do
+    SKIP="no"
+    if echo $BUILD_OPTIONS | grep $opt >/dev/null 2>&1; then
+        SKIP="yes"
+    fi
+    if [ "$SKIP" = "no" ]; then
+        echo "$opt" >> .options
+    fi
+done
+
+# reconstruct BUILD_OPTIONS with a sorted negative feature list
+# (ie. only things that are missing are will be put into the build key)
+BUILD_OPTIONS=
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+        BUILD_OPTIONS="$BUILD_OPTIONS no-$opt"
+    done
+fi
+rm -f .options
+
+# QT_NO* defines affect the Qt API (and binary compatibility).  they need
+# to be included in the build key
+for build_option in $D_FLAGS; do
+    build_option=`echo $build_option | cut -d \" -f 2 -`
+    case "$build_option" in
+    QT_NO*)
+        echo "$build_option" >> .options
+        ;;
+    *)
+        # skip all other compiler defines
+        ;;
+    esac
+done
+
+# sort the compile time defines (helps ensure that changes in this configure
+# script don't affect the QT_BUILD_KEY generation)
+if [ -f .options ]; then
+    for opt in `sort -f .options | uniq`; do
+        BUILD_OPTIONS="$BUILD_OPTIONS $opt"
+    done
+fi
+rm -f .options
+
+BUILD_OPTIONS="$BUILD_CONFIG $BUILD_OPTIONS"
+# extract the operating system from the XPLATFORM
+TARGET_OPERATING_SYSTEM=`echo $XPLATFORM | cut -f 2- -d/ | cut -f -1 -d-`
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    QT_BUILD_KEY_SYSTEM_PART="Symbian"
+else
+    QT_BUILD_KEY_SYSTEM_PART="$CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPILER"
+fi
+
+# when cross-compiling, don't include build-host information (build key is target specific)
+QT_BUILD_KEY="$CFG_USER_BUILD_KEY $QT_BUILD_KEY_SYSTEM_PART $BUILD_OPTIONS"
+if [ -n "$QT_NAMESPACE" ]; then
+    QT_BUILD_KEY="$QT_BUILD_KEY $QT_NAMESPACE"
+fi
+MAC_NEED_TWO_BUILD_KEYS="no"
+if [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" ]; then
+    QT_BUILD_KEY_CARBON=$QT_BUILD_KEY
+    TARGET_OPERATING_SYSTEM="$TARGET_OPERATING_SYSTEM-cocoa"
+    QT_BUILD_KEY_COCOA="$CFG_USER_BUILD_KEY $CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ "$CFG_MAC_CARBON" = "no" ]; then
+        QT_BUILD_KEY=$QT_BUILD_KEY_COCOA
+    else
+        MAC_NEED_TWO_BUILD_KEYS="yes"
+    fi
+fi
+# don't break loading plugins build with an older version of Qt
+QT_BUILD_KEY_COMPAT=
+if [ "$QT_CROSS_COMPILE" = "no" ]; then
+    # previous versions of Qt used a build key built from the uname
+    QT_BUILD_KEY_COMPAT="$CFG_USER_BUILD_KEY $UNAME_MACHINE $UNAME_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT="$QT_BUILD_KEY_COMPAT $QT_NAMESPACE"
+    fi
+fi
+
+# is this compiler compatible with some other "standard" build key
+QT_BUILD_KEY_COMPAT_COMPILER=
+if [ ! -z "$COMPAT_COMPILER" ]; then
+    QT_BUILD_KEY_COMPAT_COMPILER="$CFG_USER_BUILD_KEY $CFG_ARCH $TARGET_OPERATING_SYSTEM $COMPAT_COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT_COMPILER="$QT_BUILD_KEY_COMPAT_COMPILER $QT_NAMESPACE"
+    fi
+fi
+
+# is this arch compatible with some other "standard" build key
+QT_BUILD_KEY_COMPAT_ARCH=
+if [ ! -z "$COMPAT_ARCH" ]; then
+    QT_BUILD_KEY_COMPAT_ARCH="$CFG_USER_BUILD_KEY $COMPAT_ARCH $TARGET_OPERATING_SYSTEM $COMPILER $BUILD_OPTIONS"
+    if [ -n "$QT_NAMESPACE" ]; then
+        QT_BUILD_KEY_COMPAT_COMPILER="$QT_BUILD_KEY_COMPAT_ARCH $QT_NAMESPACE"
+    fi
+fi
+
+# strip out leading/trailing/extra whitespace
+QT_BUILD_KEY=`echo $QT_BUILD_KEY | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT=`echo $QT_BUILD_KEY_COMPAT | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT_COMPILER=`echo $QT_BUILD_KEY_COMPAT_COMPILER | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+QT_BUILD_KEY_COMPAT_ARCH=`echo $QT_BUILD_KEY_COMPAT_ARCH | sed -e "s,  *, ,g" -e "s,^  *,," -e "s,  *$,,"`
+
+#-------------------------------------------------------------------------------
+# part of configuration information goes into qconfig.h
+#-------------------------------------------------------------------------------
+
+case "$CFG_QCONFIG" in
+full)
+    echo "/* Everything */" >"$outpath/src/corelib/global/qconfig.h.new"
+    ;;
+*)
+    tmpconfig="$outpath/src/corelib/global/qconfig.h.new"
+    echo "#ifndef QT_BOOTSTRAPPED" >"$tmpconfig"
+    if [ -f "$relpath/src/corelib/global/qconfig-$CFG_QCONFIG.h" ]; then
+        cat "$relpath/src/corelib/global/qconfig-$CFG_QCONFIG.h" >>"$tmpconfig"
+    elif [ -f `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` ]; then
+        cat `"$relpath/config.tests/unix/makeabs" "${CFG_QCONFIG}"` >>"$tmpconfig"
+    fi
+    echo "#endif" >>"$tmpconfig"
+    ;;
+esac
+
+cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+
+/* Qt Edition */
+#ifndef QT_EDITION
+#  define QT_EDITION $QT_EDITION
+#endif
+
+/* Machine byte-order */
+#define Q_BIG_ENDIAN 4321
+#define Q_LITTLE_ENDIAN 1234
+EOF
+
+if [ "$MAC_NEED_TWO_BUILD_KEYS" = "no" ]; then
+    echo "#define QT_BUILD_KEY \"$QT_BUILD_KEY\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+else
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+
+#define QT_BUILD_KEY_CARBON "$QT_BUILD_KEY_CARBON"
+#define QT_BUILD_KEY_COCOA "$QT_BUILD_KEY_COCOA"
+EOF
+fi
+
+if [ -n "$QT_BUILD_KEY_COMPAT" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT \"$QT_BUILD_KEY_COMPAT\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+if [ -n "$QT_BUILD_KEY_COMPAT_COMPILER" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT2 \"$QT_BUILD_KEY_COMPAT_COMPILER\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+if [ -n "$QT_BUILD_KEY_COMPAT_ARCH" ]; then
+    echo "#define QT_BUILD_KEY_COMPAT3 \"$QT_BUILD_KEY_COMPAT_ARCH\"" \
+        >> "$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+echo "" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+echo "#ifdef QT_BOOTSTRAPPED" >>"$outpath/src/corelib/global/qconfig.h.new"
+if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__BIG_ENDIAN__)
+# define Q_BYTE_ORDER Q_BIG_ENDIAN
+#elif defined(__LITTLE_ENDIAN__)
+# define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+# error "Unable to determine byte order!"
+#endif
+EOF
+else
+    echo "#define Q_BYTE_ORDER $CFG_HOST_ENDIAN" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+echo "#else" >>"$outpath/src/corelib/global/qconfig.h.new"
+if [ "$CFG_ENDIAN" = "auto" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__BIG_ENDIAN__)
+# define Q_BYTE_ORDER Q_BIG_ENDIAN
+#elif defined(__LITTLE_ENDIAN__)
+# define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+# error "Unable to determine byte order!"
+#endif
+EOF
+else
+    echo "#define Q_BYTE_ORDER $CFG_ENDIAN" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+echo "#endif" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_DOUBLEFORMAT" != "normal" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+/* Non-IEEE double format */
+#define Q_DOUBLE_LITTLE "01234567"
+#define Q_DOUBLE_BIG "76543210"
+#define Q_DOUBLE_LITTLE_SWAPPED "45670123"
+#define Q_DOUBLE_BIG_SWAPPED "32107654"
+#define Q_DOUBLE_FORMAT $CFG_DOUBLEFORMAT
+EOF
+fi
+if [ "$CFG_ARMFPA" = "yes" ]; then
+    if [ "$CFG_ARCH" != "$CFG_HOST_ARCH" ]; then
+	cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#ifndef QT_BOOTSTRAPPED
+# define QT_ARMFPA
+#endif
+EOF
+    else
+	echo "#define QT_ARMFPA" >>"$outpath/src/corelib/global/qconfig.h.new"
+    fi
+fi
+
+CFG_ARCH_STR=`echo $CFG_ARCH | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+CFG_HOST_ARCH_STR=`echo $CFG_HOST_ARCH | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+/* Machine Architecture */
+#ifndef QT_BOOTSTRAPPED
+# define QT_ARCH_${CFG_ARCH_STR}
+#else
+# define QT_ARCH_${CFG_HOST_ARCH_STR}
+#endif
+EOF
+
+echo '/* Compile time features */' >>"$outpath/src/corelib/global/qconfig.h.new"
+[ '!' -z "$LicenseKeyExt" ] && echo "#define QT_PRODUCT_LICENSEKEY \"$LicenseKeyExt\"" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_LARGEFILE" = "yes" ] && [ "$XPLATFORM_MINGW" != "yes" ]; then
+    echo "#define QT_LARGEFILE_SUPPORT 64" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+# if both carbon and cocoa are specified, enable the autodetection code.
+if [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" -a "$CFG_MAC_CARBON" = "yes" ]; then
+    echo "#define QT_AUTODETECT_COCOA 1" >>"$outpath/src/corelib/global/qconfig.h.new"
+elif [ "$PLATFORM_MAC" = "yes" -a "$CFG_MAC_COCOA" = "yes" ]; then
+    echo "#define QT_MAC_USE_COCOA 1" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+if [ "$CFG_FRAMEWORK" = "yes" ]; then
+    echo "#define QT_MAC_FRAMEWORK_BUILD" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
+#if defined(__LP64__)
+# define QT_POINTER_SIZE 8
+#else
+# define QT_POINTER_SIZE 4
+#endif
+EOF
+elif [ "$XPLATFORM_SYMBIAN_SBSV2" = "no" ]; then
+    # Raptor does not support configure tests.
+    "$unixtests/ptrsize.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
+    echo "#define QT_POINTER_SIZE $?" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+
+echo "" >>"$outpath/src/corelib/global/qconfig.h.new"
+
+if [ "$CFG_DEV" = "yes" ]; then
+    echo "#define QT_BUILD_INTERNAL" >>"$outpath/src/corelib/global/qconfig.h.new"
+fi
+
+# Embedded compile time options
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    # Add QWS to config.h
+    QCONFIG_FLAGS="$QCONFIG_FLAGS Q_WS_QWS"
+
+    # Add excluded decorations to $QCONFIG_FLAGS
+    decors=`grep '^decorations -= ' "$QMAKE_VARS_FILE" | ${AWK} '{print $3}'`
+    for decor in $decors; do
+        NODECORATION=`echo $decor | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="${QCONFIG_FLAGS} QT_NO_QWS_DECORATION_${NODECORATION}"
+    done
+
+    # Figure which embedded drivers which are turned off
+    CFG_GFX_OFF="$CFG_GFX_AVAILABLE"
+    for ADRIVER in $CFG_GFX_ON; do
+        CFG_GFX_OFF=`echo "${CFG_GFX_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    CFG_KBD_OFF="$CFG_KBD_AVAILABLE"
+    # the um driver is currently not in the available list for external builds
+    if [ "$CFG_DEV" = "no" ]; then
+	CFG_KBD_OFF="$CFG_KBD_OFF um"
+    fi
+    for ADRIVER in $CFG_KBD_ON; do
+        CFG_KBD_OFF=`echo "${CFG_KBD_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    CFG_MOUSE_OFF="$CFG_MOUSE_AVAILABLE"
+    for ADRIVER in $CFG_MOUSE_ON; do
+        CFG_MOUSE_OFF=`echo "${CFG_MOUSE_OFF} " | sed "s,${ADRIVER} ,,g"`
+    done
+
+    for DRIVER in $CFG_GFX_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_$NODRIVER"
+    done
+
+    for DRIVER in $CFG_KBD_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_KBD_$NODRIVER"
+    done
+
+    for DRIVER in $CFG_MOUSE_OFF; do
+        NODRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_QWS_MOUSE_$NODRIVER"
+    done
+fi # QWS
+
+if [ "$PLATFORM_QPA" = "yes" ]; then
+    # Add QPA to config.h
+    QCONFIG_FLAGS="$QCONFIG_FLAGS Q_WS_QPA QT_NO_QWS_QPF QT_NO_QWS_QPF2"
+fi
+
+if [ "${CFG_USE_FLOATMATH}" = "yes" ]; then
+    QCONFIG_FLAGS="${QCONFIG_FLAGS} QT_USE_MATH_H_FLOATS"
+fi
+
+# Add turned on SQL drivers
+for DRIVER in $CFG_SQL_AVAILABLE; do
+    eval "VAL=\$CFG_SQL_$DRIVER"
+    case "$VAL" in
+    qt)
+        ONDRIVER=`echo $DRIVER | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+        QCONFIG_FLAGS="$QCONFIG_FLAGS QT_SQL_$ONDRIVER"
+        SQL_DRIVERS="$SQL_DRIVERS $DRIVER"
+    ;;
+    plugin)
+        SQL_PLUGINS="$SQL_PLUGINS $DRIVER"
+    ;;
+    esac
+done
+
+
+QMakeVar set sql-drivers "$SQL_DRIVERS"
+QMakeVar set sql-plugins "$SQL_PLUGINS"
+
+# Add other configuration options to the qconfig.h file
+[ "$CFG_GIF" = "yes" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_BUILTIN_GIF_READER=1"
+[ "$CFG_TIFF" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_TIFF"
+[ "$CFG_PNG" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_PNG"
+[ "$CFG_JPEG" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_JPEG"
+[ "$CFG_MNG" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IMAGEFORMAT_MNG"
+[ "$CFG_ZLIB" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ZLIB"
+[ "$CFG_S60" != "yes" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_S60"
+[ "$CFG_EXCEPTIONS" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_EXCEPTIONS"
+[ "$CFG_IPV6" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IPV6"
+[ "$CFG_SXE" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SXE"
+[ "$CFG_DBUS" = "no" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_DBUS"
+
+if [ "$PLATFORM_QWS" != "yes" -a "$PLATFORM_QPA" != "yes" ]; then
+    [ "$CFG_GRAPHICS_SYSTEM" = "raster" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_RASTER"
+    [ "$CFG_GRAPHICS_SYSTEM" = "opengl" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_OPENGL"
+    [ "$CFG_GRAPHICS_SYSTEM" = "openvg" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_OPENVG"
+    [ "$CFG_GRAPHICS_SYSTEM" = "runtime" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_GRAPHICSSYSTEM_RUNTIME"
+fi
+
+# On Windows codec plugins are used (hardcoded in .pro files)
+if [ "$XPLATFORM_MINGW" = "yes" ]; then
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_CODEC_PLUGINS"
+fi
+
+# X11/Unix/Mac only configs
+[ "$CFG_ICONV" = "no" ]      && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ICONV"
+[ "$CFG_GLIB" != "yes" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GLIB"
+[ "$CFG_QGTKSTYLE" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_GTK"
+if [ "$XPLATFORM_SYMBIAN" = "no" ]; then
+    # Do not apply following negative X11/Unix/Mac only flags on Symbian, so that
+    # configuration matches with the one generated by configure executable tool
+    [ "$CFG_CUPS" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CUPS"
+    [ "$CFG_GSTREAMER" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GSTREAMER"
+    [ "$CFG_CLOCK_MONOTONIC" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CLOCK_MONOTONIC"
+    [ "$CFG_MREMAP" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MREMAP"
+    [ "$CFG_GETADDRINFO" = "no" ]&& QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GETADDRINFO"
+    [ "$CFG_IPV6IFNAME" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_IPV6IFNAME"
+    [ "$CFG_GETIFADDRS" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_GETIFADDRS"
+    [ "$CFG_INOTIFY" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_INOTIFY"
+    [ "$CFG_NAS" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_NAS"
+    [ "$CFG_NIS" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_NIS"
+    [ "$CFG_OPENSSL" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_OPENSSL"
+    [ "$CFG_OPENSSL" = "linked" ]&& QCONFIG_FLAGS="$QCONFIG_FLAGS QT_LINKED_OPENSSL"
+
+    [ "$CFG_SM" = "no" ]         && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SESSIONMANAGER"
+    [ "$CFG_XCURSOR" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XCURSOR"
+    [ "$CFG_XFIXES" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XFIXES"
+    [ "$CFG_FONTCONFIG" = "no" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_FONTCONFIG"
+    [ "$CFG_XINERAMA" = "no" ]   && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINERAMA"
+    [ "$CFG_XKB" = "no" ]        && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XKB"
+    [ "$CFG_XRANDR" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XRANDR"
+    [ "$CFG_XRENDER" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XRENDER"
+    [ "$CFG_MITSHM" = "no" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_MITSHM"
+    [ "$CFG_XSHAPE" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_SHAPE"
+    [ "$CFG_XVIDEO" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XVIDEO"
+    [ "$CFG_XSYNC" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XSYNC"
+    [ "$CFG_XINPUT" = "no" ]     && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XINPUT QT_NO_TABLET"
+
+    [ "$CFG_XCURSOR" = "runtime" ]   && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XCURSOR"
+    [ "$CFG_XINERAMA" = "runtime" ]  && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XINERAMA"
+    [ "$CFG_XFIXES" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XFIXES"
+    [ "$CFG_XRANDR" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XRANDR"
+    [ "$CFG_XINPUT" = "runtime" ]    && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_RUNTIME_XINPUT"
+    [ "$CFG_ALSA" = "no" ]           && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ALSA"
+    [ "$CFG_PULSEAUDIO" = "no" ]          && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_PULSEAUDIO"
+    [ "$CFG_COREWLAN" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_COREWLAN"
+    [ "$CFG_ICD" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ICD"
+fi
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # Disable styles not applicable on Symbian
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_CDE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_CLEANLOOKS"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_MOTIF"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_PLASTIQUE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSCE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSMOBILE"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSVISTA"
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_WINDOWSXP"
+fi
+
+# sort QCONFIG_FLAGS for neatness if we can
+[ '!' -z "$AWK" ] && QCONFIG_FLAGS=`echo $QCONFIG_FLAGS | $AWK '{ gsub(" ", "\n"); print }' | sort | uniq`
+QCONFIG_FLAGS=`echo $QCONFIG_FLAGS`
+
+if [ "$XPLATFORM_SYMBIAN" = "yes" ]; then
+    # Enable Symbian DLLs and export rules.
+    # We cannot use Linux's default export rules since they export everything.
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_DLL"
+    # Disable non-working features.
+    QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_CRASHHANDLER QT_NO_PRINTER QT_NO_SYSTEMTRAYICON"
+fi
+
+if [ -n "$QCONFIG_FLAGS" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#ifndef QT_BOOTSTRAPPED
+
+EOF
+    # default QPA platform specified?
+    if [ -n "$QT_QPA_DEFAULT_PLATFORM" ] && [ "$QT_QPA_DEFAULT_PLATFORM" != "auto" ]; then
+        echo "#define QT_QPA_DEFAULT_PLATFORM_NAME \"$QT_QPA_DEFAULT_PLATFORM\"" >>"$outpath/src/corelib/global/qconfig.h.new"
+        echo >>"$outpath/src/corelib/global/qconfig.h.new"
+    fi
+
+    for cfg in $QCONFIG_FLAGS; do
+        cfgd=`echo $cfg | sed 's/=.*$//'` # trim pushed 'Foo=Bar' defines
+        cfg=`echo $cfg | sed 's/=/ /'`    # turn first '=' into a space
+        # figure out define logic, so we can output the correct
+        # ifdefs to override the global defines in a project
+        cfgdNeg=
+        if [ true ] && echo "$cfgd" | grep 'QT_NO_' >/dev/null 2>&1; then
+            # QT_NO_option can be forcefully turned on by QT_option
+            cfgdNeg=`echo $cfgd | sed "s,QT_NO_,QT_,"`
+        elif [ true ] && echo "$cfgd" | grep 'QT_' >/dev/null 2>&1; then
+            # QT_option can be forcefully turned off by QT_NO_option
+            cfgdNeg=`echo $cfgd | sed "s,QT_,QT_NO_,"`
+        fi
+
+        if [ -z $cfgdNeg ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#ifndef $cfgd
+# define $cfg
+#endif
+
+EOF
+        else
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#if defined($cfgd) && defined($cfgdNeg)
+# undef $cfgd
+#elif !defined($cfgd) && !defined($cfgdNeg)
+# define $cfg
+#endif
+
+EOF
+        fi
+    done
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#endif // QT_BOOTSTRAPPED
+
+EOF
+fi
+
+if [ "$CFG_REDUCE_EXPORTS" = "yes" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_VISIBILITY_AVAILABLE
+
+EOF
+fi
+
+if [ -n "$QT_LIBINFIX" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_LIBINFIX "$QT_LIBINFIX"
+
+EOF
+fi
+
+if [ -n "$CFG_RUNTIME_SYSTEM" ]; then
+cat >>"$outpath/src/corelib/global/qconfig.h.new" << EOF
+#define QT_DEFAULT_RUNTIME_SYSTEM "$CFG_RUNTIME_SYSTEM"
+
+EOF
+fi
+
+# avoid unecessary rebuilds by copying only if qconfig.h has changed
+if cmp -s "$outpath/src/corelib/global/qconfig.h" "$outpath/src/corelib/global/qconfig.h.new"; then
+    rm -f "$outpath/src/corelib/global/qconfig.h.new"
+else
+    [ -f "$outpath/src/corelib/global/qconfig.h" ] && chmod +w "$outpath/src/corelib/global/qconfig.h"
+    mv "$outpath/src/corelib/global/qconfig.h.new" "$outpath/src/corelib/global/qconfig.h"
+    chmod -w "$outpath/src/corelib/global/qconfig.h"
+    for conf in "$outpath/include/QtCore/qconfig.h" "$outpath/include/Qt/qconfig.h"; do
+        ln -s "$outpath/src/corelib/global/qconfig.h" "$conf"
+    done
+fi
+#-------------------------------------------------------------------------------
+# save configuration into qconfig.pri
+#-------------------------------------------------------------------------------
+
+QTCONFIG="$outpath/mkspecs/qconfig.pri"
+QTCONFIG_CONFIG="$QTCONFIG_CONFIG no_mocdepend"
+[ -f "$QTCONFIG.tmp" ] && rm -f "$QTCONFIG.tmp"
+if [ "$CFG_DEBUG" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG debug"
+    if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG release"
+    fi
+    QT_CONFIG="$QT_CONFIG debug"
+elif [ "$CFG_DEBUG" = "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG release"
+    if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+        QT_CONFIG="$QT_CONFIG debug"
+    fi
+    QT_CONFIG="$QT_CONFIG release"
+fi
+if [ "$CFG_STL" = "yes" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG stl"
+fi
+if [ "$CFG_FRAMEWORK" = "no" ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_no_framework"
+else
+    QT_CONFIG="$QT_CONFIG qt_framework"
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_framework"
+fi
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG $CFG_MAC_ARCHS"
+fi
+if [ "$CFG_DEV" = "yes" ]; then
+    QT_CONFIG="$QT_CONFIG private_tests"
+fi
+
+if [ -z "$QT_CFLAGS_FPU" ]; then
+    if echo "$XPLATFORM" | grep "symbian-sbsv2" > /dev/null 2>&1; then
+        QT_CFLAGS_FPU=softvfp
+    fi
+fi
+
+# Make the application arch follow the Qt arch for single arch builds.
+# (for multiple-arch builds, set CONFIG manually in the application .pro file)
+if [ `echo "$CFG_MAC_ARCHS" | wc -w` -eq 1 ]; then
+    QTCONFIG_CONFIG="$QTCONFIG_CONFIG $CFG_MAC_ARCHS"
+fi
+
+cat >>"$QTCONFIG.tmp" <<EOF
+#configuration
+CONFIG += $QTCONFIG_CONFIG
+QT_ARCH = $CFG_ARCH
+QT_EDITION = $Edition
+QT_CONFIG += $QT_CONFIG
+
+#versioning
+QT_VERSION = $QT_VERSION
+QT_MAJOR_VERSION = $QT_MAJOR_VERSION
+QT_MINOR_VERSION = $QT_MINOR_VERSION
+QT_PATCH_VERSION = $QT_PATCH_VERSION
+
+#namespaces
+QT_LIBINFIX = $QT_LIBINFIX
+QT_NAMESPACE = $QT_NAMESPACE
+QT_NAMESPACE_MAC_CRC = $QT_NAMESPACE_MAC_CRC
+
+EOF
+if [ -n "$CFG_SYSROOT" ]; then
+    echo "# sysroot" >>"$QTCONFIG.tmp"
+    echo `basename "$XQMAKESPEC"` \{ >>"$QTCONFIG.tmp"
+    echo "  QT_SYSROOT      += \$\$quote($CFG_SYSROOT)" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_CFLAGS    += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_CXXFLAGS  += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "  QMAKE_LFLAGS    += --sysroot=\$\$QT_SYSROOT" >>"$QTCONFIG.tmp"
+    echo "}" >> "$QTCONFIG.tmp"
+    echo >> "$QTCONFIG.tmp"
+fi
+if [ "$CFG_RPATH" = "yes" ]; then
+    echo "QMAKE_RPATHDIR += \"$QT_INSTALL_LIBS\"" >> "$QTCONFIG.tmp"
+fi
+if [ -n "$QT_GCC_MAJOR_VERSION" ]; then
+    echo "QT_GCC_MAJOR_VERSION = $QT_GCC_MAJOR_VERSION" >> "$QTCONFIG.tmp"
+    echo "QT_GCC_MINOR_VERSION = $QT_GCC_MINOR_VERSION" >> "$QTCONFIG.tmp"
+    echo "QT_GCC_PATCH_VERSION = $QT_GCC_PATCH_VERSION" >> "$QTCONFIG.tmp"
+fi
+if [ -n "$QT_CFLAGS_FPU" ]; then
+    echo "#Qt for symbian FPU settings" >> "$QTCONFIG.tmp"
+    echo "MMP_RULES += \"ARMFPU $QT_CFLAGS_FPU\"" >> "$QTCONFIG.tmp"
+fi
+
+if [ -n "$QMAKE_INCDIR_OPENGL_ES2" ]; then
+    echo "#Qt opengl include path" >> "$QTCONFIG.tmp"
+    echo "QMAKE_INCDIR_OPENGL_ES2 = \"$QMAKE_INCDIR_OPENGL_ES2\"" >> "$QTCONFIG.tmp"
+fi
+
+# replace qconfig.pri if it differs from the newly created temp file
+if cmp -s "$QTCONFIG.tmp" "$QTCONFIG"; then
+    rm -f "$QTCONFIG.tmp"
+else
+    mv -f "$QTCONFIG.tmp" "$QTCONFIG"
+fi
+
+#-------------------------------------------------------------------------------
+# save configuration into .qmake.cache
+#-------------------------------------------------------------------------------
+
+CACHEFILE="$outpath/.qmake.cache"
+[ -f "$CACHEFILE.tmp" ] && rm -f "$CACHEFILE.tmp"
+cat >>"$CACHEFILE.tmp" <<EOF
+CONFIG += $QMAKE_CONFIG dylib create_prl link_prl depend_includepath fix_output_dirs QTDIR_build
+QT_SOURCE_TREE = \$\$quote($relpath)
+QT_BUILD_TREE = \$\$quote($outpath)
+QT_BUILD_PARTS = $CFG_BUILD_PARTS
+QMAKE_ABSOLUTE_SOURCE_ROOT = \$\$QT_SOURCE_TREE
+QMAKE_MOC_SRC    = \$\$QT_BUILD_TREE/src/moc
+
+#local paths that cannot be queried from the QT_INSTALL_* properties while building QTDIR
+QMAKE_MOC        = \$\$QT_BUILD_TREE/bin/moc
+QMAKE_UIC        = \$\$QT_BUILD_TREE/bin/uic
+QMAKE_UIC3       = \$\$QT_BUILD_TREE/bin/uic3
+QMAKE_RCC        = \$\$QT_BUILD_TREE/bin/rcc
+QMAKE_QDBUSXML2CPP = \$\$QT_BUILD_TREE/bin/qdbusxml2cpp
+QMAKE_INCDIR_QT  = \$\$QT_BUILD_TREE/include
+QMAKE_LIBDIR_QT  = \$\$QT_BUILD_TREE/lib
+
+EOF
+
+# Ensure we can link to uninistalled libraries
+QMAKE_COMPILER="`getQMakeConf QMAKE_CXX`"
+if [ "$XPLATFORM_MINGW" != "yes" ] && [ "$CFG_EMBEDDED" != "nacl" ] && linkerSupportsFlag "$QMAKE_COMPILER" -rpath-link "$outpath/lib"; then
+    echo "QMAKE_LFLAGS    = -Wl,-rpath-link,\$\$QT_BUILD_TREE/lib \$\$QMAKE_LFLAGS" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_PSQL" ]; then
+    echo "QT_CFLAGS_PSQL   = $QT_CFLAGS_PSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_PSQL" ]; then
+    echo "QT_LFLAGS_PSQL   = $QT_LFLAGS_PSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_MYSQL" ]; then
+    echo "QT_CFLAGS_MYSQL   = $QT_CFLAGS_MYSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_MYSQL" ]; then
+    echo "QT_LFLAGS_MYSQL   = $QT_LFLAGS_MYSQL" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_CFLAGS_SQLITE" ]; then
+    echo "QT_CFLAGS_SQLITE   = $QT_CFLAGS_SQLITE" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_SQLITE" ]; then
+    echo "QT_LFLAGS_SQLITE   = $QT_LFLAGS_SQLITE" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_ODBC" ]; then
+    echo "QT_LFLAGS_ODBC   = $QT_LFLAGS_ODBC" >> "$CACHEFILE.tmp"
+fi
+if [ -n "$QT_LFLAGS_TDS" ]; then
+    echo "QT_LFLAGS_TDS   = $QT_LFLAGS_TDS" >> "$CACHEFILE.tmp"
+fi
+
+if [ "$QT_EDITION" != "QT_EDITION_OPENSOURCE" ]; then
+    echo "DEFINES *= QT_EDITION=QT_EDITION_DESKTOP" >> "$CACHEFILE.tmp"
+fi
+
+#dump in the OPENSSL_LIBS info
+if [ '!' -z "$OPENSSL_LIBS" ]; then
+    echo "OPENSSL_LIBS = $OPENSSL_LIBS" >> "$CACHEFILE.tmp"
+elif [ "$CFG_OPENSSL" = "linked" ]; then
+    echo "OPENSSL_LIBS = -lssl -lcrypto" >> "$CACHEFILE.tmp"
+fi
+
+#dump in the SDK info
+if [ '!' -z "$CFG_SDK" ]; then
+   echo "QMAKE_MAC_SDK = $CFG_SDK" >> "$CACHEFILE.tmp"
+fi
+
+# mac gcc -Xarch support
+if [ "$CFG_MAC_XARCH" = "no" ]; then
+   echo "QMAKE_MAC_XARCH = no" >> "$CACHEFILE.tmp"
+fi
+
+#dump the qmake spec
+if [ -d "$outpath/mkspecs/$XPLATFORM" ]; then
+   echo "QMAKESPEC = \$\$QT_BUILD_TREE/mkspecs/$XPLATFORM" >> "$CACHEFILE.tmp"
+else
+   echo "QMAKESPEC = $XPLATFORM" >> "$CACHEFILE.tmp"
+fi
+
+# cmdline args
+cat "$QMAKE_VARS_FILE" >> "$CACHEFILE.tmp"
+rm -f "$QMAKE_VARS_FILE" 2>/dev/null
+
+# incrementals
+INCREMENTAL=""
+[ "$CFG_INCREMENTAL" = "auto" ] && "$WHICH" p4 >/dev/null 2>&1 && [ "$CFG_DEV" = "yes" ] && CFG_INCREMENTAL="yes"
+if [ "$CFG_INCREMENTAL" = "yes" ]; then
+    find "$relpath" -perm u+w -mtime -3 | grep 'cpp$' | while read f; do
+        # don't need to worry about generated files
+        [ -r `echo $f | sed "s,cpp$,ui,"` ] && continue
+        basename "$f" | grep '^moc_' >/dev/null 2>&1 && continue
+        # done
+        INCREMENTAL="$INCREMENTAL `basename \"$f\" | sed 's,.cpp,.o,'`"
+    done
+    [ '!' -z "$INCREMENTAL" ] && echo "QMAKE_INCREMENTAL += $INCREMENTAL" >> "$CACHEFILE.tmp"
+    [ -r "$outpath/.qmake.incremental" ] && echo "include($outpath/.qmake.incremental)" >> "$CACHEFILE.tmp"
+fi
+
+# replace .qmake.cache if it differs from the newly created temp file
+if cmp -s "$CACHEFILE.tmp" "$CACHEFILE"; then
+    rm -f "$CACHEFILE.tmp"
+else
+    mv -f "$CACHEFILE.tmp" "$CACHEFILE"
+fi
+
+#-------------------------------------------------------------------------------
+# give feedback on configuration
+#-------------------------------------------------------------------------------
+
+case "$COMPILER" in
+g++*)
+    if [ "$CFG_EXCEPTIONS" != "no" ]; then
+        cat <<EOF
+
+        This target is using the GNU C++ compiler ($PLATFORM).
+
+        Recent versions of this compiler automatically include code for
+        exceptions, which increase both the size of the Qt libraries and
+        the amount of memory taken by your applications.
+
+        You may choose to re-run `basename $0` with the -no-exceptions
+        option to compile Qt without exceptions. This is completely binary
+        compatible, and existing applications will continue to work.
+
+EOF
+    fi
+    ;;
+cc*)
+    case "$PLATFORM" in
+    irix-cc*)
+        if [ "$CFG_EXCEPTIONS" != "no" ]; then
+            cat <<EOF
+
+        This target is using the MIPSpro C++ compiler ($PLATFORM).
+
+        You may choose to re-run `basename $0` with the -no-exceptions
+        option to compile Qt without exceptions. This will make the
+        size of the Qt library smaller and reduce the amount of memory
+        taken by your applications.
+
+EOF
+        fi
+        ;;
+    *) ;;
+    esac
+    ;;
+*) ;;
+esac
+
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_MAC_DWARF2" = "no" ]  && [ "$CFG_WEBKIT" != "no" ] && [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+    cat <<EOF
+        WARNING: DWARF2 debug symbols are not enabled. Linking webkit
+        in debug mode will run out of memory on systems with 2GB or less.
+        Install Xcode 2.4.1 or higher to enable DWARF2, or configure with
+         -no-webkit or -release to skip webkit debug.
+EOF
+fi
+
+echo
+if [ "$XPLATFORM" = "$PLATFORM" ]; then
+    echo "Build type:    $PLATFORM"
+else
+    echo "Building on:   $PLATFORM"
+    echo "Building for:  $XPLATFORM"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    echo "Architecture:  $CFG_ARCH ($CFG_MAC_ARCHS )"
+else
+    echo "Architecture:  $CFG_ARCH"
+fi
+
+if [ "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "yes" ]; then
+    echo "Host architecture: $CFG_HOST_ARCH"
+fi
+
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$CFG_MAC_COCOA" = "yes" ]; then
+        if [ "$CFG_MAC_CARBON" = "yes" ]; then
+            echo "Using framework: Carbon for 32-bit, Cocoa for 64-bit"
+        else
+            echo "Using framework: Cocoa"
+        fi
+    else
+        echo "Using framework: Carbon"
+    fi
+fi
+
+if [ -n "$PLATFORM_NOTES" ]; then
+    echo "Platform notes:"
+    echo "$PLATFORM_NOTES"
+else
+    echo
+fi
+
+if [ "$OPT_VERBOSE" = "yes" ]; then
+    echo $ECHO_N "qmake vars .......... $ECHO_C"
+    cat "$QMAKE_VARS_FILE" | tr '\n' ' '
+    echo "qmake switches ......... $QMAKE_SWITCHES"
+fi
+
+[ "$CFG_INCREMENTAL" = "yes" ] && [ '!' -z "$INCREMENTAL" ] && echo "Incremental ............ $INCREMENTAL"
+echo "Build .................. $CFG_BUILD_PARTS"
+echo "Configuration .......... $QMAKE_CONFIG $QT_CONFIG"
+if [ "$CFG_DEBUG_RELEASE" = "yes" ]; then
+   echo "Debug .................. yes (combined)"
+   if [ "$CFG_DEBUG" = "yes" ]; then
+       echo "Default Link ........... debug"
+   else
+       echo "Default Link ........... release"
+   fi
+else
+   echo "Debug .................. $CFG_DEBUG"
+fi
+echo "Qt 3 compatibility ..... $CFG_QT3SUPPORT"
+[ "$CFG_DBUS" = "no" ]     && echo "QtDBus module .......... no"
+[ "$CFG_DBUS" = "yes" ]    && echo "QtDBus module .......... yes (run-time)"
+[ "$CFG_DBUS" = "linked" ] && echo "QtDBus module .......... yes (linked)"
+echo "QtConcurrent code ...... $CFG_CONCURRENT"
+echo "QtGui module ........... $CFG_GUI"
+echo "QtScript module ........ $CFG_SCRIPT"
+echo "QtScriptTools module ... $CFG_SCRIPTTOOLS"
+echo "QtXmlPatterns module ... $CFG_XMLPATTERNS"
+echo "Phonon module .......... $CFG_PHONON"
+echo "Multimedia module ...... $CFG_MULTIMEDIA"
+echo "SVG module ............. $CFG_SVG"
+case "$CFG_WEBKIT" in
+    yes)   echo "WebKit module .......... yes" ;;
+    debug) echo "WebKit module .......... yes (debug)" ;;
+    no)    echo "WebKit module .......... no" ;;
+esac
+if [ "$CFG_WEBKIT" != "no" ] || [ "$CFG_SCRIPT" != "no" ]; then
+    if [ "$CFG_JAVASCRIPTCORE_JIT" = "auto" ]; then
+        echo "JavaScriptCore JIT ..... To be decided by JavaScriptCore"
+    else
+        echo "JavaScriptCore JIT ..... $CFG_JAVASCRIPTCORE_JIT"
+    fi
+fi
+echo "Declarative module ..... $CFG_DECLARATIVE"
+if [ "$CFG_DECLARATIVE" = "yes" ]; then
+    echo "Declarative debugging ...$CFG_DECLARATIVE_DEBUG"
+fi
+echo "Support for S60 ........ $CFG_S60"
+echo "Symbian DEF files ...... $CFG_SYMBIAN_DEFFILES"
+echo "STL support ............ $CFG_STL"
+echo "PCH support ............ $CFG_PRECOMPILE"
+echo "MMX/3DNOW/SSE/SSE2/SSE3. ${CFG_MMX}/${CFG_3DNOW}/${CFG_SSE}/${CFG_SSE2}/${CFG_SSE3}"
+echo "SSSE3/SSE4.1/SSE4.2..... ${CFG_SSSE3}/${CFG_SSE4_1}/${CFG_SSE4_2}"
+echo "AVX..................... ${CFG_AVX}"
+if [ "$CFG_ARCH" = "arm" ] || [ "$CFG_ARCH" = "armv6" ]; then
+    echo "iWMMXt support ......... ${CFG_IWMMXT}"
+    echo "NEON support ........... ${CFG_NEON}"
+fi
+[ "${PLATFORM_QWS}" != "yes" -a "${PLATFORM_QPA}" != "yes" ] && echo "Graphics System ........ $CFG_GRAPHICS_SYSTEM"
+echo "IPv6 support ........... $CFG_IPV6"
+echo "IPv6 ifname support .... $CFG_IPV6IFNAME"
+echo "getaddrinfo support .... $CFG_GETADDRINFO"
+echo "getifaddrs support ..... $CFG_GETIFADDRS"
+echo "Accessibility .......... $CFG_ACCESSIBILITY"
+echo "NIS support ............ $CFG_NIS"
+echo "CUPS support ........... $CFG_CUPS"
+echo "Iconv support .......... $CFG_ICONV"
+echo "Glib support ........... $CFG_GLIB"
+echo "GStreamer support ...... $CFG_GSTREAMER"
+echo "PulseAudio support ..... $CFG_PULSEAUDIO"
+echo "Large File support ..... $CFG_LARGEFILE"
+echo "GIF support ............ $CFG_GIF"
+if [ "$CFG_TIFF" = "no" ]; then
+    echo "TIFF support ........... $CFG_TIFF"
+else
+    echo "TIFF support ........... $CFG_TIFF ($CFG_LIBTIFF)"
+fi
+if [ "$CFG_JPEG" = "no" ]; then
+    echo "JPEG support ........... $CFG_JPEG"
+else
+    echo "JPEG support ........... $CFG_JPEG ($CFG_LIBJPEG)"
+fi
+if [ "$CFG_PNG" = "no" ]; then
+    echo "PNG support ............ $CFG_PNG"
+else
+    echo "PNG support ............ $CFG_PNG ($CFG_LIBPNG)"
+fi
+if [ "$CFG_MNG" = "no" ]; then
+    echo "MNG support ............ $CFG_MNG"
+else
+    echo "MNG support ............ $CFG_MNG ($CFG_LIBMNG)"
+fi
+if [ "$XPLATFORM_QNX" = "yes" ]; then
+    echo "SLOG2 support .......... $CFG_SLOG2"
+fi
+echo "zlib support ........... $CFG_ZLIB"
+echo "Session management ..... $CFG_SM"
+if [ "$PLATFORM_QWS" = "yes" ]; then
+    echo "Embedded support ....... $CFG_EMBEDDED"
+    if [ "$CFG_QWS_FREETYPE" = "auto" ]; then
+	echo "Freetype2 support ...... $CFG_QWS_FREETYPE ($CFG_LIBFREETYPE)"
+    else
+	echo "Freetype2 support ...... $CFG_QWS_FREETYPE"
+    fi
+    # Normalize the decoration output first
+    CFG_GFX_ON=`echo ${CFG_GFX_ON}`
+    CFG_GFX_PLUGIN=`echo ${CFG_GFX_PLUGIN}`
+    echo "Graphics (qt) .......... ${CFG_GFX_ON}"
+    echo "Graphics (plugin) ...... ${CFG_GFX_PLUGIN}"
+    CFG_DECORATION_ON=`echo ${CFG_DECORATION_ON}`
+    CFG_DECORATION_PLUGIN=`echo ${CFG_DECORATION_PLUGIN}`
+    echo "Decorations (qt) ....... $CFG_DECORATION_ON"
+    echo "Decorations (plugin) ... $CFG_DECORATION_PLUGIN"
+    CFG_KBD_ON=`echo ${CFG_KBD_ON}`
+    CFG_KBD_PLUGIN=`echo ${CFG_KBD_PLUGIN}`
+    echo "Keyboard driver (qt) ... ${CFG_KBD_ON}"
+    echo "Keyboard driver (plugin) .. ${CFG_KBD_PLUGIN}"
+    CFG_MOUSE_ON=`echo ${CFG_MOUSE_ON}`
+    CFG_MOUSE_PLUGIN=`echo ${CFG_MOUSE_PLUGIN}`
+    echo "Mouse driver (qt) ...... $CFG_MOUSE_ON"
+    echo "Mouse driver (plugin) .. $CFG_MOUSE_PLUGIN"
+fi
+if [ "$CFG_OPENGL" = "desktop" ]; then
+    echo "OpenGL support ......... yes (Desktop OpenGL)"
+elif [ "$CFG_OPENGL" = "es1" ]; then
+    echo "OpenGL support ......... yes (OpenGL ES 1.x Common profile)"
+elif [ "$CFG_OPENGL" = "es2" ]; then
+    echo "OpenGL support ......... yes (OpenGL ES 2.x)"
+else
+    echo "OpenGL support ......... no"
+fi
+if [ "$CFG_EGL" != "no" ]; then
+    if [ "$CFG_EGL_GLES_INCLUDES" = "yes" ]; then
+        echo "EGL support ............ yes <GLES/egl.h>"
+    else
+        echo "EGL support ............ yes <EGL/egl.h>"
+    fi
+fi
+if [ "$CFG_OPENVG" ]; then
+    if [ "$CFG_OPENVG_SHIVA" = "yes" ]; then
+        echo "OpenVG support ......... ShivaVG"
+    else
+        echo "OpenVG support ......... $CFG_OPENVG"
+    fi
+fi
+if [ "$PLATFORM_X11" = "yes" ]; then
+    echo "NAS sound support ...... $CFG_NAS"
+    echo "XShape support ......... $CFG_XSHAPE"
+    echo "XVideo support ......... $CFG_XVIDEO"
+    echo "XSync support .......... $CFG_XSYNC"
+    echo "Xinerama support ....... $CFG_XINERAMA"
+    echo "Xcursor support ........ $CFG_XCURSOR"
+    echo "Xfixes support ......... $CFG_XFIXES"
+    echo "Xrandr support ......... $CFG_XRANDR"
+    echo "Xrender support ........ $CFG_XRENDER"
+    echo "Xi support ............. $CFG_XINPUT"
+    echo "MIT-SHM support ........ $CFG_MITSHM"
+    echo "FontConfig support ..... $CFG_FONTCONFIG"
+    echo "XKB Support ............ $CFG_XKB"
+    echo "immodule support ....... $CFG_IM"
+    echo "GTK theme support ...... $CFG_QGTKSTYLE"
+fi
+[ "$CFG_SQL_mysql" != "no" ] && echo "MySQL support .......... $CFG_SQL_mysql"
+[ "$CFG_SQL_psql" != "no" ] && echo "PostgreSQL support ..... $CFG_SQL_psql"
+[ "$CFG_SQL_odbc" != "no" ] && echo "ODBC support ........... $CFG_SQL_odbc"
+[ "$CFG_SQL_oci" != "no" ] && echo "OCI support ............ $CFG_SQL_oci"
+[ "$CFG_SQL_tds" != "no" ] && echo "TDS support ............ $CFG_SQL_tds"
+[ "$CFG_SQL_db2" != "no" ] && echo "DB2 support ............ $CFG_SQL_db2"
+[ "$CFG_SQL_ibase" != "no" ] && echo "InterBase support ...... $CFG_SQL_ibase"
+[ "$CFG_SQL_sqlite2" != "no" ] && echo "SQLite 2 support ....... $CFG_SQL_sqlite2"
+[ "$CFG_SQL_sqlite" != "no" ] && echo "SQLite support ......... $CFG_SQL_sqlite ($CFG_SQLITE)"
+
+OPENSSL_LINKAGE=""
+if [ "$CFG_OPENSSL" = "yes" ]; then
+    OPENSSL_LINKAGE="(run-time)"
+elif [ "$CFG_OPENSSL" = "linked" ]; then
+    OPENSSL_LINKAGE="(linked)"
+fi
+echo "OpenSSL support ........ $CFG_OPENSSL $OPENSSL_LINKAGE"
+echo "Alsa support ........... $CFG_ALSA"
+if [ "$PLATFORM_MAC" = "yes" ]; then
+    echo "CoreWlan support ....... $CFG_COREWLAN"
+fi
+echo "ICD support ............ $CFG_ICD"
+echo "libICU support ......... $CFG_ICU"
+echo "Use system proxies ..... $CFG_SYSTEM_PROXIES"
+echo
+
+[ "$CFG_PTMALLOC" != "no" ] && echo "Use ptmalloc ........... $CFG_PTMALLOC"
+
+# complain about not being able to use dynamic plugins if we are using a static build
+if [ "$CFG_SHARED" = "no" ]; then
+    echo
+    echo "WARNING: Using static linking will disable the use of dynamically"
+    echo "loaded plugins. Make sure to import all needed static plugins,"
+    echo "or compile needed modules into the library."
+    echo
+fi
+if [ "$CFG_OPENSSL" = "linked" ] && [ "$OPENSSL_LIBS" = "" ]; then
+    echo
+    echo "NOTE: When linking against OpenSSL, you can override the default"
+    echo "library names through OPENSSL_LIBS."
+    echo "For example:"
+    echo "    OPENSSL_LIBS='-L/opt/ssl/lib -lssl -lcrypto' ./configure -openssl-linked"
+    echo
+fi
+if [ "$PLATFORM_MAC" = "yes" ] && [ "$CFG_FRAMEWORK" = "yes" ] && [ "$CFG_DEBUG" = "yes" ] && [ "$CFG_DEBUG_RELEASE" = "no" ]; then
+    echo
+    echo "Error: debug-only framework builds are not supported. Configure with -no-framework"
+    echo "if you want a pure debug build."
+    echo
+    exit 1
+fi
+
+sepath=`echo "$relpath" | sed -e 's/\\./\\\\./g'`
+PROCS=1
+EXEC=""
+
+
+#-------------------------------------------------------------------------------
+# build makefiles based on the configuration
+#-------------------------------------------------------------------------------
+
+echo "Finding project files. Please wait..."
+if [ "$CFG_NOPROCESS" != "yes" ]; then
+    "$outpath/bin/qmake" -prl -r "${relpath}/projects.pro"
+    if [ -f "${relpath}/projects.pro" ]; then
+        mkfile="${outpath}/Makefile"
+        [ -f "$mkfile" ] && chmod +w "$mkfile"
+        QTDIR="$outpath" "$outpath/bin/qmake" -spec "$XQMAKESPEC" "${relpath}/projects.pro" -o "$mkfile"
+    fi
+fi
+
+# .projects      -> projects to process
+# .projects.1    -> qt and moc
+# .projects.2    -> subdirs and libs
+# .projects.3    -> the rest
+rm -f .projects .projects.1 .projects.2 .projects.3
+
+QMAKE_PROJECTS=`find "$relpath/." -name '*.pro' -print | sed 's-/\./-/-'`
+if [ -z "$AWK" ]; then
+    for p in `echo $QMAKE_PROJECTS`; do
+        echo "$p" >> .projects
+    done
+else
+    cat >projects.awk <<EOF
+BEGIN {
+    files = 0
+    target_file = ""
+    input_file = ""
+
+    first = "./.projects.1.tmp"
+    second = "./.projects.2.tmp"
+    third = "./.projects.3.tmp"
+}
+
+FNR == 1 {
+    if ( input_file ) {
+        if ( ! target_file )
+            target_file = third
+        print input_file >target_file
+    }
+
+    matched_target = 0
+    template_lib = 0
+    input_file = FILENAME
+    target_file = ""
+}
+
+/^(TARGET.*=)/ {
+    if ( \$3 == "moc" || \$3 ~ /^Qt/ ) {
+        target_file = first
+        matched_target = 1
+    } else if ( \$3 == "lrelease" || \$3 == "qm_phony_target" ) {
+        target_file = second
+        matched_target = 1
+    }
+}
+
+matched_target == 0 && /^(TEMPLATE.*=)/ {
+    if ( \$3 == "subdirs" )
+        target_file = second
+    else if ( \$3 == "lib" )
+        template_lib = 1
+    else
+        target_file = third
+}
+
+matched_target == 0 && template_lib == 1 && /^(CONFIG.*=)/ {
+    if ( \$0 ~ /plugin/ )
+        target_file = third
+    else
+        target_file = second
+}
+
+END {
+    if ( input_file ) {
+        if ( ! target_file )
+            target_file = third
+        print input_file >>target_file
+    }
+}
+
+EOF
+
+    rm -f .projects.all
+    for p in `echo $QMAKE_PROJECTS`; do
+       echo "$p" >> .projects.all
+    done
+
+    # if you get errors about the length of the command line to awk, change the -l arg
+    # to split below
+    split -l 100 .projects.all .projects.all.
+    for p in .projects.all.*; do
+       "$AWK" -f projects.awk `cat $p`
+       [ -f .projects.1.tmp ] && cat .projects.1.tmp >> .projects.1
+       [ -f .projects.2.tmp ] && cat .projects.2.tmp >> .projects.2
+       [ -f .projects.3.tmp ] && cat .projects.3.tmp >> .projects.3
+       rm -f .projects.1.tmp .projects.2.tmp .projects.3.tmp $p
+    done
+    rm -f .projects.all* projects.awk
+
+    [ -f .projects.1 ] && cat .projects.1 >>.projects
+    [ -f .projects.2 ] && cat .projects.2 >>.projects
+    rm -f .projects.1 .projects.2
+    if [ -f .projects.3 ] && [ "$OPT_FAST" = "no" ]; then
+       cat .projects.3 >>.projects
+       rm -f .projects.3
+    fi
+fi
+# don't sort Qt and MOC in with the other project files
+# also work around a segfaulting uniq(1)
+if [ -f .sorted.projects.2 ]; then
+    sort .sorted.projects.2 > .sorted.projects.2.new
+    mv -f .sorted.projects.2.new .sorted.projects.2
+    cat .sorted.projects.2 >> .sorted.projects.1
+fi
+[ -f .sorted.projects.1 ] && sort .sorted.projects.1 >> .sorted.projects
+rm -f .sorted.projects.2 .sorted.projects.1
+
+NORM_PROJECTS=0
+FAST_PROJECTS=0
+if [ -f .projects ]; then
+   uniq .projects >.tmp
+   mv -f .tmp .projects
+   NORM_PROJECTS=`cat .projects | wc -l | sed -e "s, ,,g"`
+fi
+if [ -f .projects.3 ]; then
+   uniq .projects.3 >.tmp
+   mv -f .tmp .projects.3
+   FAST_PROJECTS=`cat .projects.3 | wc -l | sed -e "s, ,,g"`
+fi
+echo "  `expr $NORM_PROJECTS + $FAST_PROJECTS` projects found."
+echo
+
+PART_ROOTS=
+for part in $CFG_BUILD_PARTS; do
+    case "$part" in
+    tools) PART_ROOTS="$PART_ROOTS tools" ;;
+    libs) PART_ROOTS="$PART_ROOTS src tools/linguist/lrelease" ;;
+    translations) PART_ROOTS="$PART_ROOTS translations" ;;
+    examples) PART_ROOTS="$PART_ROOTS examples demos" ;;
+    *) ;;
+    esac
+done
+
+if [ "$CFG_DEV" = "yes" ]; then
+    PART_ROOTS="$PART_ROOTS tests"
+fi
+
+echo "Creating makefiles. Please wait..."
+for file in .projects .projects.3; do
+    [ '!' -f "$file" ] && continue
+    for a in `cat $file`; do
+        IN_ROOT=no
+	for r in $PART_ROOTS; do
+	    if echo "$a" | grep "^$r" >/dev/null 2>&1 || echo "$a" | grep "^$relpath/$r" >/dev/null 2>&1; then
+		IN_ROOT=yes
+		break
+            fi
+	done
+        [ "$IN_ROOT" = "no" ] && continue
+
+        case $a in
+        *winmain/winmain.pro)
+            if [ "$CFG_NOPROCESS" = "yes" ] || [ "$XPLATFORM_MINGW" != "yes" ]; then
+                continue
+            fi
+            SPEC=$XQMAKESPEC ;;
+        *s60main/s60main.pro)
+            if [ "$CFG_NOPROCESS" = "yes" ] || [ "$XPLATFORM_SYMBIAN" != "yes" ]; then
+                continue
+            fi;;
+        *examples/activeqt/*) continue ;;
+        */qmake/qmake.pro) continue ;;
+        *tools/bootstrap*|*tools/moc*|*tools/rcc*|*tools/uic*|*linguist/lrelease*) SPEC=$QMAKESPEC ;;
+        *) if [ "$CFG_NOPROCESS" = "yes" ]; then
+              continue
+           else
+              SPEC=$XQMAKESPEC
+           fi;;
+        esac
+        dir=`dirname "$a" | sed -e "s;$sepath;.;g"`
+        test -d "$dir" || mkdir -p "$dir"
+        OUTDIR="$outpath/$dir"
+        if [ -f "${OUTDIR}/Makefile" ] && [ "$OPT_FAST" = "yes" ]; then
+            # fast configure - the makefile exists, skip it
+            # since the makefile exists, it was generated by qmake, which means we
+            # can skip it, since qmake has a rule to regenerate the makefile if the .pro
+            # file changes...
+            [ "$OPT_VERBOSE" = "yes" ] && echo "  skipping $a"
+            continue;
+        fi
+        QMAKE_SPEC_ARGS="-spec $SPEC"
+        echo $ECHO_N "  for $a$ECHO_C"
+
+        QMAKE="$outpath/bin/qmake"
+	QMAKE_ARGS="$QMAKE_SWITCHES $QMAKE_SPEC_ARGS"
+        if [ "$file" = ".projects.3" ]; then
+            echo " (fast)"
+
+            cat >"${OUTDIR}/Makefile" <<EOF
+# ${OUTDIR}/Makefile: generated by configure
+#
+# WARNING: This makefile will be replaced with a real makefile.
+# All changes made to this file will be lost.
+EOF
+            [ "$CFG_DEBUG_RELEASE" = "no" ] && echo "first_target: first" >>${OUTDIR}/Makefile
+
+            cat >>"${OUTDIR}/Makefile" <<EOF
+QMAKE = "$QMAKE"
+all clean install qmake first Makefile: FORCE
+	\$(QMAKE) $QMAKE_ARGS -o "$OUTDIR" "$a"
+	cd "$OUTDIR"
+	\$(MAKE) \$@
+
+FORCE:
+
+EOF
+        else
+            if [ "$OPT_VERBOSE" = "yes" ]; then
+                echo " (`basename $SPEC`)"
+                echo "$QMAKE" $QMAKE_ARGS -o "$OUTDIR" "$a"
+	    else
+		echo
+            fi
+
+            [ -f "${OUTDIR}/Makefile" ] && chmod +w "${OUTDIR}/Makefile"
+            QTDIR="$outpath" "$QMAKE" $QMAKE_ARGS -o "$OUTDIR" "$a"
+       fi
+    done
+done
+rm -f .projects .projects.3
+
+#-------------------------------------------------------------------------------
+# check for platforms that we don't yet know about
+#-------------------------------------------------------------------------------
+if [ "$CFG_ARCH" = "generic" ]; then
+cat <<EOF
+
+        NOTICE: Atomic operations are not yet supported for this
+        architecture.
+
+        Qt will use the 'generic' architecture instead, which uses a
+        single pthread_mutex_t to protect all atomic operations. This
+        implementation is the slow (but safe) fallback implementation
+        for architectures Qt does not yet support.
+EOF
+fi
+
+#-------------------------------------------------------------------------------
+# check if the user passed the -no-zlib option, which is no longer supported
+#-------------------------------------------------------------------------------
+if [ -n "$ZLIB_FORCED" ]; then
+    which_zlib="supplied"
+    if [ "$CFG_ZLIB" = "system" ]; then
+	which_zlib="system"
+    fi
+
+cat <<EOF
+
+        NOTICE: The -no-zlib option was supplied but is no longer
+        supported.
+
+        Qt now requires zlib support in all builds, so the -no-zlib
+        option was ignored. Qt will be built using the $which_zlib
+        zlib.
+EOF
+fi
+
+#-------------------------------------------------------------------------------
+# finally save the executed command to another script
+#-------------------------------------------------------------------------------
+if [ `basename $0` != "config.status" ]; then
+    CONFIG_STATUS="$relpath/$relconf $OPT_CMDLINE"
+
+    # add the system variables
+    for varname in $SYSTEM_VARIABLES; do
+        cmd=`echo \
+'if [ -n "\$'${varname}'" ]; then
+    CONFIG_STATUS="'${varname}'='"'\\\$${varname}'"' \$CONFIG_STATUS"
+fi'`
+	eval "$cmd"
+    done
+
+    echo "$CONFIG_STATUS" | grep '\-confirm\-license' >/dev/null 2>&1 || CONFIG_STATUS="$CONFIG_STATUS -confirm-license"
+
+    [ -f "$outpath/config.status" ] && rm -f "$outpath/config.status"
+    echo "#!/bin/sh" > "$outpath/config.status"
+    echo "if [ \"\$#\" -gt 0 ]; then" >> "$outpath/config.status"
+    echo "  $CONFIG_STATUS \"\$@\"" >> "$outpath/config.status"
+    echo "else" >> "$outpath/config.status"
+    echo "  $CONFIG_STATUS" >> "$outpath/config.status"
+    echo "fi" >> "$outpath/config.status"
+    chmod +x "$outpath/config.status"
+fi
+
+if [ -n "$RPATH_MESSAGE" ]; then
+    echo
+    echo "$RPATH_MESSAGE"
+fi
+
+MAKE=`basename "$MAKE"`
+echo
+echo Qt is now configured for building. Just run \'$MAKE\'.
+if [ "$relpath" = "$QT_INSTALL_PREFIX" ]; then
+    echo Once everything is built, Qt is installed.
+    echo You should not run \'$MAKE install\'.
+else
+    echo Once everything is built, you must run \'$MAKE install\'.
+    echo Qt will be installed into $QT_INSTALL_PREFIX
+fi
+echo
+echo To reconfigure, run \'$MAKE confclean\' and \'configure\'.
+echo
diff -Naur qt-everywhere-opensource-src-4.8.7-original/examples/desktop/systray/window.cpp qt-everywhere-opensource-src-4.8.7/examples/desktop/systray/window.cpp
--- qt-everywhere-opensource-src-4.8.7-original/examples/desktop/systray/window.cpp	2015-05-07 14:14:37.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/examples/desktop/systray/window.cpp	2017-09-26 08:03:14.973414406 +0000
@@ -158,15 +158,23 @@
     iconComboBox->addItem(QIcon(":/images/bad.svg"), tr("Bad"));
     iconComboBox->addItem(QIcon(":/images/heart.svg"), tr("Heart"));
     iconComboBox->addItem(QIcon(":/images/trash.svg"), tr("Trash"));
+    iconComboBox->addItem(QIcon::fromTheme("system-file-manager"), tr("File Manager"));
 
     showIconCheckBox = new QCheckBox(tr("Show icon"));
     showIconCheckBox->setChecked(true);
 
+#if defined(Q_WS_X11)
+    jitToolTipCheckBox = new QCheckBox(tr("Just In Time Tooltip"));
+#endif
+
     QHBoxLayout *iconLayout = new QHBoxLayout;
     iconLayout->addWidget(iconLabel);
     iconLayout->addWidget(iconComboBox);
     iconLayout->addStretch();
     iconLayout->addWidget(showIconCheckBox);
+#if defined(Q_WS_X11)
+    iconLayout->addWidget(jitToolTipCheckBox);
+#endif
     iconGroupBox->setLayout(iconLayout);
 }
 
@@ -254,5 +262,37 @@
     trayIconMenu->addAction(quitAction);
 
     trayIcon = new QSystemTrayIcon(this);
+    QByteArray category = qgetenv("SNI_CATEGORY");
+    if (!category.isEmpty()) {
+        trayIcon->setProperty("_qt_sni_category", QString::fromLocal8Bit(category));
+    }
     trayIcon->setContextMenu(trayIconMenu);
+
+#if defined(Q_WS_X11)
+    trayIcon->installEventFilter(this);
+#endif
+}
+
+#if defined(Q_WS_X11)
+bool Window::eventFilter(QObject *, QEvent *event)
+{
+    switch(event->type()) {
+    case QEvent::ToolTip:
+        if (jitToolTipCheckBox->isChecked()) {
+            QString timeString = QTime::currentTime().toString();
+            trayIcon->setToolTip(tr("Current Time: %1").arg(timeString));
+        }
+        break;
+    case QEvent::Wheel: {
+        QWheelEvent *wheelEvent = static_cast<QWheelEvent*>(event);
+        int delta = wheelEvent->delta() > 0 ? 1 : -1;
+        int index = (iconComboBox->currentIndex() + delta) % iconComboBox->count();
+        iconComboBox->setCurrentIndex(index);
+        break;
+    }
+    default:
+        break;
+    }
+    return false;
 }
+#endif
diff -Naur qt-everywhere-opensource-src-4.8.7-original/examples/desktop/systray/window.h qt-everywhere-opensource-src-4.8.7/examples/desktop/systray/window.h
--- qt-everywhere-opensource-src-4.8.7-original/examples/desktop/systray/window.h	2015-05-07 14:14:37.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/examples/desktop/systray/window.h	2017-09-26 08:03:14.976747740 +0000
@@ -69,6 +69,9 @@
 
 protected:
     void closeEvent(QCloseEvent *event);
+#if defined(Q_WS_X11)
+    bool eventFilter(QObject *object, QEvent *event);
+#endif
 
 private slots:
     void setIcon(int index);
@@ -86,6 +89,9 @@
     QLabel *iconLabel;
     QComboBox *iconComboBox;
     QCheckBox *showIconCheckBox;
+#if defined(Q_WS_X11)
+    QCheckBox *jitToolTipCheckBox;
+#endif
 
     QGroupBox *messageGroupBox;
     QLabel *typeLabel;
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/corelib/global/qglobal.h qt-everywhere-opensource-src-4.8.7/src/corelib/global/qglobal.h
--- qt-everywhere-opensource-src-4.8.7-original/src/corelib/global/qglobal.h	2015-05-07 14:14:48.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/corelib/global/qglobal.h	2017-09-26 08:07:13.030089179 +0000
@@ -52,7 +52,7 @@
 /*
    can be used like #if (QT_VERSION >= QT_VERSION_CHECK(4, 4, 0))
 */
-#define QT_VERSION_CHECK(major, minor, patch) ((major<<16)|(minor<<8)|(patch))
+#define QT_VERSION_CHECK(qt_version_check_major, qt_version_check_minor, qt_version_check_patch) ((qt_version_check_major<<16)|(qt_version_check_minor<<8)|(qt_version_check_patch))
 
 #define QT_PACKAGEDATE_STR "2015-05-07"
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_glib.cpp qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_glib.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_glib.cpp	2015-05-07 14:14:48.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_glib.cpp	2017-09-26 08:04:51.846751038 +0000
@@ -65,6 +65,7 @@
 struct GSocketNotifierSource
 {
     GSource source;
+    QEventLoop::ProcessEventsFlags processEventsFlags;
     QList<GPollFDWithQSocketNotifier *> pollfds;
 };
 
@@ -80,6 +81,9 @@
     GSocketNotifierSource *src = reinterpret_cast<GSocketNotifierSource *>(source);
 
     bool pending = false;
+    if (src->processEventsFlags & QEventLoop::ExcludeSocketNotifiers)
+        return pending;
+
     for (int i = 0; !pending && i < src->pollfds.count(); ++i) {
         GPollFDWithQSocketNotifier *p = src->pollfds.at(i);
 
@@ -103,6 +107,9 @@
     QEvent event(QEvent::SockAct);
 
     GSocketNotifierSource *src = reinterpret_cast<GSocketNotifierSource *>(source);
+    if (src->processEventsFlags & QEventLoop::ExcludeSocketNotifiers)
+        return true;
+
     for (int i = 0; i < src->pollfds.count(); ++i) {
         GPollFDWithQSocketNotifier *p = src->pollfds.at(i);
 
@@ -248,22 +255,30 @@
     GSource source;
     QAtomicInt serialNumber;
     int lastSerialNumber;
+    QEventLoop::ProcessEventsFlags processEventsFlags;
     QEventDispatcherGlibPrivate *d;
 };
 
 static gboolean postEventSourcePrepare(GSource *s, gint *timeout)
 {
+    GPostEventSource *source = reinterpret_cast<GPostEventSource *>(s);
     QThreadData *data = QThreadData::current();
     if (!data)
         return false;
 
+    QEventLoop::ProcessEventsFlags excludeAllFlags
+        = QEventLoop::ExcludeUserInputEvents
+        | QEventLoop::ExcludeSocketNotifiers
+        | QEventLoop::X11ExcludeTimers;
+    if ((source->processEventsFlags & excludeAllFlags) == excludeAllFlags)
+        return false;
+
     gint dummy;
     if (!timeout)
         timeout = &dummy;
     const bool canWait = data->canWaitLocked();
     *timeout = canWait ? -1 : 0;
 
-    GPostEventSource *source = reinterpret_cast<GPostEventSource *>(s);
     return (!canWait
             || (source->serialNumber != source->lastSerialNumber));
 }
@@ -277,8 +292,14 @@
 {
     GPostEventSource *source = reinterpret_cast<GPostEventSource *>(s);
     source->lastSerialNumber = source->serialNumber;
-    QCoreApplication::sendPostedEvents();
-    source->d->runTimersOnceWithNormalPriority();
+    QEventLoop::ProcessEventsFlags excludeAllFlags
+        = QEventLoop::ExcludeUserInputEvents
+        | QEventLoop::ExcludeSocketNotifiers
+        | QEventLoop::X11ExcludeTimers;
+    if ((source->processEventsFlags & excludeAllFlags) != excludeAllFlags) {
+        QCoreApplication::sendPostedEvents();
+        source->d->runTimersOnceWithNormalPriority();
+    }
     return true; // i dunno, george...
 }
 
@@ -322,6 +343,7 @@
     postEventSource = reinterpret_cast<GPostEventSource *>(g_source_new(&postEventSourceFuncs,
                                                                         sizeof(GPostEventSource)));
     postEventSource->serialNumber = 1;
+    postEventSource->processEventsFlags = QEventLoop::AllEvents;
     postEventSource->d = this;
     g_source_set_can_recurse(&postEventSource->source, true);
     g_source_attach(&postEventSource->source, mainContext);
@@ -331,6 +353,7 @@
         reinterpret_cast<GSocketNotifierSource *>(g_source_new(&socketNotifierSourceFuncs,
                                                                sizeof(GSocketNotifierSource)));
     (void) new (&socketNotifierSource->pollfds) QList<GPollFDWithQSocketNotifier *>();
+    socketNotifierSource->processEventsFlags = QEventLoop::AllEvents;
     g_source_set_can_recurse(&socketNotifierSource->source, true);
     g_source_attach(&socketNotifierSource->source, mainContext);
 
@@ -415,7 +438,9 @@
 
     // tell postEventSourcePrepare() and timerSource about any new flags
     QEventLoop::ProcessEventsFlags savedFlags = d->timerSource->processEventsFlags;
+    d->postEventSource->processEventsFlags = flags;
     d->timerSource->processEventsFlags = flags;
+    d->socketNotifierSource->processEventsFlags = flags;
 
     if (!(flags & QEventLoop::EventLoopExec)) {
         // force timers to be sent at normal priority
@@ -426,7 +451,9 @@
     while (!result && canWait)
         result = g_main_context_iteration(d->mainContext, canWait);
 
+    d->postEventSource->processEventsFlags = savedFlags;
     d->timerSource->processEventsFlags = savedFlags;
+    d->socketNotifierSource->processEventsFlags = savedFlags;
 
     if (canWait)
         emit awake();
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_glib.cpp.orig qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_glib.cpp.orig
--- qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_glib.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_glib.cpp.orig	2015-05-07 14:14:48.000000000 +0000
@@ -0,0 +1,602 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 The Qt Company Ltd.
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see http://www.qt.io/terms-conditions. For further
+** information use the contact form at http://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** As a special exception, The Qt Company gives you certain additional
+** rights. These rights are described in The Qt Company LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qeventdispatcher_glib_p.h"
+#include "qeventdispatcher_unix_p.h"
+
+#include <private/qmutexpool_p.h>
+#include <private/qthread_p.h>
+
+#include "qcoreapplication.h"
+#include "qsocketnotifier.h"
+
+#include <QtCore/qhash.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qpair.h>
+
+#include <glib.h>
+
+QT_BEGIN_NAMESPACE
+
+struct GPollFDWithQSocketNotifier
+{
+    GPollFD pollfd;
+    QSocketNotifier *socketNotifier;
+};
+
+struct GSocketNotifierSource
+{
+    GSource source;
+    QList<GPollFDWithQSocketNotifier *> pollfds;
+};
+
+static gboolean socketNotifierSourcePrepare(GSource *, gint *timeout)
+{
+    if (timeout)
+        *timeout = -1;
+    return false;
+}
+
+static gboolean socketNotifierSourceCheck(GSource *source)
+{
+    GSocketNotifierSource *src = reinterpret_cast<GSocketNotifierSource *>(source);
+
+    bool pending = false;
+    for (int i = 0; !pending && i < src->pollfds.count(); ++i) {
+        GPollFDWithQSocketNotifier *p = src->pollfds.at(i);
+
+        if (p->pollfd.revents & G_IO_NVAL) {
+            // disable the invalid socket notifier
+            static const char *t[] = { "Read", "Write", "Exception" };
+            qWarning("QSocketNotifier: Invalid socket %d and type '%s', disabling...",
+                     p->pollfd.fd, t[int(p->socketNotifier->type())]);
+            // ### note, modifies src->pollfds!
+            p->socketNotifier->setEnabled(false);
+        }
+
+        pending = ((p->pollfd.revents & p->pollfd.events) != 0);
+    }
+
+    return pending;
+}
+
+static gboolean socketNotifierSourceDispatch(GSource *source, GSourceFunc, gpointer)
+{
+    QEvent event(QEvent::SockAct);
+
+    GSocketNotifierSource *src = reinterpret_cast<GSocketNotifierSource *>(source);
+    for (int i = 0; i < src->pollfds.count(); ++i) {
+        GPollFDWithQSocketNotifier *p = src->pollfds.at(i);
+
+        if ((p->pollfd.revents & p->pollfd.events) != 0)
+            QCoreApplication::sendEvent(p->socketNotifier, &event);
+    }
+
+    return true; // ??? don't remove, right?
+}
+
+static GSourceFuncs socketNotifierSourceFuncs = {
+    socketNotifierSourcePrepare,
+    socketNotifierSourceCheck,
+    socketNotifierSourceDispatch,
+    NULL,
+    NULL,
+    NULL
+};
+
+struct GTimerSource
+{
+    GSource source;
+    QTimerInfoList timerList;
+    QEventLoop::ProcessEventsFlags processEventsFlags;
+    bool runWithIdlePriority;
+};
+
+static gboolean timerSourcePrepareHelper(GTimerSource *src, gint *timeout)
+{
+    timeval tv = { 0l, 0l };
+    if (!(src->processEventsFlags & QEventLoop::X11ExcludeTimers) && src->timerList.timerWait(tv))
+        *timeout = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+    else
+        *timeout = -1;
+
+    return (*timeout == 0);
+}
+
+static gboolean timerSourceCheckHelper(GTimerSource *src)
+{
+    if (src->timerList.isEmpty()
+        || (src->processEventsFlags & QEventLoop::X11ExcludeTimers))
+        return false;
+
+    if (src->timerList.updateCurrentTime() < src->timerList.first()->timeout)
+        return false;
+
+    return true;
+}
+
+static gboolean timerSourcePrepare(GSource *source, gint *timeout)
+{
+    gint dummy;
+    if (!timeout)
+        timeout = &dummy;
+
+    GTimerSource *src = reinterpret_cast<GTimerSource *>(source);
+    if (src->runWithIdlePriority) {
+        if (timeout)
+            *timeout = -1;
+        return false;
+    }
+
+    return timerSourcePrepareHelper(src, timeout);
+}
+
+static gboolean timerSourceCheck(GSource *source)
+{
+    GTimerSource *src = reinterpret_cast<GTimerSource *>(source);
+    if (src->runWithIdlePriority)
+        return false;
+    return timerSourceCheckHelper(src);
+}
+
+static gboolean timerSourceDispatch(GSource *source, GSourceFunc, gpointer)
+{
+    GTimerSource *timerSource = reinterpret_cast<GTimerSource *>(source);
+    if (timerSource->processEventsFlags & QEventLoop::X11ExcludeTimers)
+        return true;
+    timerSource->runWithIdlePriority = true;
+    (void) timerSource->timerList.activateTimers();
+    return true; // ??? don't remove, right again?
+}
+
+static GSourceFuncs timerSourceFuncs = {
+    timerSourcePrepare,
+    timerSourceCheck,
+    timerSourceDispatch,
+    NULL,
+    NULL,
+    NULL
+};
+
+struct GIdleTimerSource
+{
+    GSource source;
+    GTimerSource *timerSource;
+};
+
+static gboolean idleTimerSourcePrepare(GSource *source, gint *timeout)
+{
+    GIdleTimerSource *idleTimerSource = reinterpret_cast<GIdleTimerSource *>(source);
+    GTimerSource *timerSource = idleTimerSource->timerSource;
+    if (!timerSource->runWithIdlePriority) {
+        // Yield to the normal priority timer source
+        if (timeout)
+            *timeout = -1;
+        return false;
+    }
+
+    return timerSourcePrepareHelper(timerSource, timeout);
+}
+
+static gboolean idleTimerSourceCheck(GSource *source)
+{
+    GIdleTimerSource *idleTimerSource = reinterpret_cast<GIdleTimerSource *>(source);
+    GTimerSource *timerSource = idleTimerSource->timerSource;
+    if (!timerSource->runWithIdlePriority) {
+        // Yield to the normal priority timer source
+        return false;
+    }
+    return timerSourceCheckHelper(timerSource);
+}
+
+static gboolean idleTimerSourceDispatch(GSource *source, GSourceFunc, gpointer)
+{
+    GTimerSource *timerSource = reinterpret_cast<GIdleTimerSource *>(source)->timerSource;
+    (void) timerSourceDispatch(&timerSource->source, 0, 0);
+    return true;
+}
+
+static GSourceFuncs idleTimerSourceFuncs = {
+    idleTimerSourcePrepare,
+    idleTimerSourceCheck,
+    idleTimerSourceDispatch,
+    NULL,
+    NULL,
+    NULL
+};
+
+struct GPostEventSource
+{
+    GSource source;
+    QAtomicInt serialNumber;
+    int lastSerialNumber;
+    QEventDispatcherGlibPrivate *d;
+};
+
+static gboolean postEventSourcePrepare(GSource *s, gint *timeout)
+{
+    QThreadData *data = QThreadData::current();
+    if (!data)
+        return false;
+
+    gint dummy;
+    if (!timeout)
+        timeout = &dummy;
+    const bool canWait = data->canWaitLocked();
+    *timeout = canWait ? -1 : 0;
+
+    GPostEventSource *source = reinterpret_cast<GPostEventSource *>(s);
+    return (!canWait
+            || (source->serialNumber != source->lastSerialNumber));
+}
+
+static gboolean postEventSourceCheck(GSource *source)
+{
+    return postEventSourcePrepare(source, 0);
+}
+
+static gboolean postEventSourceDispatch(GSource *s, GSourceFunc, gpointer)
+{
+    GPostEventSource *source = reinterpret_cast<GPostEventSource *>(s);
+    source->lastSerialNumber = source->serialNumber;
+    QCoreApplication::sendPostedEvents();
+    source->d->runTimersOnceWithNormalPriority();
+    return true; // i dunno, george...
+}
+
+static GSourceFuncs postEventSourceFuncs = {
+    postEventSourcePrepare,
+    postEventSourceCheck,
+    postEventSourceDispatch,
+    NULL,
+    NULL,
+    NULL
+};
+
+
+QEventDispatcherGlibPrivate::QEventDispatcherGlibPrivate(GMainContext *context)
+    : mainContext(context)
+{
+    if (qgetenv("QT_NO_THREADED_GLIB").isEmpty()) {
+        static int dummyValue = 0; // only used for its address
+        QMutexLocker locker(QMutexPool::instance()->get(&dummyValue));
+        if (!g_thread_supported())
+            g_thread_init(NULL);
+    }
+
+    if (mainContext) {
+        g_main_context_ref(mainContext);
+    } else {
+        QCoreApplication *app = QCoreApplication::instance();
+        if (app && QThread::currentThread() == app->thread()) {
+            mainContext = g_main_context_default();
+            g_main_context_ref(mainContext);
+        } else {
+            mainContext = g_main_context_new();
+        }
+    }
+
+#if GLIB_CHECK_VERSION (2, 22, 0)
+    g_main_context_push_thread_default (mainContext);
+#endif
+
+    // setup post event source
+    postEventSource = reinterpret_cast<GPostEventSource *>(g_source_new(&postEventSourceFuncs,
+                                                                        sizeof(GPostEventSource)));
+    postEventSource->serialNumber = 1;
+    postEventSource->d = this;
+    g_source_set_can_recurse(&postEventSource->source, true);
+    g_source_attach(&postEventSource->source, mainContext);
+
+    // setup socketNotifierSource
+    socketNotifierSource =
+        reinterpret_cast<GSocketNotifierSource *>(g_source_new(&socketNotifierSourceFuncs,
+                                                               sizeof(GSocketNotifierSource)));
+    (void) new (&socketNotifierSource->pollfds) QList<GPollFDWithQSocketNotifier *>();
+    g_source_set_can_recurse(&socketNotifierSource->source, true);
+    g_source_attach(&socketNotifierSource->source, mainContext);
+
+    // setup normal and idle timer sources
+    timerSource = reinterpret_cast<GTimerSource *>(g_source_new(&timerSourceFuncs,
+                                                                sizeof(GTimerSource)));
+    (void) new (&timerSource->timerList) QTimerInfoList();
+    timerSource->processEventsFlags = QEventLoop::AllEvents;
+    timerSource->runWithIdlePriority = false;
+    g_source_set_can_recurse(&timerSource->source, true);
+    g_source_attach(&timerSource->source, mainContext);
+
+    idleTimerSource = reinterpret_cast<GIdleTimerSource *>(g_source_new(&idleTimerSourceFuncs,
+                                                                        sizeof(GIdleTimerSource)));
+    idleTimerSource->timerSource = timerSource;
+    g_source_set_can_recurse(&idleTimerSource->source, true);
+    g_source_set_priority(&idleTimerSource->source, G_PRIORITY_DEFAULT_IDLE);
+    g_source_attach(&idleTimerSource->source, mainContext);
+}
+
+void QEventDispatcherGlibPrivate::runTimersOnceWithNormalPriority()
+{
+    timerSource->runWithIdlePriority = false;
+}
+
+QEventDispatcherGlib::QEventDispatcherGlib(QObject *parent)
+    : QAbstractEventDispatcher(*(new QEventDispatcherGlibPrivate), parent)
+{
+}
+
+QEventDispatcherGlib::QEventDispatcherGlib(GMainContext *mainContext, QObject *parent)
+    : QAbstractEventDispatcher(*(new QEventDispatcherGlibPrivate(mainContext)), parent)
+{ }
+
+QEventDispatcherGlib::~QEventDispatcherGlib()
+{
+    Q_D(QEventDispatcherGlib);
+
+    // destroy all timer sources
+    qDeleteAll(d->timerSource->timerList);
+    d->timerSource->timerList.~QTimerInfoList();
+    g_source_destroy(&d->timerSource->source);
+    g_source_unref(&d->timerSource->source);
+    d->timerSource = 0;
+    g_source_destroy(&d->idleTimerSource->source);
+    g_source_unref(&d->idleTimerSource->source);
+    d->idleTimerSource = 0;
+
+    // destroy socket notifier source
+    for (int i = 0; i < d->socketNotifierSource->pollfds.count(); ++i) {
+        GPollFDWithQSocketNotifier *p = d->socketNotifierSource->pollfds[i];
+        g_source_remove_poll(&d->socketNotifierSource->source, &p->pollfd);
+        delete p;
+    }
+    d->socketNotifierSource->pollfds.~QList<GPollFDWithQSocketNotifier *>();
+    g_source_destroy(&d->socketNotifierSource->source);
+    g_source_unref(&d->socketNotifierSource->source);
+    d->socketNotifierSource = 0;
+
+    // destroy post event source
+    g_source_destroy(&d->postEventSource->source);
+    g_source_unref(&d->postEventSource->source);
+    d->postEventSource = 0;
+
+    Q_ASSERT(d->mainContext != 0);
+#if GLIB_CHECK_VERSION (2, 22, 0)
+    g_main_context_pop_thread_default (d->mainContext);
+#endif
+    g_main_context_unref(d->mainContext);
+    d->mainContext = 0;
+}
+
+bool QEventDispatcherGlib::processEvents(QEventLoop::ProcessEventsFlags flags)
+{
+    Q_D(QEventDispatcherGlib);
+
+    const bool canWait = (flags & QEventLoop::WaitForMoreEvents);
+    if (canWait)
+        emit aboutToBlock();
+    else
+        emit awake();
+
+    // tell postEventSourcePrepare() and timerSource about any new flags
+    QEventLoop::ProcessEventsFlags savedFlags = d->timerSource->processEventsFlags;
+    d->timerSource->processEventsFlags = flags;
+
+    if (!(flags & QEventLoop::EventLoopExec)) {
+        // force timers to be sent at normal priority
+        d->timerSource->runWithIdlePriority = false;
+    }
+
+    bool result = g_main_context_iteration(d->mainContext, canWait);
+    while (!result && canWait)
+        result = g_main_context_iteration(d->mainContext, canWait);
+
+    d->timerSource->processEventsFlags = savedFlags;
+
+    if (canWait)
+        emit awake();
+
+    return result;
+}
+
+bool QEventDispatcherGlib::hasPendingEvents()
+{
+    Q_D(QEventDispatcherGlib);
+    return g_main_context_pending(d->mainContext);
+}
+
+void QEventDispatcherGlib::registerSocketNotifier(QSocketNotifier *notifier)
+{
+    Q_ASSERT(notifier);
+    int sockfd = notifier->socket();
+    int type = notifier->type();
+#ifndef QT_NO_DEBUG
+    if (sockfd < 0) {
+        qWarning("QSocketNotifier: Internal error");
+        return;
+    } else if (notifier->thread() != thread()
+               || thread() != QThread::currentThread()) {
+        qWarning("QSocketNotifier: socket notifiers cannot be enabled from another thread");
+        return;
+    }
+#endif
+
+    Q_D(QEventDispatcherGlib);
+
+
+    GPollFDWithQSocketNotifier *p = new GPollFDWithQSocketNotifier;
+    p->pollfd.fd = sockfd;
+    switch (type) {
+    case QSocketNotifier::Read:
+        p->pollfd.events = G_IO_IN | G_IO_HUP | G_IO_ERR;
+        break;
+    case QSocketNotifier::Write:
+        p->pollfd.events = G_IO_OUT | G_IO_ERR;
+        break;
+    case QSocketNotifier::Exception:
+        p->pollfd.events = G_IO_PRI | G_IO_ERR;
+        break;
+    }
+    p->socketNotifier = notifier;
+
+    d->socketNotifierSource->pollfds.append(p);
+
+    g_source_add_poll(&d->socketNotifierSource->source, &p->pollfd);
+}
+
+void QEventDispatcherGlib::unregisterSocketNotifier(QSocketNotifier *notifier)
+{
+    Q_ASSERT(notifier);
+#ifndef QT_NO_DEBUG
+    int sockfd = notifier->socket();
+    if (sockfd < 0) {
+        qWarning("QSocketNotifier: Internal error");
+        return;
+    } else if (notifier->thread() != thread()
+               || thread() != QThread::currentThread()) {
+        qWarning("QSocketNotifier: socket notifiers cannot be disabled from another thread");
+        return;
+    }
+#endif
+
+    Q_D(QEventDispatcherGlib);
+
+    for (int i = 0; i < d->socketNotifierSource->pollfds.count(); ++i) {
+        GPollFDWithQSocketNotifier *p = d->socketNotifierSource->pollfds.at(i);
+        if (p->socketNotifier == notifier) {
+            // found it
+            g_source_remove_poll(&d->socketNotifierSource->source, &p->pollfd);
+
+            d->socketNotifierSource->pollfds.removeAt(i);
+            delete p;
+
+            return;
+        }
+    }
+}
+
+void QEventDispatcherGlib::registerTimer(int timerId, int interval, QObject *object)
+{
+#ifndef QT_NO_DEBUG
+    if (timerId < 1 || interval < 0 || !object) {
+        qWarning("QEventDispatcherGlib::registerTimer: invalid arguments");
+        return;
+    } else if (object->thread() != thread() || thread() != QThread::currentThread()) {
+        qWarning("QObject::startTimer: timers cannot be started from another thread");
+        return;
+    }
+#endif
+
+    Q_D(QEventDispatcherGlib);
+    d->timerSource->timerList.registerTimer(timerId, interval, object);
+}
+
+bool QEventDispatcherGlib::unregisterTimer(int timerId)
+{
+#ifndef QT_NO_DEBUG
+    if (timerId < 1) {
+        qWarning("QEventDispatcherGlib::unregisterTimer: invalid argument");
+        return false;
+    } else if (thread() != QThread::currentThread()) {
+        qWarning("QObject::killTimer: timers cannot be stopped from another thread");
+        return false;
+    }
+#endif
+
+    Q_D(QEventDispatcherGlib);
+    return d->timerSource->timerList.unregisterTimer(timerId);
+}
+
+bool QEventDispatcherGlib::unregisterTimers(QObject *object)
+{
+#ifndef QT_NO_DEBUG
+    if (!object) {
+        qWarning("QEventDispatcherGlib::unregisterTimers: invalid argument");
+        return false;
+    } else if (object->thread() != thread() || thread() != QThread::currentThread()) {
+        qWarning("QObject::killTimers: timers cannot be stopped from another thread");
+        return false;
+    }
+#endif
+
+    Q_D(QEventDispatcherGlib);
+    return d->timerSource->timerList.unregisterTimers(object);
+}
+
+QList<QEventDispatcherGlib::TimerInfo> QEventDispatcherGlib::registeredTimers(QObject *object) const
+{
+    if (!object) {
+        qWarning("QEventDispatcherUNIX:registeredTimers: invalid argument");
+        return QList<TimerInfo>();
+    }
+
+    Q_D(const QEventDispatcherGlib);
+    return d->timerSource->timerList.registeredTimers(object);
+}
+
+void QEventDispatcherGlib::interrupt()
+{
+    wakeUp();
+}
+
+void QEventDispatcherGlib::wakeUp()
+{
+    Q_D(QEventDispatcherGlib);
+    d->postEventSource->serialNumber.ref();
+    g_main_context_wakeup(d->mainContext);
+}
+
+void QEventDispatcherGlib::flush()
+{
+}
+
+bool QEventDispatcherGlib::versionSupported()
+{
+#if !defined(GLIB_MAJOR_VERSION) || !defined(GLIB_MINOR_VERSION) || !defined(GLIB_MICRO_VERSION)
+    return false;
+#else
+    return ((GLIB_MAJOR_VERSION << 16) + (GLIB_MINOR_VERSION << 8) + GLIB_MICRO_VERSION) >= 0x020301;
+#endif
+}
+
+QEventDispatcherGlib::QEventDispatcherGlib(QEventDispatcherGlibPrivate &dd, QObject *parent)
+    : QAbstractEventDispatcher(dd, parent)
+{
+}
+
+QT_END_NAMESPACE
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_unix.cpp qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_unix.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/corelib/kernel/qeventdispatcher_unix.cpp	2015-05-07 14:14:48.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/corelib/kernel/qeventdispatcher_unix.cpp	2017-09-26 08:04:51.846751038 +0000
@@ -905,7 +905,15 @@
 
     // we are awake, broadcast it
     emit awake();
-    QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
+
+    QEventLoop::ProcessEventsFlags excludeAllFlags
+        = QEventLoop::ExcludeUserInputEvents
+        | QEventLoop::ExcludeSocketNotifiers
+        | QEventLoop::X11ExcludeTimers;
+    if ((flags & excludeAllFlags) == excludeAllFlags)
+        return false;
+    if(( flags & excludeAllFlags ) != excludeAllFlags )
+        QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
 
     int nevents = 0;
     const bool canWait = (d->threadData->canWaitLocked()
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/corelib/tools/qlocale_icu.cpp qt-everywhere-opensource-src-4.8.7/src/corelib/tools/qlocale_icu.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/corelib/tools/qlocale_icu.cpp	2015-05-07 14:14:48.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/corelib/tools/qlocale_icu.cpp	2017-09-26 08:07:20.526756100 +0000
@@ -43,6 +43,8 @@
 #include "qlibrary.h"
 #include "qdebug.h"
 
+#define UCHAR_TYPE unsigned short
+
 #include "unicode/uversion.h"
 #include "unicode/ucol.h"
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/dialogs/qprintdialog_unix.cpp qt-everywhere-opensource-src-4.8.7/src/gui/dialogs/qprintdialog_unix.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/dialogs/qprintdialog_unix.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/dialogs/qprintdialog_unix.cpp	2017-09-26 08:02:52.830080319 +0000
@@ -579,6 +579,32 @@
 void QPrintDialogPrivate::selectPrinter(QCUPSSupport *cups)
 {
     options.duplex->setEnabled(cups && cups->ppdOption("Duplex"));
+
+    if (cups) {
+        const ppd_option_t* duplex = cups->ppdOption("Duplex");
+        if (duplex) {
+            // copy default ppd duplex to qt dialog
+            if (qstrcmp(duplex->defchoice, "DuplexTumble") == 0)
+                options.duplexShort->setChecked(true);
+            else if (qstrcmp(duplex->defchoice, "DuplexNoTumble") == 0)
+                options.duplexLong->setChecked(true);
+            else
+                options.noDuplex->setChecked(true);
+        }
+
+        if (cups->currentPPD()) {
+            // set default color
+            if (cups->currentPPD()->color_device)
+                options.color->setChecked(true);
+            else
+                options.grayscale->setChecked(true);
+        }
+
+        // set collation
+        const ppd_option_t *collate = cups->ppdOption("Collate");
+        if (collate)
+            options.collate->setChecked(qstrcmp(collate->defchoice, "True")==0);
+    }
 }
 #endif
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/dialogs/qprintdialog_unix.cpp.orig qt-everywhere-opensource-src-4.8.7/src/gui/dialogs/qprintdialog_unix.cpp.orig
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/dialogs/qprintdialog_unix.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/dialogs/qprintdialog_unix.cpp.orig	2015-05-07 14:14:43.000000000 +0000
@@ -0,0 +1,1309 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 The Qt Company Ltd.
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see http://www.qt.io/terms-conditions. For further
+** information use the contact form at http://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** As a special exception, The Qt Company gives you certain additional
+** rights. These rights are described in The Qt Company LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qplatformdefs.h"
+
+#ifndef QT_NO_PRINTDIALOG
+
+#include "private/qabstractprintdialog_p.h"
+#include <QtGui/qmessagebox.h>
+#include "qprintdialog.h"
+#include "qfiledialog.h"
+#include <QtCore/qdir.h>
+#include <QtGui/qevent.h>
+#include <QtGui/qfilesystemmodel.h>
+#include <QtGui/qstyleditemdelegate.h>
+#include <QtGui/qprinter.h>
+
+#include <QtGui/qdialogbuttonbox.h>
+
+#include "qfscompleter_p.h"
+#include "ui_qprintpropertieswidget.h"
+#include "ui_qprintsettingsoutput.h"
+#include "ui_qprintwidget.h"
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+#  include <private/qcups_p.h>
+#  include <cups/cups.h>
+#  include <private/qpdf_p.h>
+#else
+#  include <QtCore/qlibrary.h>
+#endif
+
+#include <private/qprinterinfo_unix_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QOptionTreeItem;
+class QPPDOptionsModel;
+
+class QPrintPropertiesDialog : public QDialog
+{
+    Q_OBJECT
+public:
+    QPrintPropertiesDialog(QAbstractPrintDialog *parent = 0);
+    ~QPrintPropertiesDialog();
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    void setCups(QCUPSSupport *cups) { m_cups = cups; }
+    void addItemToOptions(QOptionTreeItem *parent, QList<const ppd_option_t*>& options, QList<const char*>& markedOptions) const;
+#endif
+
+    void selectPrinter();
+    void selectPdfPsPrinter(const QPrinter *p);
+
+    /// copy printer properties to the widget
+    void applyPrinterProperties(QPrinter *p);
+    void setupPrinter() const;
+
+protected:
+    void showEvent(QShowEvent* event);
+
+private:
+    Ui::QPrintPropertiesWidget widget;
+    QDialogButtonBox *m_buttons;
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    QCUPSSupport *m_cups;
+    QPPDOptionsModel *m_cupsOptionsModel;
+#endif
+};
+
+class QPrintDialogPrivate : public QAbstractPrintDialogPrivate
+{
+    Q_DECLARE_PUBLIC(QPrintDialog)
+    Q_DECLARE_TR_FUNCTIONS(QPrintDialog)
+public:
+    QPrintDialogPrivate();
+    ~QPrintDialogPrivate();
+
+    void init();
+    /// copy printer properties to the widget
+    void applyPrinterProperties(QPrinter *p);
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    void selectPrinter(QCUPSSupport *cups);
+#endif
+
+    void _q_chbPrintLastFirstToggled(bool);
+#ifndef QT_NO_MESSAGEBOX
+    void _q_checkFields();
+#endif
+    void _q_collapseOrExpandDialog();
+
+    void setupPrinter();
+    void updateWidgets();
+
+    virtual void setTabs(const QList<QWidget*> &tabs);
+
+    Ui::QPrintSettingsOutput options;
+    QUnixPrintWidget *top;
+    QWidget *bottom;
+    QDialogButtonBox *buttons;
+    QPushButton *collapseButton;
+};
+
+#if defined (Q_OS_UNIX)
+class QUnixPrintWidgetPrivate
+{
+public:
+    QUnixPrintWidgetPrivate(QUnixPrintWidget *q);
+    ~QUnixPrintWidgetPrivate();
+
+    /// copy printer properties to the widget
+    void applyPrinterProperties(QPrinter *p);
+    bool checkFields();
+    void setupPrinter();
+    void setOptionsPane(QPrintDialogPrivate *pane);
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    void setCupsProperties();
+#endif
+
+// slots
+    void _q_printerChanged(int index);
+    void _q_btnPropertiesClicked();
+    void _q_btnBrowseClicked();
+
+    QUnixPrintWidget * const parent;
+    QPrintPropertiesDialog *propertiesDialog;
+    Ui::QPrintWidget widget;
+    QAbstractPrintDialog * q;
+    QPrinter *printer;
+    QList<QPrinterDescription> lprPrinters;
+    void updateWidget();
+
+private:
+    QPrintDialogPrivate *optionsPane;
+    bool filePrintersAdded;
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    QCUPSSupport* cups;
+    int cupsPrinterCount;
+    const cups_dest_t* cupsPrinters;
+    const ppd_file_t* cupsPPD;
+#endif
+};
+#endif
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+class QOptionTreeItem
+{
+public:
+    enum ItemType { Root, Group, Option, Choice };
+
+    QOptionTreeItem(ItemType t, int i, const void* p, const char* desc, QOptionTreeItem* pi)
+        : type(t),
+          index(i),
+          ptr(p),
+          description(desc),
+          selected(-1),
+          selDescription(0),
+          parentItem(pi) {}
+
+    ~QOptionTreeItem() {
+        while (!childItems.isEmpty())
+            delete childItems.takeFirst();
+    }
+
+    ItemType type;
+    int index;
+    const void* ptr;
+    const char* description;
+    int selected;
+    const char* selDescription;
+    QOptionTreeItem* parentItem;
+    QList<QOptionTreeItem*> childItems;
+};
+
+class QPPDOptionsModel : public QAbstractItemModel
+{
+    friend class QPPDOptionsEditor;
+public:
+    QPPDOptionsModel(QCUPSSupport *cups, QObject *parent = 0);
+    ~QPPDOptionsModel();
+
+    int columnCount(const QModelIndex& parent = QModelIndex()) const;
+    int rowCount(const QModelIndex& parent = QModelIndex()) const;
+    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const;
+    QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const;
+    QModelIndex parent(const QModelIndex& index) const;
+    Qt::ItemFlags flags(const QModelIndex& index) const;
+    QVariant headerData ( int section, Qt::Orientation orientation, int role = Qt::DisplayRole ) const;
+
+    QOptionTreeItem* rootItem;
+    QCUPSSupport *cups;
+    const ppd_file_t* ppd;
+    void parseItems();
+    void parseGroups(QOptionTreeItem* parent);
+    void parseOptions(QOptionTreeItem* parent);
+    void parseChoices(QOptionTreeItem* parent);
+};
+
+class QPPDOptionsEditor : public QStyledItemDelegate
+{
+    Q_OBJECT
+public:
+    QPPDOptionsEditor(QObject* parent = 0) : QStyledItemDelegate(parent) {}
+    ~QPPDOptionsEditor() {}
+
+    QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem& option, const QModelIndex& index) const;
+    void setEditorData(QWidget* editor, const QModelIndex& index) const;
+    void setModelData( QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const;
+
+private slots:
+    void cbChanged(int index);
+
+};
+
+#endif
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+QPrintPropertiesDialog::QPrintPropertiesDialog(QAbstractPrintDialog *parent)
+    : QDialog(parent)
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    , m_cups(0), m_cupsOptionsModel(0)
+#endif
+{
+    QVBoxLayout *lay = new QVBoxLayout(this);
+    this->setLayout(lay);
+    QWidget *content = new QWidget(this);
+    widget.setupUi(content);
+    m_buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, Qt::Horizontal, this);
+    lay->addWidget(content);
+    lay->addWidget(m_buttons);
+
+    connect(m_buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()), this, SLOT(accept()));
+    connect(m_buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()), this, SLOT(reject()));
+}
+
+QPrintPropertiesDialog::~QPrintPropertiesDialog()
+{
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    delete m_cupsOptionsModel;
+#else
+    delete widget.cupsPropertiesPage;
+#endif
+}
+
+void QPrintPropertiesDialog::applyPrinterProperties(QPrinter *p)
+{
+    widget.pageSetup->setPrinter(p);
+}
+
+void QPrintPropertiesDialog::setupPrinter() const
+{
+    widget.pageSetup->setupPrinter();
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    QPPDOptionsModel* model = static_cast<QPPDOptionsModel*>(widget.treeView->model());
+    if (model) {
+        QOptionTreeItem* rootItem = model->rootItem;
+        QList<const ppd_option_t*> options;
+        QList<const char*> markedOptions;
+
+        addItemToOptions(rootItem, options, markedOptions);
+        model->cups->saveOptions(options, markedOptions);
+    }
+#endif
+}
+
+void QPrintPropertiesDialog::selectPrinter()
+{
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    widget.pageSetup->selectPrinter(m_cups);
+    widget.treeView->setModel(0);
+    if (m_cups && QCUPSSupport::isAvailable()) {
+
+        if (m_cupsOptionsModel == 0) {
+            m_cupsOptionsModel = new QPPDOptionsModel(m_cups);
+
+            widget.treeView->setItemDelegate(new QPPDOptionsEditor(this));
+        } else {
+            // update the model
+            m_cupsOptionsModel->parseItems();
+        }
+
+        if (m_cupsOptionsModel->rowCount() > 0) {
+            widget.treeView->setModel(m_cupsOptionsModel);
+
+            for (int i = 0; i < m_cupsOptionsModel->rowCount(); ++i)
+                widget.treeView->expand(m_cupsOptionsModel->index(i,0));
+
+            widget.tabs->setTabEnabled(1, true); // enable the advanced tab
+        } else {
+            widget.tabs->setTabEnabled(1, false);
+        }
+
+    } else
+#endif
+    {
+        widget.cupsPropertiesPage->setEnabled(false);
+        widget.pageSetup->selectPrinter(0);
+    }
+}
+
+void QPrintPropertiesDialog::selectPdfPsPrinter(const QPrinter *p)
+{
+    widget.treeView->setModel(0);
+    widget.pageSetup->selectPdfPsPrinter(p);
+    widget.tabs->setTabEnabled(1, false); // disable the advanced tab
+}
+
+void QPrintPropertiesDialog::showEvent(QShowEvent* event)
+{
+    widget.treeView->resizeColumnToContents(0);
+    event->accept();
+}
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+void QPrintPropertiesDialog::addItemToOptions(QOptionTreeItem *parent, QList<const ppd_option_t*>& options, QList<const char*>& markedOptions) const
+{
+    for (int i = 0; i < parent->childItems.count(); ++i) {
+        QOptionTreeItem *itm = parent->childItems.at(i);
+        if (itm->type == QOptionTreeItem::Option) {
+            const ppd_option_t* opt = reinterpret_cast<const ppd_option_t*>(itm->ptr);
+            options << opt;
+            if (qstrcmp(opt->defchoice, opt->choices[itm->selected].choice) != 0) {
+                markedOptions << opt->keyword << opt->choices[itm->selected].choice;
+            }
+        } else {
+            addItemToOptions(itm, options, markedOptions);
+        }
+    }
+}
+#endif
+
+QPrintDialogPrivate::QPrintDialogPrivate()
+    : top(0), bottom(0), buttons(0), collapseButton(0)
+{
+}
+
+QPrintDialogPrivate::~QPrintDialogPrivate()
+{
+}
+
+void QPrintDialogPrivate::init()
+{
+    Q_Q(QPrintDialog);
+
+    top = new QUnixPrintWidget(0, q);
+    bottom = new QWidget(q);
+    options.setupUi(bottom);
+    options.color->setIconSize(QSize(32, 32));
+    options.color->setIcon(QIcon(QLatin1String(":/trolltech/dialogs/qprintdialog/images/status-color.png")));
+    options.grayscale->setIconSize(QSize(32, 32));
+    options.grayscale->setIcon(QIcon(QLatin1String(":/trolltech/dialogs/qprintdialog/images/status-gray-scale.png")));
+    top->d->setOptionsPane(this);
+
+    buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, Qt::Horizontal, q);
+    collapseButton = new QPushButton(QPrintDialog::tr("&Options >>"), buttons);
+    buttons->addButton(collapseButton, QDialogButtonBox::ResetRole);
+    bottom->setVisible(false);
+
+    QPushButton *printButton = buttons->button(QDialogButtonBox::Ok);
+    printButton->setText(QPrintDialog::tr("&Print"));
+    printButton->setDefault(true);
+
+    QVBoxLayout *lay = new QVBoxLayout(q);
+    q->setLayout(lay);
+    lay->addWidget(top);
+    lay->addWidget(bottom);
+    lay->addWidget(buttons);
+
+    QPrinter* p = q->printer();
+
+    applyPrinterProperties(p);
+
+#ifdef QT_NO_MESSAGEBOX
+    QObject::connect(buttons, SIGNAL(accepted()), q, SLOT(accept()));
+#else
+    QObject::connect(buttons, SIGNAL(accepted()), q, SLOT(_q_checkFields()));
+#endif
+    QObject::connect(buttons, SIGNAL(rejected()), q, SLOT(reject()));
+
+    QObject::connect(options.reverse, SIGNAL(toggled(bool)),
+                     q, SLOT(_q_chbPrintLastFirstToggled(bool)));
+
+    QObject::connect(collapseButton, SIGNAL(released()), q, SLOT(_q_collapseOrExpandDialog()));
+}
+
+void QPrintDialogPrivate::applyPrinterProperties(QPrinter *p)
+{
+    if (p->colorMode() == QPrinter::Color)
+        options.color->setChecked(true);
+    else
+        options.grayscale->setChecked(true);
+
+    switch(p->duplex()) {
+    case QPrinter::DuplexNone:
+        options.noDuplex->setChecked(true); break;
+    case QPrinter::DuplexLongSide:
+    case QPrinter::DuplexAuto:
+        options.duplexLong->setChecked(true); break;
+    case QPrinter::DuplexShortSide:
+        options.duplexShort->setChecked(true); break;
+    }
+    options.copies->setValue(p->copyCount());
+    options.collate->setChecked(p->collateCopies());
+    options.reverse->setChecked(p->pageOrder() == QPrinter::LastPageFirst);
+    top->d->applyPrinterProperties(p);
+}
+
+void QPrintDialogPrivate::_q_chbPrintLastFirstToggled(bool checked)
+{
+    Q_Q(QPrintDialog);
+    if (checked)
+        q->printer()->setPageOrder(QPrinter::LastPageFirst);
+    else
+        q->printer()->setPageOrder(QPrinter::FirstPageFirst);
+}
+
+void QPrintDialogPrivate::_q_collapseOrExpandDialog()
+{
+    int collapseHeight = 0;
+    Q_Q(QPrintDialog);
+    QWidget *widgetToHide = bottom;
+    if (widgetToHide->isVisible()) {
+        collapseButton->setText(QPrintDialog::tr("&Options >>"));
+        collapseHeight = widgetToHide->y() + widgetToHide->height() - (top->y() + top->height());
+    }
+    else
+        collapseButton->setText(QPrintDialog::tr("&Options <<"));
+    widgetToHide->setVisible(! widgetToHide->isVisible());
+    if (! widgetToHide->isVisible()) { // make it shrink
+        q->layout()->activate();
+        q->resize( QSize(q->width(), q->height() - collapseHeight) );
+    }
+}
+
+#ifndef QT_NO_MESSAGEBOX
+void QPrintDialogPrivate::_q_checkFields()
+{
+    Q_Q(QPrintDialog);
+    if (top->d->checkFields())
+        q->accept();
+}
+#endif // QT_NO_MESSAGEBOX
+
+void QPrintDialogPrivate::setupPrinter()
+{
+    Q_Q(QPrintDialog);
+    QPrinter* p = q->printer();
+
+    if (options.duplex->isEnabled()) {
+        if (options.noDuplex->isChecked())
+            p->setDuplex(QPrinter::DuplexNone);
+        else if (options.duplexLong->isChecked())
+            p->setDuplex(QPrinter::DuplexLongSide);
+        else
+            p->setDuplex(QPrinter::DuplexShortSide);
+    }
+
+    p->setColorMode( options.color->isChecked() ? QPrinter::Color : QPrinter::GrayScale );
+
+    // print range
+    if (options.printAll->isChecked()) {
+        p->setPrintRange(QPrinter::AllPages);
+        p->setFromTo(0,0);
+    } else if (options.printSelection->isChecked()) {
+        p->setPrintRange(QPrinter::Selection);
+        p->setFromTo(0,0);
+    } else if (options.printCurrentPage->isChecked()) {
+        p->setPrintRange(QPrinter::CurrentPage);
+        p->setFromTo(0,0);
+    } else if (options.printRange->isChecked()) {
+        p->setPrintRange(QPrinter::PageRange);
+        p->setFromTo(options.from->value(), qMax(options.from->value(), options.to->value()));
+    }
+
+    // copies
+    p->setCopyCount(options.copies->value());
+    p->setCollateCopies(options.collate->isChecked());
+
+    top->d->setupPrinter();
+}
+
+void QPrintDialogPrivate::updateWidgets()
+{
+    Q_Q(QPrintDialog);
+    options.gbPrintRange->setVisible(q->isOptionEnabled(QPrintDialog::PrintPageRange) ||
+                                     q->isOptionEnabled(QPrintDialog::PrintSelection) ||
+                                     q->isOptionEnabled(QPrintDialog::PrintCurrentPage));
+
+    options.printRange->setEnabled(q->isOptionEnabled(QPrintDialog::PrintPageRange));
+    options.printSelection->setVisible(q->isOptionEnabled(QPrintDialog::PrintSelection));
+    options.printCurrentPage->setVisible(q->isOptionEnabled(QPrintDialog::PrintCurrentPage));
+    options.collate->setVisible(q->isOptionEnabled(QPrintDialog::PrintCollateCopies));
+
+    switch (q->printRange()) {
+    case QPrintDialog::AllPages:
+        options.printAll->setChecked(true);
+        break;
+    case QPrintDialog::Selection:
+        options.printSelection->setChecked(true);
+        break;
+    case QPrintDialog::PageRange:
+        options.printRange->setChecked(true);
+        break;
+    case QPrintDialog::CurrentPage:
+        if (q->isOptionEnabled(QPrintDialog::PrintCurrentPage))
+            options.printCurrentPage->setChecked(true);
+        break;
+    default:
+        break;
+    }
+    const int minPage = qMax(1, qMin(q->minPage() , q->maxPage()));
+    const int maxPage = qMax(1, q->maxPage() == INT_MAX ? 9999 : q->maxPage());
+
+    options.from->setMinimum(minPage);
+    options.to->setMinimum(minPage);
+    options.from->setMaximum(maxPage);
+    options.to->setMaximum(maxPage);
+
+    options.from->setValue(q->fromPage());
+    options.to->setValue(q->toPage());
+    top->d->updateWidget();
+}
+
+void QPrintDialogPrivate::setTabs(const QList<QWidget*> &tabWidgets)
+{
+    while(options.tabs->count() > 2)
+        delete options.tabs->widget(2);
+
+    QList<QWidget*>::ConstIterator iter = tabWidgets.begin();
+    while(iter != tabWidgets.constEnd()) {
+        QWidget *tab = *iter;
+        options.tabs->addTab(tab, tab->windowTitle());
+        ++iter;
+    }
+}
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+void QPrintDialogPrivate::selectPrinter(QCUPSSupport *cups)
+{
+    options.duplex->setEnabled(cups && cups->ppdOption("Duplex"));
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+QPrintDialog::QPrintDialog(QPrinter *printer, QWidget *parent)
+    : QAbstractPrintDialog(*(new QPrintDialogPrivate), printer, parent)
+{
+    Q_D(QPrintDialog);
+    d->init();
+}
+
+/*!
+    Constructs a print dialog with the given \a parent.
+*/
+QPrintDialog::QPrintDialog(QWidget *parent)
+    : QAbstractPrintDialog(*(new QPrintDialogPrivate), 0, parent)
+{
+    Q_D(QPrintDialog);
+    d->init();
+}
+
+QPrintDialog::~QPrintDialog()
+{
+}
+
+void QPrintDialog::setVisible(bool visible)
+{
+    Q_D(QPrintDialog);
+
+    if (visible)
+        d->updateWidgets();
+
+    QAbstractPrintDialog::setVisible(visible);
+}
+
+int QPrintDialog::exec()
+{
+    return QDialog::exec();
+}
+
+void QPrintDialog::accept()
+{
+    Q_D(QPrintDialog);
+    d->setupPrinter();
+    QDialog::accept();
+}
+
+#ifdef QT3_SUPPORT
+QPrinter *QPrintDialog::printer() const
+{
+    Q_D(const QPrintDialog);
+    return d->printer;
+}
+
+void QPrintDialog::setPrinter(QPrinter *printer, bool pickupSettings)
+{
+    if (!printer)
+        return;
+
+    Q_D(QPrintDialog);
+    d->printer = printer;
+
+    if (pickupSettings)
+        d->applyPrinterProperties(printer);
+}
+
+void QPrintDialog::addButton(QPushButton *button)
+{
+    Q_D(QPrintDialog);
+    d->buttons->addButton(button, QDialogButtonBox::HelpRole);
+}
+#endif // QT3_SUPPORT
+
+#if defined (Q_OS_UNIX)
+
+/*! \internal
+*/
+QUnixPrintWidgetPrivate::QUnixPrintWidgetPrivate(QUnixPrintWidget *p)
+    : parent(p), propertiesDialog(0), printer(0), optionsPane(0), filePrintersAdded(false)
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    , cups(0), cupsPrinterCount(0), cupsPrinters(0), cupsPPD(0)
+#endif
+{
+    q = 0;
+    if (parent)
+        q = qobject_cast<QAbstractPrintDialog*> (parent->parent());
+
+    widget.setupUi(parent);
+
+    int currentPrinterIndex = 0;
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    cups = new QCUPSSupport;
+    if (QCUPSSupport::isAvailable()) {
+        cupsPPD = cups->currentPPD();
+        cupsPrinterCount = cups->availablePrintersCount();
+        cupsPrinters = cups->availablePrinters();
+
+        for (int i = 0; i < cupsPrinterCount; ++i) {
+            QString printerName(QString::fromLocal8Bit(cupsPrinters[i].name));
+            if (cupsPrinters[i].instance)
+                printerName += QLatin1Char('/') + QString::fromLocal8Bit(cupsPrinters[i].instance);
+
+            widget.printers->addItem(printerName);
+            if (cupsPrinters[i].is_default)
+                widget.printers->setCurrentIndex(i);
+        }
+        // the model depends on valid ppd. so before enabling the
+        // properties button we make sure the ppd is in fact valid.
+        if (cupsPrinterCount && cups->currentPPD()) {
+            widget.properties->setEnabled(true);
+        }
+        currentPrinterIndex = cups->currentPrinterIndex();
+    } else {
+#endif
+        currentPrinterIndex = qt_getLprPrinters(lprPrinters);
+        // populating printer combo
+        QList<QPrinterDescription>::const_iterator i = lprPrinters.constBegin();
+        for(; i != lprPrinters.constEnd(); ++i)
+            widget.printers->addItem((*i).name);
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    }
+#endif
+
+#if !defined(QT_NO_FILESYSTEMMODEL) && !defined(QT_NO_COMPLETER)
+    QFileSystemModel *fsm = new QFileSystemModel(widget.filename);
+    fsm->setRootPath(QDir::homePath());
+    widget.filename->setCompleter(new QCompleter(fsm, widget.filename));
+#endif
+    _q_printerChanged(currentPrinterIndex);
+
+    QObject::connect(widget.printers, SIGNAL(currentIndexChanged(int)),
+                     parent, SLOT(_q_printerChanged(int)));
+    QObject::connect(widget.fileBrowser, SIGNAL(clicked()), parent, SLOT(_q_btnBrowseClicked()));
+    QObject::connect(widget.properties, SIGNAL(clicked()), parent, SLOT(_q_btnPropertiesClicked()));
+
+    // disable features that QPrinter does not yet support.
+    widget.preview->setVisible(false);
+}
+
+void QUnixPrintWidgetPrivate::updateWidget()
+{
+    const bool printToFile = q == 0 || q->isOptionEnabled(QPrintDialog::PrintToFile);
+    if (printToFile && !filePrintersAdded) {
+        if (widget.printers->count())
+            widget.printers->insertSeparator(widget.printers->count());
+        widget.printers->addItem(QPrintDialog::tr("Print to File (PDF)"));
+        widget.printers->addItem(QPrintDialog::tr("Print to File (Postscript)"));
+        filePrintersAdded = true;
+    }
+    if (!printToFile && filePrintersAdded) {
+        widget.printers->removeItem(widget.printers->count()-1);
+        widget.printers->removeItem(widget.printers->count()-1);
+        if (widget.printers->count())
+            widget.printers->removeItem(widget.printers->count()-1); // remove separator
+        filePrintersAdded = false;
+    }
+    if (printer && filePrintersAdded && (printer->outputFormat() != QPrinter::NativeFormat
+                                         || printer->printerName().isEmpty()))
+    {
+        if (printer->outputFormat() == QPrinter::PdfFormat)
+            widget.printers->setCurrentIndex(widget.printers->count() - 2);
+        else if (printer->outputFormat() == QPrinter::PostScriptFormat)
+            widget.printers->setCurrentIndex(widget.printers->count() - 1);
+        widget.filename->setEnabled(true);
+        widget.lOutput->setEnabled(true);
+    }
+
+    widget.filename->setVisible(printToFile);
+    widget.lOutput->setVisible(printToFile);
+    widget.fileBrowser->setVisible(printToFile);
+
+    widget.properties->setVisible(q->isOptionEnabled(QAbstractPrintDialog::PrintShowPageSize));
+}
+
+QUnixPrintWidgetPrivate::~QUnixPrintWidgetPrivate()
+{
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    delete cups;
+#endif
+}
+
+void QUnixPrintWidgetPrivate::_q_printerChanged(int index)
+{
+    if (index < 0)
+        return;
+    const int printerCount = widget.printers->count();
+    widget.filename->setEnabled(false);
+    widget.lOutput->setEnabled(false);
+
+    if (filePrintersAdded) {
+        Q_ASSERT(index != printerCount - 3); // separator
+        if (index > printerCount - 3) { // PDF or postscript
+            bool pdfPrinter = (index == printerCount - 2);
+            widget.location->setText(QPrintDialog::tr("Local file"));
+            widget.type->setText(QPrintDialog::tr("Write %1 file").arg(pdfPrinter ? QString::fromLatin1("PDF")
+                                                                       : QString::fromLatin1("PostScript")));
+            widget.properties->setEnabled(true);
+            widget.filename->setEnabled(true);
+            QString filename = widget.filename->text();
+            QString suffix = QFileInfo(filename).suffix();
+            if (pdfPrinter && suffix == QLatin1String("ps"))
+                filename = filename.replace(QLatin1String(".ps"), QLatin1String(".pdf"));
+            if (!pdfPrinter && suffix == QLatin1String("pdf"))
+                filename = filename.replace(QLatin1String(".pdf"), QLatin1String(".ps"));
+            widget.filename->setText(filename);
+            widget.lOutput->setEnabled(true);
+            if (propertiesDialog)
+                propertiesDialog->selectPdfPsPrinter(printer);
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+            if (optionsPane)
+                optionsPane->selectPrinter(0);
+#endif
+            return;
+        }
+    }
+
+    widget.location->setText(QString());
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    if (QCUPSSupport::isAvailable()) {
+        cups->setCurrentPrinter(index);
+
+        const cups_option_t *opt = cups->printerOption(QString::fromLatin1("printer-location"));
+        QString location;
+        if (opt)
+            location = QString::fromLocal8Bit(opt->value);
+        widget.location->setText(location);
+
+        cupsPPD = cups->currentPPD();
+        // set printer type line
+        QString type;
+        if (cupsPPD)
+            type = QString::fromLocal8Bit(cupsPPD->manufacturer) + QLatin1String(" - ") + QString::fromLocal8Bit(cupsPPD->modelname);
+        widget.type->setText(type);
+        if (propertiesDialog)
+            propertiesDialog->selectPrinter();
+        if (optionsPane)
+            optionsPane->selectPrinter(cups);
+    } else {
+        if (optionsPane)
+            optionsPane->selectPrinter(0);
+#endif
+        if (lprPrinters.count() > 0) {
+            QString type = lprPrinters.at(index).name + QLatin1Char('@') + lprPrinters.at(index).host;
+            if (!lprPrinters.at(index).comment.isEmpty())
+            type += QLatin1String(", ") + lprPrinters.at(index).comment;
+            widget.type->setText(type);
+            if (propertiesDialog)
+                propertiesDialog->selectPrinter();
+        }
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    }
+#endif
+}
+
+void QUnixPrintWidgetPrivate::setOptionsPane(QPrintDialogPrivate *pane)
+{
+    optionsPane = pane;
+    if (optionsPane)
+        _q_printerChanged(widget.printers->currentIndex());
+}
+
+void QUnixPrintWidgetPrivate::_q_btnBrowseClicked()
+{
+    QString filename = widget.filename->text();
+#ifndef QT_NO_FILEDIALOG
+    filename = QFileDialog::getSaveFileName(parent, QPrintDialog::tr("Print To File ..."), filename,
+                                            QString(), 0, QFileDialog::DontConfirmOverwrite);
+#else
+    filename.clear();
+#endif
+    if (!filename.isEmpty()) {
+        widget.filename->setText(filename);
+        if (filename.endsWith(QString::fromLatin1(".ps"), Qt::CaseInsensitive))
+            widget.printers->setCurrentIndex(widget.printers->count() - 1); // the postscript one
+        else if (filename.endsWith(QString::fromLatin1(".pdf"), Qt::CaseInsensitive))
+            widget.printers->setCurrentIndex(widget.printers->count() - 2); // the pdf one
+        else if (widget.printers->currentIndex() != widget.printers->count() - 1) // if ps is not selected, pdf is default
+            widget.printers->setCurrentIndex(widget.printers->count() - 2); // the pdf one
+    }
+}
+
+void QUnixPrintWidgetPrivate::applyPrinterProperties(QPrinter *p)
+{
+    if (p == 0)
+        return;
+    printer = p;
+    if (p->outputFileName().isEmpty()) {
+        QString home = QString::fromLocal8Bit(qgetenv("HOME").constData());
+        QString cur = QDir::currentPath();
+        if (home.at(home.length()-1) != QLatin1Char('/'))
+            home += QLatin1Char('/');
+        if (cur.at(cur.length()-1) != QLatin1Char('/'))
+            cur += QLatin1Char('/');
+        if (cur.left(home.length()) != home)
+            cur = home;
+#ifdef Q_WS_X11
+        if (p->docName().isEmpty()) {
+            if (p->outputFormat() == QPrinter::PostScriptFormat)
+                cur += QLatin1String("print.ps");
+            else
+                cur += QLatin1String("print.pdf");
+        } else {
+            QRegExp re(QString::fromLatin1("(.*)\\.\\S+"));
+            if (re.exactMatch(p->docName()))
+                cur += re.cap(1);
+            else
+                cur += p->docName();
+            if (p->outputFormat() == QPrinter::PostScriptFormat)
+                cur += QLatin1String(".ps");
+            else
+                cur += QLatin1String(".pdf");
+        }
+#endif
+        widget.filename->setText(cur);
+    }
+    else
+        widget.filename->setText( p->outputFileName() );
+    QString printer = p->printerName();
+    if (!printer.isEmpty()) {
+        for (int i = 0; i < widget.printers->count(); ++i) {
+            if (widget.printers->itemText(i) == printer) {
+                widget.printers->setCurrentIndex(i);
+                break;
+            }
+        }
+    }
+    // PDF and PS printers are not added to the dialog yet, we'll handle those cases in QUnixPrintWidgetPrivate::updateWidget
+
+    if (propertiesDialog)
+        propertiesDialog->applyPrinterProperties(p);
+}
+
+#ifndef QT_NO_MESSAGEBOX
+bool QUnixPrintWidgetPrivate::checkFields()
+{
+    if (widget.filename->isEnabled()) {
+        QString file = widget.filename->text();
+        QFile f(file);
+        QFileInfo fi(f);
+        bool exists = fi.exists();
+        bool opened = false;
+        if (exists && fi.isDir()) {
+            QMessageBox::warning(q, q->windowTitle(),
+                            QPrintDialog::tr("%1 is a directory.\nPlease choose a different file name.").arg(file));
+            return false;
+        } else if ((exists && !fi.isWritable()) || !(opened = f.open(QFile::Append))) {
+            QMessageBox::warning(q, q->windowTitle(),
+                            QPrintDialog::tr("File %1 is not writable.\nPlease choose a different file name.").arg(file));
+            return false;
+        } else if (exists) {
+            int ret = QMessageBox::question(q, q->windowTitle(),
+                                            QPrintDialog::tr("%1 already exists.\nDo you want to overwrite it?").arg(file),
+                                            QMessageBox::Yes|QMessageBox::No, QMessageBox::No);
+            if (ret == QMessageBox::No)
+                return false;
+        }
+        if (opened) {
+            f.close();
+            if (!exists)
+                f.remove();
+        }
+    }
+
+    // Every test passed. Accept the dialog.
+    return true;
+}
+#endif // QT_NO_MESSAGEBOX
+
+void QUnixPrintWidgetPrivate::_q_btnPropertiesClicked()
+{
+    if (!propertiesDialog) {
+        propertiesDialog = new QPrintPropertiesDialog(q);
+        propertiesDialog->setResult(QDialog::Rejected);
+    }
+
+    if (propertiesDialog->result() == QDialog::Rejected) {
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+        propertiesDialog->setCups(cups);
+#endif
+        propertiesDialog->applyPrinterProperties(q->printer());
+
+        if (q->isOptionEnabled(QPrintDialog::PrintToFile)
+            && (widget.printers->currentIndex() > widget.printers->count() - 3)) // PDF or postscript
+            propertiesDialog->selectPdfPsPrinter(q->printer());
+        else
+            propertiesDialog->selectPrinter();
+    }
+    propertiesDialog->exec();
+}
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+void QUnixPrintWidgetPrivate::setCupsProperties()
+{
+    if (cups && QCUPSSupport::isAvailable() && cups->pageSizes()) {
+        QPrintEngine *engine = printer->printEngine();
+        const ppd_option_t* pageSizes = cups->pageSizes();
+        QByteArray cupsPageSize;
+        for (int i = 0; i < pageSizes->num_choices; ++i) {
+            if (static_cast<int>(pageSizes->choices[i].marked) == 1)
+                cupsPageSize = pageSizes->choices[i].choice;
+        }
+        engine->setProperty(PPK_CupsStringPageSize, QString::fromLatin1(cupsPageSize));
+        engine->setProperty(PPK_CupsOptions, cups->options());
+
+        QRect pageRect = cups->pageRect(cupsPageSize);
+        engine->setProperty(PPK_CupsPageRect, pageRect);
+
+        QRect paperRect = cups->paperRect(cupsPageSize);
+        engine->setProperty(PPK_CupsPaperRect, paperRect);
+
+        for (int ps = 0; ps < QPrinter::NPaperSize; ++ps) {
+            QPdf::PaperSize size = QPdf::paperSize(QPrinter::PaperSize(ps));
+            if (size.width == paperRect.width() && size.height == paperRect.height())
+                printer->setPaperSize(static_cast<QPrinter::PaperSize>(ps));
+        }
+    }
+}
+#endif
+
+void QUnixPrintWidgetPrivate::setupPrinter()
+{
+    const int printerCount = widget.printers->count();
+    const int index = widget.printers->currentIndex();
+
+    if (filePrintersAdded && index > printerCount - 3) { // PDF or postscript
+        printer->setPrinterName(QString());
+        Q_ASSERT(index != printerCount - 3); // separator
+        if (index == printerCount - 2)
+            printer->setOutputFormat(QPrinter::PdfFormat);
+        else
+            printer->setOutputFormat(QPrinter::PostScriptFormat);
+        QString path = widget.filename->text();
+        if (QDir::isRelativePath(path))
+            path = QDir::homePath() + QDir::separator() + path;
+        printer->setOutputFileName(path);
+    }
+    else {
+        printer->setPrinterName(widget.printers->currentText());
+        printer->setOutputFileName(QString());
+    }
+
+    if (propertiesDialog && propertiesDialog->result() == QDialog::Accepted)
+        propertiesDialog->setupPrinter();
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    if (!propertiesDialog)
+        setCupsProperties();
+#endif
+}
+
+
+/*! \internal
+*/
+QUnixPrintWidget::QUnixPrintWidget(QPrinter *printer, QWidget *parent)
+    : QWidget(parent), d(new QUnixPrintWidgetPrivate(this))
+{
+    d->applyPrinterProperties(printer);
+}
+
+/*! \internal
+*/
+QUnixPrintWidget::~QUnixPrintWidget()
+{
+    delete d;
+}
+
+/*! \internal
+
+    Updates the printer with the states held in the QUnixPrintWidget.
+*/
+void QUnixPrintWidget::updatePrinter()
+{
+    d->setupPrinter();
+}
+
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+
+QPPDOptionsModel::QPPDOptionsModel(QCUPSSupport *c, QObject *parent)
+    : QAbstractItemModel(parent), rootItem(0), cups(c), ppd(c->currentPPD())
+{
+    parseItems();
+}
+
+QPPDOptionsModel::~QPPDOptionsModel()
+{
+}
+
+int QPPDOptionsModel::columnCount(const QModelIndex&) const
+{
+    return 2;
+}
+
+int QPPDOptionsModel::rowCount(const QModelIndex& parent) const
+{
+    QOptionTreeItem* itm;
+    if (!parent.isValid())
+        itm = rootItem;
+    else
+        itm = reinterpret_cast<QOptionTreeItem*>(parent.internalPointer());
+
+    if (itm->type == QOptionTreeItem::Option)
+        return 0;
+
+    return itm->childItems.count();
+}
+
+QVariant QPPDOptionsModel::data(const QModelIndex& index, int role) const
+{
+    switch(role) {
+        case Qt::FontRole: {
+            QOptionTreeItem* itm = reinterpret_cast<QOptionTreeItem*>(index.internalPointer());
+            if (itm && itm->type == QOptionTreeItem::Group){
+                QFont font = QApplication::font();
+                font.setBold(true);
+                return QVariant(font);
+            }
+            return QVariant();
+        }
+        break;
+
+        case Qt::DisplayRole: {
+            QOptionTreeItem* itm;
+            if (!index.isValid())
+                itm = rootItem;
+            else
+                itm = reinterpret_cast<QOptionTreeItem*>(index.internalPointer());
+
+            if (index.column() == 0)
+                return cups->unicodeString(itm->description);
+            else if (itm->type == QOptionTreeItem::Option && itm->selected > -1)
+                return cups->unicodeString(itm->selDescription);
+            else
+                return QVariant();
+        }
+        break;
+
+        default:
+            return QVariant();
+    }
+    if (role != Qt::DisplayRole)
+        return QVariant();
+}
+
+QModelIndex QPPDOptionsModel::index(int row, int column, const QModelIndex& parent) const
+{
+    QOptionTreeItem* itm;
+    if (!parent.isValid())
+        itm = rootItem;
+    else
+        itm = reinterpret_cast<QOptionTreeItem*>(parent.internalPointer());
+
+    return createIndex(row, column, itm->childItems.at(row));
+}
+
+
+QModelIndex QPPDOptionsModel::parent(const QModelIndex& index) const
+{
+    if (!index.isValid())
+        return QModelIndex();
+
+    QOptionTreeItem* itm = reinterpret_cast<QOptionTreeItem*>(index.internalPointer());
+
+    if (itm->parentItem && itm->parentItem != rootItem)
+        return createIndex(itm->parentItem->index, 0, itm->parentItem);
+    else
+        return QModelIndex();
+}
+
+Qt::ItemFlags QPPDOptionsModel::flags(const QModelIndex& index) const
+{
+    if (!index.isValid() || reinterpret_cast<QOptionTreeItem*>(index.internalPointer())->type == QOptionTreeItem::Group)
+        return Qt::ItemIsEnabled;
+
+    if (index.column() == 1)
+        return Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable;
+
+    return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
+}
+
+void QPPDOptionsModel::parseItems()
+{
+    emit layoutAboutToBeChanged();
+    ppd = cups->currentPPD();
+    delete rootItem;
+    rootItem = new QOptionTreeItem(QOptionTreeItem::Root, 0, ppd, "Root Item", 0);
+    parseGroups(rootItem);
+    emit layoutChanged();
+}
+
+void QPPDOptionsModel::parseGroups(QOptionTreeItem* parent)
+{
+    if (parent->type == QOptionTreeItem::Root) {
+
+        const ppd_file_t* ppdFile = reinterpret_cast<const ppd_file_t*>(parent->ptr);
+
+        if (ppdFile) {
+            for (int i = 0; i < ppdFile->num_groups; ++i) {
+                QOptionTreeItem* group = new QOptionTreeItem(QOptionTreeItem::Group, i, &ppdFile->groups[i], ppdFile->groups[i].text, parent);
+                parent->childItems.append(group);
+                parseGroups(group); // parse possible subgroups
+                parseOptions(group); // parse options
+            }
+        }
+    } else if (parent->type == QOptionTreeItem::Group) {
+
+        const ppd_group_t* group = reinterpret_cast<const ppd_group_t*>(parent->ptr);
+
+        if (group) {
+            for (int i = 0; i < group->num_subgroups; ++i) {
+                QOptionTreeItem* subgroup = new QOptionTreeItem(QOptionTreeItem::Group, i, &group->subgroups[i], group->subgroups[i].text, parent);
+                parent->childItems.append(subgroup);
+                parseGroups(subgroup); // parse possible subgroups
+                parseOptions(subgroup); // parse options
+            }
+        }
+    }
+}
+
+void QPPDOptionsModel::parseOptions(QOptionTreeItem* parent)
+{
+    const ppd_group_t* group = reinterpret_cast<const ppd_group_t*>(parent->ptr);
+    for (int i = 0; i < group->num_options; ++i) {
+        QOptionTreeItem* opt = new QOptionTreeItem(QOptionTreeItem::Option, i, &group->options[i], group->options[i].text, parent);
+        parent->childItems.append(opt);
+        parseChoices(opt);
+    }
+}
+
+void QPPDOptionsModel::parseChoices(QOptionTreeItem* parent)
+{
+    const ppd_option_t* option = reinterpret_cast<const ppd_option_t*>(parent->ptr);
+    bool marked = false;
+    for (int i = 0; i < option->num_choices; ++i) {
+        QOptionTreeItem* choice = new QOptionTreeItem(QOptionTreeItem::Choice, i, &option->choices[i], option->choices[i].text, parent);
+        if (static_cast<int>(option->choices[i].marked) == 1) {
+            parent->selected = i;
+            parent->selDescription = option->choices[i].text;
+            marked = true;
+        } else if (!marked && qstrcmp(option->choices[i].choice, option->defchoice) == 0) {
+            parent->selected = i;
+            parent->selDescription = option->choices[i].text;
+        }
+        parent->childItems.append(choice);
+    }
+}
+
+QVariant QPPDOptionsModel::headerData(int section, Qt::Orientation, int role) const
+{
+    if (role != Qt::DisplayRole)
+        return QVariant();
+
+    switch(section){
+        case 0:
+            return QVariant(QApplication::translate("QPPDOptionsModel", "Name"));
+        case 1:
+            return QVariant(QApplication::translate("QPPDOptionsModel", "Value"));
+        default:
+            return QVariant();
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+QWidget* QPPDOptionsEditor::createEditor(QWidget* parent, const QStyleOptionViewItem&, const QModelIndex& index) const
+{
+    if (index.column() == 1 && reinterpret_cast<QOptionTreeItem*>(index.internalPointer())->type == QOptionTreeItem::Option)
+        return new QComboBox(parent);
+    else
+        return 0;
+}
+
+void QPPDOptionsEditor::setEditorData(QWidget* editor, const QModelIndex& index) const
+{
+    if (index.column() != 1)
+        return;
+
+    QComboBox* cb = static_cast<QComboBox*>(editor);
+    QOptionTreeItem* itm = reinterpret_cast<QOptionTreeItem*>(index.internalPointer());
+
+    if (itm->selected == -1)
+        cb->addItem(QString());
+
+    for (int i = 0; i < itm->childItems.count(); ++i)
+        cb->addItem(QString::fromLocal8Bit(itm->childItems.at(i)->description));
+
+    if (itm->selected > -1)
+        cb->setCurrentIndex(itm->selected);
+
+    connect(cb, SIGNAL(currentIndexChanged(int)), this, SLOT(cbChanged(int)));
+}
+
+void QPPDOptionsEditor::setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const
+{
+    QComboBox* cb = static_cast<QComboBox*>(editor);
+    QOptionTreeItem* itm = reinterpret_cast<QOptionTreeItem*>(index.internalPointer());
+
+    if (itm->selected == cb->currentIndex())
+        return;
+
+    const ppd_option_t* opt = reinterpret_cast<const ppd_option_t*>(itm->ptr);
+    QPPDOptionsModel* m = static_cast<QPPDOptionsModel*>(model);
+
+    if (m->cups->markOption(opt->keyword, opt->choices[cb->currentIndex()].choice) == 0) {
+        itm->selected = cb->currentIndex();
+        itm->selDescription = reinterpret_cast<const ppd_option_t*>(itm->ptr)->choices[itm->selected].text;
+    }
+}
+
+void QPPDOptionsEditor::cbChanged(int)
+{
+/*
+    emit commitData(static_cast<QWidget*>(sender()));
+*/
+}
+
+#endif
+
+QT_END_NAMESPACE
+
+#include "moc_qprintdialog.cpp"
+#include "qprintdialog_unix.moc"
+#include "qrc_qprintdialog.cpp"
+
+#endif // QT_NO_PRINTDIALOG
+
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/kernel/qclipboard_x11.cpp qt-everywhere-opensource-src-4.8.7/src/gui/kernel/qclipboard_x11.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/kernel/qclipboard_x11.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/kernel/qclipboard_x11.cpp	2017-09-26 08:03:54.246749076 +0000
@@ -548,7 +548,8 @@
                 return false;
 
             XSync(X11->display, false);
-            usleep(50000);
+            if (!XPending(X11->display))
+                usleep(5000);
 
             now.start();
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/kernel/qkde.cpp qt-everywhere-opensource-src-4.8.7/src/gui/kernel/qkde.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/kernel/qkde.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/kernel/qkde.cpp	2017-09-26 08:04:17.203416525 +0000
@@ -63,7 +63,7 @@
         kdeHomePath = QString::fromLocal8Bit(qgetenv("KDEHOME"));
         if (kdeHomePath.isEmpty()) {
             QDir homeDir(QDir::homePath());
-            QString kdeConfDir(QLatin1String("/.kde"));
+            QString kdeConfDir(QLatin1String("/.kde4"));
             if (4 == X11->desktopVersion && homeDir.exists(QLatin1String(".kde4")))
             kdeConfDir = QLatin1String("/.kde4");
             kdeHomePath = QDir::homePath() + kdeConfDir;
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/painting/qprinter.cpp qt-everywhere-opensource-src-4.8.7/src/gui/painting/qprinter.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/painting/qprinter.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/painting/qprinter.cpp	2017-09-26 08:02:52.830080319 +0000
@@ -609,6 +609,44 @@
                && d_ptr->paintEngine->type() != QPaintEngine::MacPrinter) {
         setOutputFormat(QPrinter::PdfFormat);
     }
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    // fill in defaults from ppd file
+    QCUPSSupport cups;
+
+    int printernum = -1;
+    for (int i = 0; i < cups.availablePrintersCount(); i++) {
+        if (printerName().toLocal8Bit() == cups.availablePrinters()[i].name)
+            printernum = i;
+    }
+    if (printernum >= 0) {
+        cups.setCurrentPrinter(printernum);
+
+        const ppd_option_t* duplex = cups.ppdOption("Duplex");
+        if (duplex) {
+            // copy default ppd duplex to qt dialog
+            if (qstrcmp(duplex->defchoice, "DuplexTumble") == 0)
+                setDuplex(DuplexShortSide);
+            else if (qstrcmp(duplex->defchoice, "DuplexNoTumble") == 0)
+                setDuplex(DuplexLongSide);
+            else
+                setDuplex(DuplexNone);
+        }
+
+        if (cups.currentPPD()) {
+            // set default color
+            if (cups.currentPPD()->color_device)
+                setColorMode(Color);
+            else
+                setColorMode(GrayScale);
+        }
+
+        // set collation
+        const ppd_option_t *collate = cups.ppdOption("Collate");
+        if (collate)
+            setCollateCopies(qstrcmp(collate->defchoice, "True")==0);
+    }
+#endif
 }
 
 /*!
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/painting/qprinter.cpp.orig qt-everywhere-opensource-src-4.8.7/src/gui/painting/qprinter.cpp.orig
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/painting/qprinter.cpp.orig	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/painting/qprinter.cpp.orig	2015-05-07 14:14:43.000000000 +0000
@@ -0,0 +1,2453 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 The Qt Company Ltd.
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see http://www.qt.io/terms-conditions. For further
+** information use the contact form at http://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** As a special exception, The Qt Company gives you certain additional
+** rights. These rights are described in The Qt Company LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qprinter_p.h"
+#include "qprinter.h"
+#include "qprintengine.h"
+#include "qprinterinfo.h"
+#include "qlist.h"
+#include <qpagesetupdialog.h>
+#include <qapplication.h>
+#include <qfileinfo.h>
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+#include "private/qcups_p.h"
+#endif
+
+#ifndef QT_NO_PRINTER
+
+#if defined (Q_WS_WIN)
+#include <private/qprintengine_win_p.h>
+#elif defined (Q_WS_MAC)
+#include <private/qprintengine_mac_p.h>
+#elif defined (QTOPIA_PRINTENGINE)
+#include <private/qprintengine_qws_p.h>
+#endif
+#include <private/qprintengine_ps_p.h>
+
+#if defined(Q_WS_X11)
+#include <private/qt_x11_p.h>
+#endif
+
+#ifndef QT_NO_PDF
+#include "qprintengine_pdf_p.h"
+#endif
+
+#include <qpicture.h>
+#include <private/qpaintengine_preview_p.h>
+
+#if defined(QT3_SUPPORT)
+#  include "qprintdialog.h"
+#endif // QT3_SUPPORT
+
+QT_BEGIN_NAMESPACE
+
+#define ABORT_IF_ACTIVE(location) \
+    if (d->printEngine->printerState() == QPrinter::Active) { \
+        qWarning("%s: Cannot be changed while printer is active", location); \
+        return; \
+    }
+
+// NB! This table needs to be in sync with QPrinter::PaperSize
+static const float qt_paperSizes[][2] = {
+    {210, 297}, // A4
+    {176, 250}, // B5
+    {215.9f, 279.4f}, // Letter
+    {215.9f, 355.6f}, // Legal
+    {190.5f, 254}, // Executive
+    {841, 1189}, // A0
+    {594, 841}, // A1
+    {420, 594}, // A2
+    {297, 420}, // A3
+    {148, 210}, // A5
+    {105, 148}, // A6
+    {74, 105}, // A7
+    {52, 74}, // A8
+    {37, 52}, // A8
+    {1000, 1414}, // B0
+    {707, 1000}, // B1
+    {31, 44}, // B10
+    {500, 707}, // B2
+    {353, 500}, // B3
+    {250, 353}, // B4
+    {125, 176}, // B6
+    {88, 125}, // B7
+    {62, 88}, // B8
+    {33, 62}, // B9
+    {163, 229}, // C5E
+    {105, 241}, // US Common
+    {110, 220}, // DLE
+    {210, 330}, // Folio
+    {431.8f, 279.4f}, // Ledger
+    {279.4f, 431.8f} // Tabloid
+};
+
+/// return the multiplier of converting from the unit value to postscript-points.
+double qt_multiplierForUnit(QPrinter::Unit unit, int resolution)
+{
+    switch(unit) {
+    case QPrinter::Millimeter:
+        return 2.83464566929;
+    case QPrinter::Point:
+        return 1.0;
+    case QPrinter::Inch:
+        return 72.0;
+    case QPrinter::Pica:
+        return 12;
+    case QPrinter::Didot:
+        return 1.065826771;
+    case QPrinter::Cicero:
+        return 12.789921252;
+    case QPrinter::DevicePixel:
+        return 72.0/resolution;
+    }
+    return 1.0;
+}
+
+// not static: it's needed in qpagesetupdialog_unix.cpp
+QSizeF qt_printerPaperSize(QPrinter::Orientation orientation,
+                           QPrinter::PaperSize paperSize,
+                           QPrinter::Unit unit,
+                           int resolution)
+{
+    int width_index = 0;
+    int height_index = 1;
+    if (orientation == QPrinter::Landscape) {
+        width_index = 1;
+        height_index = 0;
+    }
+    const qreal multiplier = qt_multiplierForUnit(unit, resolution);
+    return QSizeF((qt_paperSizes[paperSize][width_index] * 72 / 25.4) / multiplier,
+                  (qt_paperSizes[paperSize][height_index] * 72 / 25.4) / multiplier);
+}
+
+void QPrinterPrivate::createDefaultEngines()
+{
+    QPrinter::OutputFormat realOutputFormat = outputFormat;
+#if !defined (QTOPIA_PRINTENGINE)
+#if defined (Q_OS_UNIX) && ! defined (Q_WS_MAC)
+    if(outputFormat == QPrinter::NativeFormat) {
+        realOutputFormat = QPrinter::PostScriptFormat;
+    }
+#endif
+#endif
+
+    switch (realOutputFormat) {
+    case QPrinter::NativeFormat: {
+#if defined (Q_WS_WIN)
+        QWin32PrintEngine *winEngine = new QWin32PrintEngine(printerMode);
+        paintEngine = winEngine;
+        printEngine = winEngine;
+#elif defined (Q_WS_MAC)
+        QMacPrintEngine *macEngine = new QMacPrintEngine(printerMode);
+        paintEngine = macEngine;
+        printEngine = macEngine;
+#elif defined (QTOPIA_PRINTENGINE)
+        QtopiaPrintEngine *qwsEngine = new QtopiaPrintEngine(printerMode);
+        paintEngine = qwsEngine;
+        printEngine = qwsEngine;
+#elif defined (Q_OS_UNIX)
+        Q_ASSERT(false);
+#endif
+        }
+        break;
+    case QPrinter::PdfFormat: {
+        QPdfEngine *pdfEngine = new QPdfEngine(printerMode);
+        paintEngine = pdfEngine;
+        printEngine = pdfEngine;
+    }
+        break;
+    case QPrinter::PostScriptFormat: {
+        QPSPrintEngine *psEngine = new QPSPrintEngine(printerMode);
+        paintEngine = psEngine;
+        printEngine = psEngine;
+    }
+        break;
+    }
+    use_default_engine = true;
+    had_default_engines = true;
+}
+
+#ifndef QT_NO_PRINTPREVIEWWIDGET
+QList<const QPicture *> QPrinterPrivate::previewPages() const
+{
+    if (previewEngine)
+        return previewEngine->pages();
+    return QList<const QPicture *>();
+}
+
+void QPrinterPrivate::setPreviewMode(bool enable)
+{
+    Q_Q(QPrinter);
+    if (enable) {
+        if (!previewEngine)
+            previewEngine = new QPreviewPaintEngine;
+        had_default_engines = use_default_engine;
+        use_default_engine = false;
+        realPrintEngine = printEngine;
+        realPaintEngine = paintEngine;
+        q->setEngines(previewEngine, previewEngine);
+        previewEngine->setProxyEngines(realPrintEngine, realPaintEngine);
+    } else {
+        q->setEngines(realPrintEngine, realPaintEngine);
+        use_default_engine = had_default_engines;
+    }
+}
+#endif // QT_NO_PRINTPREVIEWWIDGET
+
+void QPrinterPrivate::addToManualSetList(QPrintEngine::PrintEnginePropertyKey key)
+{
+    for (int c = 0; c < manualSetList.size(); ++c) {
+        if (manualSetList[c] == key) return;
+    }
+    manualSetList.append(key);
+}
+
+
+/*!
+  \class QPrinter
+  \reentrant
+
+  \brief The QPrinter class is a paint device that paints on a printer.
+
+  \ingroup printing
+
+
+  This device represents a series of pages of printed output, and is
+  used in almost exactly the same way as other paint devices such as
+  QWidget and QPixmap.
+  A set of additional functions are provided to manage device-specific
+  features, such as orientation and resolution, and to step through
+  the pages in a document as it is generated.
+
+  When printing directly to a printer on Windows or Mac OS X, QPrinter uses
+  the built-in printer drivers. On X11, QPrinter uses the
+  \l{Common Unix Printing System (CUPS)} or the standard Unix \l lpr utility
+  to send PostScript or PDF output to the printer. As an alternative,
+  the printProgram() function can be used to specify the command or utility
+  to use instead of the system default.
+
+  Note that setting parameters like paper size and resolution on an
+  invalid printer is undefined. You can use QPrinter::isValid() to
+  verify this before changing any parameters.
+
+  QPrinter supports a number of parameters, most of which can be
+  changed by the end user through a \l{QPrintDialog}{print dialog}. In
+  general, QPrinter passes these functions onto the underlying QPrintEngine.
+
+  The most important parameters are:
+  \list
+  \i setOrientation() tells QPrinter which page orientation to use.
+  \i setPaperSize() tells QPrinter what paper size to expect from the
+  printer.
+  \i setResolution() tells QPrinter what resolution you wish the
+  printer to provide, in dots per inch (DPI).
+  \i setFullPage() tells QPrinter whether you want to deal with the
+  full page or just with the part the printer can draw on.
+  \i setCopyCount() tells QPrinter how many copies of the document
+  it should print.
+  \endlist
+
+  Many of these functions can only be called before the actual printing
+  begins (i.e., before QPainter::begin() is called). This usually makes
+  sense because, for example, it's not possible to change the number of
+  copies when you are halfway through printing. There are also some
+  settings that the user sets (through the printer dialog) and that
+  applications are expected to obey. See QAbstractPrintDialog's
+  documentation for more details.
+
+  When QPainter::begin() is called, the QPrinter it operates on is prepared for
+  a new page, enabling the QPainter to be used immediately to paint the first
+  page in a document. Once the first page has been painted, newPage() can be
+  called to request a new blank page to paint on, or QPainter::end() can be
+  called to finish printing. The second page and all following pages are
+  prepared using a call to newPage() before they are painted.
+
+  The first page in a document does not need to be preceded by a call to
+  newPage(). You only need to calling newPage() after QPainter::begin() if you
+  need to insert a blank page at the beginning of a printed document.
+  Similarly, calling newPage() after the last page in a document is painted will
+  result in a trailing blank page appended to the end of the printed document.
+
+  If you want to abort the print job, abort() will try its best to
+  stop printing. It may cancel the entire job or just part of it.
+
+  Since QPrinter can print to any QPrintEngine subclass, it is possible to
+  extend printing support to cover new types of printing subsystem by
+  subclassing QPrintEngine and reimplementing its interface.
+
+  \sa QPrintDialog, {Printing with Qt}
+*/
+
+/*!
+    \enum QPrinter::PrinterState
+
+    \value Idle
+    \value Active
+    \value Aborted
+    \value Error
+*/
+
+/*!
+    \enum QPrinter::PrinterMode
+
+    This enum describes the mode the printer should work in. It
+    basically presets a certain resolution and working mode.
+
+    \value ScreenResolution Sets the resolution of the print device to
+    the screen resolution. This has the big advantage that the results
+    obtained when painting on the printer will match more or less
+    exactly the visible output on the screen. It is the easiest to
+    use, as font metrics on the screen and on the printer are the
+    same. This is the default value. ScreenResolution will produce a
+    lower quality output than HighResolution and should only be used
+    for drafts.
+
+    \value PrinterResolution This value is deprecated. Is is
+    equivalent to ScreenResolution on Unix and HighResolution on
+    Windows and Mac. Due do the difference between ScreenResolution
+    and HighResolution, use of this value may lead to non-portable
+    printer code.
+
+    \value HighResolution On Windows, sets the printer resolution to that
+    defined for the printer in use. For PostScript printing, sets the
+    resolution of the PostScript driver to 1200 dpi.
+
+    \note When rendering text on a QPrinter device, it is important
+    to realize that the size of text, when specified in points, is
+    independent of the resolution specified for the device itself.
+    Therefore, it may be useful to specify the font size in pixels
+    when combining text with graphics to ensure that their relative
+    sizes are what you expect.
+*/
+
+/*!
+  \enum QPrinter::Orientation
+
+  This enum type (not to be confused with \c Orientation) is used
+  to specify each page's orientation.
+
+  \value Portrait the page's height is greater than its width.
+
+  \value Landscape the page's width is greater than its height.
+
+  This type interacts with \l QPrinter::PaperSize and
+  QPrinter::setFullPage() to determine the final size of the page
+  available to the application.
+*/
+
+
+/*!
+    \enum QPrinter::PrintRange
+
+    Used to specify the print range selection option.
+
+    \value AllPages All pages should be printed.
+    \value Selection Only the selection should be printed.
+    \value PageRange The specified page range should be printed.
+    \value CurrentPage Only the current page should be printed.
+
+    \sa QAbstractPrintDialog::PrintRange
+*/
+
+/*!
+    \enum QPrinter::PrinterOption
+    \compat
+
+    Use QAbstractPrintDialog::PrintDialogOption instead.
+
+    \value PrintToFile
+    \value PrintSelection
+    \value PrintPageRange
+*/
+
+/*!
+  \enum QPrinter::PageSize
+
+  \obsolete
+  Use QPrinter::PaperSize instead.
+
+  \value A0 841 x 1189 mm
+  \value A1 594 x 841 mm
+  \value A2 420 x 594 mm
+  \value A3 297 x 420 mm
+  \value A4 210 x 297 mm, 8.26 x 11.69 inches
+  \value A5 148 x 210 mm
+  \value A6 105 x 148 mm
+  \value A7 74 x 105 mm
+  \value A8 52 x 74 mm
+  \value A9 37 x 52 mm
+  \value B0 1030 x 1456 mm
+  \value B1 728 x 1030 mm
+  \value B10 32 x 45 mm
+  \value B2 515 x 728 mm
+  \value B3 364 x 515 mm
+  \value B4 257 x 364 mm
+  \value B5 182 x 257 mm, 7.17 x 10.13 inches
+  \value B6 128 x 182 mm
+  \value B7 91 x 128 mm
+  \value B8 64 x 91 mm
+  \value B9 45 x 64 mm
+  \value C5E 163 x 229 mm
+  \value Comm10E 105 x 241 mm, U.S. Common 10 Envelope
+  \value DLE 110 x 220 mm
+  \value Executive 7.5 x 10 inches, 191 x 254 mm
+  \value Folio 210 x 330 mm
+  \value Ledger 432 x 279 mm
+  \value Legal 8.5 x 14 inches, 216 x 356 mm
+  \value Letter 8.5 x 11 inches, 216 x 279 mm
+  \value Tabloid 279 x 432 mm
+  \value Custom Unknown, or a user defined size.
+
+  \omitvalue NPageSize
+  */
+
+/*!
+  \enum QPrinter::PaperSize
+  \since 4.4
+
+  This enum type specifies what paper size QPrinter should use.
+  QPrinter does not check that the paper size is available; it just
+  uses this information, together with QPrinter::Orientation and
+  QPrinter::setFullPage(), to determine the printable area.
+
+  The defined sizes (with setFullPage(true)) are:
+
+  \value A0 841 x 1189 mm
+  \value A1 594 x 841 mm
+  \value A2 420 x 594 mm
+  \value A3 297 x 420 mm
+  \value A4 210 x 297 mm, 8.26 x 11.69 inches
+  \value A5 148 x 210 mm
+  \value A6 105 x 148 mm
+  \value A7 74 x 105 mm
+  \value A8 52 x 74 mm
+  \value A9 37 x 52 mm
+  \value B0 1000 x 1414 mm
+  \value B1 707 x 1000 mm
+  \value B2 500 x 707 mm
+  \value B3 353 x 500 mm
+  \value B4 250 x 353 mm
+  \value B5 176 x 250 mm, 6.93 x 9.84 inches
+  \value B6 125 x 176 mm
+  \value B7 88 x 125 mm
+  \value B8 62 x 88 mm
+  \value B9 33 x 62 mm
+  \value B10 31 x 44 mm
+  \value C5E 163 x 229 mm
+  \value Comm10E 105 x 241 mm, U.S. Common 10 Envelope
+  \value DLE 110 x 220 mm
+  \value Executive 7.5 x 10 inches, 190.5 x 254 mm
+  \value Folio 210 x 330 mm
+  \value Ledger 431.8 x 279.4 mm
+  \value Legal 8.5 x 14 inches, 215.9 x 355.6 mm
+  \value Letter 8.5 x 11 inches, 215.9 x 279.4 mm
+  \value Tabloid 279.4 x 431.8 mm
+  \value Custom Unknown, or a user defined size.
+
+  With setFullPage(false) (the default), the metrics will be a bit
+  smaller; how much depends on the printer in use.
+
+  \omitvalue NPageSize
+  \omitvalue NPaperSize
+*/
+
+
+/*!
+  \enum QPrinter::PageOrder
+
+  This enum type is used by QPrinter to tell the application program
+  how to print.
+
+  \value FirstPageFirst  the lowest-numbered page should be printed
+  first.
+
+  \value LastPageFirst  the highest-numbered page should be printed
+  first.
+*/
+
+/*!
+  \enum QPrinter::ColorMode
+
+  This enum type is used to indicate whether QPrinter should print
+  in color or not.
+
+  \value Color  print in color if available, otherwise in grayscale.
+
+  \value GrayScale  print in grayscale, even on color printers.
+*/
+
+/*!
+  \enum QPrinter::PaperSource
+
+  This enum type specifies what paper source QPrinter is to use.
+  QPrinter does not check that the paper source is available; it
+  just uses this information to try and set the paper source.
+  Whether it will set the paper source depends on whether the
+  printer has that particular source.
+
+  \warning This is currently only implemented for Windows.
+
+  \value Auto
+  \value Cassette
+  \value Envelope
+  \value EnvelopeManual
+  \value FormSource
+  \value LargeCapacity
+  \value LargeFormat
+  \value Lower
+  \value MaxPageSource
+  \value Middle
+  \value Manual
+  \value OnlyOne
+  \value Tractor
+  \value SmallFormat
+*/
+
+/*!
+  \enum QPrinter::Unit
+  \since 4.4
+
+  This enum type is used to specify the measurement unit for page and
+  paper sizes.
+
+  \value Millimeter
+  \value Point
+  \value Inch
+  \value Pica
+  \value Didot
+  \value Cicero
+  \value DevicePixel
+
+  Note the difference between Point and DevicePixel. The Point unit is
+  defined to be 1/72th of an inch, while the DevicePixel unit is
+  resolution dependant and is based on the actual pixels, or dots, on
+  the printer.
+*/
+
+
+/*
+  \enum QPrinter::PrintRange
+
+  This enum is used to specify which print range the application
+  should use to print.
+
+  \value AllPages All the pages should be printed.
+  \value Selection Only the selection should be printed.
+  \value PageRange Print according to the from page and to page options.
+  \value CurrentPage Only the current page should be printed.
+
+  \sa setPrintRange(), printRange()
+*/
+
+/*
+  \enum QPrinter::PrinterOption
+
+  This enum describes various printer options that appear in the
+  printer setup dialog. It is used to enable and disable these
+  options in the setup dialog.
+
+  \value PrintToFile Describes if print to file should be enabled.
+  \value PrintSelection Describes if printing selections should be enabled.
+  \value PrintPageRange Describes if printing page ranges (from, to) should
+  be enabled
+  \value PrintCurrentPage if Print Current Page option should be enabled
+
+  \sa setOptionEnabled(), isOptionEnabled()
+*/
+
+/*!
+    Creates a new printer object with the given \a mode.
+*/
+QPrinter::QPrinter(PrinterMode mode)
+    : QPaintDevice(),
+      d_ptr(new QPrinterPrivate(this))
+{
+    init(mode);
+    QPrinterInfo defPrn(QPrinterInfo::defaultPrinter());
+    if (!defPrn.isNull()) {
+        setPrinterName(defPrn.printerName());
+    } else if (QPrinterInfo::availablePrinters().isEmpty()
+               && d_ptr->paintEngine->type() != QPaintEngine::Windows
+               && d_ptr->paintEngine->type() != QPaintEngine::MacPrinter) {
+        setOutputFormat(QPrinter::PdfFormat);
+    }
+}
+
+/*!
+    \since 4.4
+
+    Creates a new printer object with the given \a printer and \a mode.
+*/
+QPrinter::QPrinter(const QPrinterInfo& printer, PrinterMode mode)
+    : QPaintDevice(),
+      d_ptr(new QPrinterPrivate(this))
+{
+    init(mode);
+    setPrinterName(printer.printerName());
+}
+
+void QPrinter::init(PrinterMode mode)
+{
+#if !defined(Q_WS_X11)
+    if (!qApp) {
+#else
+    if (!qApp || !X11) {
+#endif
+        qFatal("QPrinter: Must construct a QApplication before a QPaintDevice");
+        return;
+    }
+    Q_D(QPrinter);
+
+    d->printerMode = mode;
+    d->outputFormat = QPrinter::NativeFormat;
+    d->createDefaultEngines();
+
+#ifndef QT_NO_PRINTPREVIEWWIDGET
+    d->previewEngine = 0;
+#endif
+    d->realPrintEngine = 0;
+    d->realPaintEngine = 0;
+
+#if !defined(QT_NO_CUPS) && !defined(QT_NO_LIBRARY)
+    if (QCUPSSupport::cupsVersion() >= 10200 && QCUPSSupport().currentPPD()) {
+        setOutputFormat(QPrinter::PdfFormat);
+        d->outputFormat = QPrinter::NativeFormat;
+    }
+#endif
+}
+
+/*!
+    This function is used by subclasses of QPrinter to specify custom
+    print and paint engines (\a printEngine and \a paintEngine,
+    respectively).
+
+    QPrinter does not take ownership of the engines, so you need to
+    manage these engine instances yourself.
+
+    Note that changing the engines will reset the printer state and
+    all its properties.
+
+    \sa printEngine() paintEngine() setOutputFormat()
+
+    \since 4.1
+*/
+void QPrinter::setEngines(QPrintEngine *printEngine, QPaintEngine *paintEngine)
+{
+    Q_D(QPrinter);
+
+    if (d->use_default_engine)
+        delete d->printEngine;
+
+    d->printEngine = printEngine;
+    d->paintEngine = paintEngine;
+    d->use_default_engine = false;
+}
+
+/*!
+    Destroys the printer object and frees any allocated resources. If
+    the printer is destroyed while a print job is in progress this may
+    or may not affect the print job.
+*/
+QPrinter::~QPrinter()
+{
+    Q_D(QPrinter);
+    if (d->use_default_engine)
+        delete d->printEngine;
+#ifndef QT_NO_PRINTPREVIEWWIDGET
+    delete d->previewEngine;
+#endif
+}
+
+/*!
+    \enum QPrinter::OutputFormat
+
+    The OutputFormat enum is used to describe the format QPrinter should
+    use for printing.
+
+    \value NativeFormat QPrinter will print output using a method defined
+    by the platform it is running on. This mode is the default when printing
+    directly to a printer.
+
+    \value PdfFormat QPrinter will generate its output as a searchable PDF file.
+    This mode is the default when printing to a file.
+
+    \value PostScriptFormat QPrinter will generate its output as in the PostScript format.
+    (This feature was introduced in Qt 4.2.)
+
+    \sa outputFormat(), setOutputFormat(), setOutputFileName()
+*/
+
+/*!
+    \since 4.1
+
+    Sets the output format for this printer to \a format.
+*/
+void QPrinter::setOutputFormat(OutputFormat format)
+{
+
+#ifndef QT_NO_PDF
+    Q_D(QPrinter);
+    if (d->validPrinter && d->outputFormat == format)
+        return;
+    d->outputFormat = format;
+
+    QPrintEngine *oldPrintEngine = d->printEngine;
+    const bool def_engine = d->use_default_engine;
+    d->printEngine = 0;
+
+    d->createDefaultEngines();
+
+    if (oldPrintEngine) {
+        for (int i = 0; i < d->manualSetList.size(); ++i) {
+            QPrintEngine::PrintEnginePropertyKey key = d->manualSetList[i];
+            QVariant prop;
+            // PPK_NumberOfCopies need special treatmeant since it in most cases
+            // will return 1, disregarding the actual value that was set
+            if (key == QPrintEngine::PPK_NumberOfCopies)
+                prop = QVariant(copyCount());
+            else
+                prop = oldPrintEngine->property(key);
+            if (prop.isValid())
+                d->printEngine->setProperty(key, prop);
+        }
+    }
+
+    if (def_engine)
+        delete oldPrintEngine;
+
+    if (d->outputFormat == QPrinter::PdfFormat || d->outputFormat == QPrinter::PostScriptFormat)
+        d->validPrinter = true;
+#else
+    Q_UNUSED(format);
+#endif
+}
+
+/*!
+    \since 4.1
+
+    Returns the output format for this printer.
+*/
+QPrinter::OutputFormat QPrinter::outputFormat() const
+{
+    Q_D(const QPrinter);
+    return d->outputFormat;
+}
+
+
+
+/*! \internal
+*/
+int QPrinter::devType() const
+{
+    return QInternal::Printer;
+}
+
+/*!
+    Returns the printer name. This value is initially set to the name
+    of the default printer.
+
+    \sa setPrinterName()
+*/
+QString QPrinter::printerName() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_PrinterName).toString();
+}
+
+/*!
+    Sets the printer name to \a name.
+
+    \sa printerName(), isValid()
+*/
+void QPrinter::setPrinterName(const QString &name)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setPrinterName");
+
+#if defined(Q_OS_UNIX) && !defined(QT_NO_CUPS)
+    if(d->use_default_engine
+        && d->outputFormat == QPrinter::NativeFormat) {
+        if (QCUPSSupport::cupsVersion() >= 10200
+            && QCUPSSupport::printerHasPPD(name.toLocal8Bit().constData()))
+            setOutputFormat(QPrinter::PdfFormat);
+        else
+            setOutputFormat(QPrinter::PostScriptFormat);
+        d->outputFormat = QPrinter::NativeFormat;
+    }
+#endif
+
+    QList<QPrinterInfo> prnList = QPrinterInfo::availablePrinters();
+    if (name.isEmpty()) {
+        d->validPrinter = d->outputFormat == QPrinter::PdfFormat || d->outputFormat == QPrinter::PostScriptFormat;
+    } else {
+        d->validPrinter = false;
+        for (int i = 0; i < prnList.size(); ++i) {
+            if (prnList[i].printerName() == name) {
+                d->validPrinter = true;
+                break;
+            }
+        }
+    }
+
+    d->printEngine->setProperty(QPrintEngine::PPK_PrinterName, name);
+    d->addToManualSetList(QPrintEngine::PPK_PrinterName);
+}
+
+
+/*!
+  \since 4.4
+
+  Returns true if the printer currently selected is a valid printer
+  in the system, or a pure PDF/PostScript printer; otherwise returns false.
+
+  To detect other failures check the output of QPainter::begin() or QPrinter::newPage().
+
+  \snippet doc/src/snippets/printing-qprinter/errors.cpp 0
+
+  \sa setPrinterName()
+*/
+bool QPrinter::isValid() const
+{
+    Q_D(const QPrinter);
+#if defined(Q_WS_X11)
+    if (!qApp || !X11) {
+        return false;
+    }
+#endif
+    return d->validPrinter;
+}
+
+
+/*!
+  \fn bool QPrinter::outputToFile() const
+
+  Returns true if the output should be written to a file, or false
+  if the output should be sent directly to the printer. The default
+  setting is false.
+
+  \sa setOutputToFile(), setOutputFileName()
+*/
+
+
+/*!
+  \fn void QPrinter::setOutputToFile(bool enable)
+
+  Specifies whether the output should be written to a file or sent
+  directly to the printer.
+
+  Will output to a file if \a enable is true, or will output
+  directly to the printer if \a enable is false.
+
+  \sa outputToFile(), setOutputFileName()
+*/
+
+
+/*!
+  \fn QString QPrinter::outputFileName() const
+
+  Returns the name of the output file. By default, this is an empty string
+  (indicating that the printer shouldn't print to file).
+
+  \sa QPrintEngine::PrintEnginePropertyKey
+
+*/
+
+QString QPrinter::outputFileName() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_OutputFileName).toString();
+}
+
+/*!
+    Sets the name of the output file to \a fileName.
+
+    Setting a null or empty name (0 or "") disables printing to a file.
+    Setting a non-empty name enables printing to a file.
+
+    This can change the value of outputFormat().  If the file name has the
+    suffix ".ps" then PostScript is automatically selected as output format.
+    If the file name has the ".pdf" suffix PDF is generated. If the file name
+    has a suffix other than ".ps" and ".pdf", the output format used is the
+    one set with setOutputFormat().
+
+    QPrinter uses Qt's cross-platform PostScript or PDF print engines
+    respectively. If you can produce this format natively, for example
+    Mac OS X can generate PDF's from its print engine, set the output format
+    back to NativeFormat.
+
+    \sa outputFileName() setOutputToFile() setOutputFormat()
+*/
+
+void QPrinter::setOutputFileName(const QString &fileName)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setOutputFileName");
+
+    QFileInfo fi(fileName);
+    if (!fi.suffix().compare(QLatin1String("ps"), Qt::CaseInsensitive))
+        setOutputFormat(QPrinter::PostScriptFormat);
+    else if (!fi.suffix().compare(QLatin1String("pdf"), Qt::CaseInsensitive))
+        setOutputFormat(QPrinter::PdfFormat);
+    else if (fileName.isEmpty())
+        setOutputFormat(QPrinter::NativeFormat);
+
+    d->printEngine->setProperty(QPrintEngine::PPK_OutputFileName, fileName);
+    d->addToManualSetList(QPrintEngine::PPK_OutputFileName);
+}
+
+
+/*!
+  Returns the name of the program that sends the print output to the
+  printer.
+
+  The default is to return an empty string; meaning that QPrinter will try to
+  be smart in a system-dependent way. On X11 only, you can set it to something
+  different to use a specific print program. On the other platforms, this
+  returns an empty string.
+
+  \sa setPrintProgram(), setPrinterSelectionOption()
+*/
+QString QPrinter::printProgram() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_PrinterProgram).toString();
+}
+
+
+/*!
+  Sets the name of the program that should do the print job to \a
+  printProg.
+
+  On X11, this function sets the program to call with the PostScript
+  output. On other platforms, it has no effect.
+
+  \sa printProgram()
+*/
+void QPrinter::setPrintProgram(const QString &printProg)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setPrintProgram");
+    d->printEngine->setProperty(QPrintEngine::PPK_PrinterProgram, printProg);
+    d->addToManualSetList(QPrintEngine::PPK_PrinterProgram);
+}
+
+
+/*!
+  Returns the document name.
+
+  \sa setDocName(), QPrintEngine::PrintEnginePropertyKey
+*/
+QString QPrinter::docName() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_DocumentName).toString();
+}
+
+
+/*!
+  Sets the document name to \a name.
+
+  On X11, the document name is for example used as the default
+  output filename in QPrintDialog. Note that the document name does
+  not affect the file name if the printer is printing to a file.
+  Use the setOutputFile() function for this.
+
+  \sa docName(), QPrintEngine::PrintEnginePropertyKey
+*/
+void QPrinter::setDocName(const QString &name)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setDocName");
+    d->printEngine->setProperty(QPrintEngine::PPK_DocumentName, name);
+    d->addToManualSetList(QPrintEngine::PPK_DocumentName);
+}
+
+
+/*!
+  Returns the name of the application that created the document.
+
+  \sa setCreator()
+*/
+QString QPrinter::creator() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_Creator).toString();
+}
+
+
+/*!
+  Sets the name of the application that created the document to \a
+  creator.
+
+  This function is only applicable to the X11 version of Qt. If no
+  creator name is specified, the creator will be set to "Qt"
+  followed by some version number.
+
+  \sa creator()
+*/
+void QPrinter::setCreator(const QString &creator)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setCreator");
+    d->printEngine->setProperty(QPrintEngine::PPK_Creator, creator);
+    d->addToManualSetList(QPrintEngine::PPK_Creator);
+}
+
+
+/*!
+  Returns the orientation setting. This is driver-dependent, but is usually
+  QPrinter::Portrait.
+
+  \sa setOrientation()
+*/
+QPrinter::Orientation QPrinter::orientation() const
+{
+    Q_D(const QPrinter);
+    return QPrinter::Orientation(d->printEngine->property(QPrintEngine::PPK_Orientation).toInt());
+}
+
+
+/*!
+  Sets the print orientation to \a orientation.
+
+  The orientation can be either QPrinter::Portrait or
+  QPrinter::Landscape.
+
+  The printer driver reads this setting and prints using the
+  specified orientation.
+
+  On Windows, this option can be changed while printing and will
+  take effect from the next call to newPage().
+
+  On Mac OS X, changing the orientation during a print job has no effect.
+
+  \sa orientation()
+*/
+
+void QPrinter::setOrientation(Orientation orientation)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_Orientation, orientation);
+    d->addToManualSetList(QPrintEngine::PPK_Orientation);
+}
+
+
+/*!
+    \since 4.4
+    Returns the printer paper size. The default value is driver-dependent.
+
+    \sa setPaperSize() pageRect() paperRect()
+*/
+
+QPrinter::PaperSize QPrinter::paperSize() const
+{
+    Q_D(const QPrinter);
+    return QPrinter::PaperSize(d->printEngine->property(QPrintEngine::PPK_PaperSize).toInt());
+}
+
+/*!
+    \since 4.4
+
+    Sets the printer paper size to \a newPaperSize if that size is
+    supported. The result is undefined if \a newPaperSize is not
+    supported.
+
+    The default paper size is driver-dependent.
+
+    This function is useful mostly for setting a default value that
+    the user can override in the print dialog.
+
+    \sa paperSize() PaperSize setFullPage() setResolution() pageRect() paperRect()
+*/
+void QPrinter::setPaperSize(PaperSize newPaperSize)
+{
+    Q_D(QPrinter);
+    if (d->paintEngine->type() != QPaintEngine::Pdf)
+        ABORT_IF_ACTIVE("QPrinter::setPaperSize");
+    if (newPaperSize < 0 || newPaperSize >= NPaperSize) {
+        qWarning("QPrinter::setPaperSize: Illegal paper size %d", newPaperSize);
+        return;
+    }
+    d->printEngine->setProperty(QPrintEngine::PPK_PaperSize, newPaperSize);
+    d->addToManualSetList(QPrintEngine::PPK_PaperSize);
+    d->hasUserSetPageSize = true;
+}
+
+/*!
+    \obsolete
+
+    Returns the printer page size. The default value is driver-dependent.
+
+    Use paperSize() instead.
+*/
+QPrinter::PageSize QPrinter::pageSize() const
+{
+    return paperSize();
+}
+
+
+/*!
+    \obsolete
+
+    Sets the printer page size based on \a newPageSize.
+
+    Use setPaperSize() instead.
+*/
+
+void QPrinter::setPageSize(PageSize newPageSize)
+{
+    setPaperSize(newPageSize);
+}
+
+/*!
+    \since 4.4
+
+    Sets the paper size based on \a paperSize in \a unit.
+
+    \sa paperSize()
+*/
+
+void QPrinter::setPaperSize(const QSizeF &paperSize, QPrinter::Unit unit)
+{
+    Q_D(QPrinter);
+    if (d->paintEngine->type() != QPaintEngine::Pdf)
+        ABORT_IF_ACTIVE("QPrinter::setPaperSize");
+    const qreal multiplier = qt_multiplierForUnit(unit, resolution());
+    QSizeF size(paperSize.width() * multiplier, paperSize.height() * multiplier);
+    d->printEngine->setProperty(QPrintEngine::PPK_CustomPaperSize, size);
+    d->addToManualSetList(QPrintEngine::PPK_CustomPaperSize);
+    d->hasUserSetPageSize = true;
+}
+
+/*!
+    \since 4.4
+
+    Returns the paper size in \a unit.
+
+    \sa setPaperSize()
+*/
+
+QSizeF QPrinter::paperSize(Unit unit) const
+{
+    Q_D(const QPrinter);
+    int res = resolution();
+    const qreal multiplier = qt_multiplierForUnit(unit, res);
+    PaperSize paperType = paperSize();
+    if (paperType == Custom) {
+        QSizeF size = d->printEngine->property(QPrintEngine::PPK_CustomPaperSize).toSizeF();
+        return QSizeF(size.width() / multiplier, size.height() / multiplier);
+    }
+    else {
+        return qt_printerPaperSize(orientation(), paperType, unit, res);
+    }
+}
+
+/*!
+    Sets the page order to \a pageOrder.
+
+    The page order can be QPrinter::FirstPageFirst or
+    QPrinter::LastPageFirst. The application is responsible for
+    reading the page order and printing accordingly.
+
+    This function is mostly useful for setting a default value that
+    the user can override in the print dialog.
+
+    This function is only supported under X11.
+*/
+
+void QPrinter::setPageOrder(PageOrder pageOrder)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setPageOrder");
+    d->printEngine->setProperty(QPrintEngine::PPK_PageOrder, pageOrder);
+    d->addToManualSetList(QPrintEngine::PPK_PageOrder);
+}
+
+
+/*!
+  Returns the current page order.
+
+  The default page order is \c FirstPageFirst.
+*/
+
+QPrinter::PageOrder QPrinter::pageOrder() const
+{
+    Q_D(const QPrinter);
+    return QPrinter::PageOrder(d->printEngine->property(QPrintEngine::PPK_PageOrder).toInt());
+}
+
+
+/*!
+  Sets the printer's color mode to \a newColorMode, which can be
+  either \c Color or \c GrayScale.
+
+  \sa colorMode()
+*/
+
+void QPrinter::setColorMode(ColorMode newColorMode)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setColorMode");
+    d->printEngine->setProperty(QPrintEngine::PPK_ColorMode, newColorMode);
+    d->addToManualSetList(QPrintEngine::PPK_ColorMode);
+}
+
+
+/*!
+  Returns the current color mode.
+
+  \sa setColorMode()
+*/
+QPrinter::ColorMode QPrinter::colorMode() const
+{
+    Q_D(const QPrinter);
+    return QPrinter::ColorMode(d->printEngine->property(QPrintEngine::PPK_ColorMode).toInt());
+}
+
+
+/*!
+  \obsolete
+  Returns the number of copies to be printed. The default value is 1.
+
+  On Windows, Mac OS X and X11 systems that support CUPS, this will always
+  return 1 as these operating systems can internally handle the number
+  of copies.
+
+  On X11, this value will return the number of times the application is
+  required to print in order to match the number specified in the printer setup
+  dialog. This has been done since some printer drivers are not capable of
+  buffering up the copies and in those cases the application must make an
+  explicit call to the print code for each copy.
+
+  Use copyCount() in conjunction with supportsMultipleCopies() instead.
+
+  \sa setNumCopies(), actualNumCopies()
+*/
+
+int QPrinter::numCopies() const
+{
+    Q_D(const QPrinter);
+   return d->printEngine->property(QPrintEngine::PPK_NumberOfCopies).toInt();
+}
+
+
+/*!
+    \obsolete
+    \since 4.6
+
+    Returns the number of copies that will be printed. The default
+    value is 1.
+
+    This function always returns the actual value specified in the print
+    dialog or using setNumCopies().
+
+    Use copyCount() instead.
+
+    \sa setNumCopies(), numCopies()
+*/
+int QPrinter::actualNumCopies() const
+{
+    return copyCount();
+}
+
+
+
+/*!
+  \obsolete
+  Sets the number of copies to be printed to \a numCopies.
+
+  The printer driver reads this setting and prints the specified
+  number of copies.
+
+  Use setCopyCount() instead.
+
+  \sa numCopies()
+*/
+
+void QPrinter::setNumCopies(int numCopies)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setNumCopies");
+    d->printEngine->setProperty(QPrintEngine::PPK_NumberOfCopies, numCopies);
+    d->addToManualSetList(QPrintEngine::PPK_NumberOfCopies);
+}
+
+/*!
+    \since 4.7
+
+    Sets the number of copies to be printed to \a count.
+
+    The printer driver reads this setting and prints the specified number of
+    copies.
+
+    \sa copyCount(), supportsMultipleCopies()
+*/
+
+void QPrinter::setCopyCount(int count)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setCopyCount;");
+    d->printEngine->setProperty(QPrintEngine::PPK_CopyCount, count);
+    d->addToManualSetList(QPrintEngine::PPK_CopyCount);
+}
+
+/*!
+    \since 4.7
+
+    Returns the number of copies that will be printed. The default value is 1.
+
+    \sa setCopyCount(), supportsMultipleCopies()
+*/
+
+int QPrinter::copyCount() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_CopyCount).toInt();
+}
+
+/*!
+    \since 4.7
+
+    Returns true if the printer supports printing multiple copies of the same
+    document in one job; otherwise false is returned.
+
+    On most systems this function will return true. However, on X11 systems
+    that do not support CUPS, this function will return false. That means the
+    application has to handle the number of copies by printing the same
+    document the required number of times.
+
+    \sa setCopyCount(), copyCount()
+*/
+
+bool QPrinter::supportsMultipleCopies() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_SupportsMultipleCopies).toBool();
+}
+
+/*!
+    \since 4.1
+
+    Returns true if collation is turned on when multiple copies is selected.
+    Returns false if it is turned off when multiple copies is selected.
+    When collating is turned off the printing of each individual page will be repeated
+    the numCopies() amount before the next page is started. With collating turned on
+    all pages are printed before the next copy of those pages is started.
+
+    \sa setCollateCopies()
+*/
+bool QPrinter::collateCopies() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_CollateCopies).toBool();
+}
+
+
+/*!
+    \since 4.1
+
+    Sets the default value for collation checkbox when the print
+    dialog appears.  If \a collate is true, it will enable
+    setCollateCopiesEnabled().  The default value is false. This value
+    will be changed by what the user presses in the print dialog.
+
+    \sa collateCopies()
+*/
+void QPrinter::setCollateCopies(bool collate)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setCollateCopies");
+    d->printEngine->setProperty(QPrintEngine::PPK_CollateCopies, collate);
+    d->addToManualSetList(QPrintEngine::PPK_CollateCopies);
+}
+
+
+
+/*!
+  If \a fp is true, enables support for painting over the entire page;
+  otherwise restricts painting to the printable area reported by the
+  device.
+
+  By default, full page printing is disabled. In this case, the origin
+  of the QPrinter's coordinate system coincides with the top-left
+  corner of the printable area.
+
+  If full page printing is enabled, the origin of the QPrinter's
+  coordinate system coincides with the top-left corner of the paper
+  itself. In this case, the
+  \l{QPaintDevice::PaintDeviceMetric}{device metrics} will report
+  the exact same dimensions as indicated by \l{PaperSize}. It may not
+  be possible to print on the entire physical page because of the
+  printer's margins, so the application must account for the margins
+  itself.
+
+  \sa fullPage(), setPaperSize(), width(), height(), {Printing with Qt}
+*/
+
+void QPrinter::setFullPage(bool fp)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_FullPage, fp);
+    d->addToManualSetList(QPrintEngine::PPK_FullPage);
+}
+
+
+/*!
+  Returns true if the origin of the printer's coordinate system is
+  at the corner of the page and false if it is at the edge of the
+  printable area.
+
+  See setFullPage() for details and caveats.
+
+  \sa setFullPage() PaperSize
+*/
+
+bool QPrinter::fullPage() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_FullPage).toBool();
+}
+
+
+/*!
+  Requests that the printer prints at \a dpi or as near to \a dpi as
+  possible.
+
+  This setting affects the coordinate system as returned by, for
+  example QPainter::viewport().
+
+  This function must be called before QPainter::begin() to have an effect on
+  all platforms.
+
+  \sa resolution() setPaperSize()
+*/
+
+void QPrinter::setResolution(int dpi)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setResolution");
+    d->printEngine->setProperty(QPrintEngine::PPK_Resolution, dpi);
+    d->addToManualSetList(QPrintEngine::PPK_Resolution);
+}
+
+
+/*!
+  Returns the current assumed resolution of the printer, as set by
+  setResolution() or by the printer driver.
+
+  \sa setResolution()
+*/
+
+int QPrinter::resolution() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_Resolution).toInt();
+}
+
+/*!
+  Sets the paper source setting to \a source.
+
+  Windows only: This option can be changed while printing and will
+  take effect from the next call to newPage()
+
+  \sa paperSource()
+*/
+
+void QPrinter::setPaperSource(PaperSource source)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_PaperSource, source);
+    d->addToManualSetList(QPrintEngine::PPK_PaperSource);
+}
+
+/*!
+    Returns the printer's paper source. This is \c Manual or a printer
+    tray or paper cassette.
+*/
+QPrinter::PaperSource QPrinter::paperSource() const
+{
+    Q_D(const QPrinter);
+    return QPrinter::PaperSource(d->printEngine->property(QPrintEngine::PPK_PaperSource).toInt());
+}
+
+
+/*!
+  \since 4.1
+
+  Enabled or disables font embedding depending on \a enable.
+
+  Currently this option is only supported on X11.
+
+  \sa fontEmbeddingEnabled()
+*/
+void QPrinter::setFontEmbeddingEnabled(bool enable)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_FontEmbedding, enable);
+    d->addToManualSetList(QPrintEngine::PPK_FontEmbedding);
+}
+
+/*!
+  \since 4.1
+
+  Returns true if font embedding is enabled.
+
+  Currently this option is only supported on X11.
+
+  \sa setFontEmbeddingEnabled()
+*/
+bool QPrinter::fontEmbeddingEnabled() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_FontEmbedding).toBool();
+}
+
+/*!
+    \enum QPrinter::DuplexMode
+    \since 4.4
+
+    This enum is used to indicate whether printing will occur on one or both sides
+    of each sheet of paper (simplex or duplex printing).
+
+    \value DuplexNone       Single sided (simplex) printing only.
+    \value DuplexAuto       The printer's default setting is used to determine whether
+                            duplex printing is used.
+    \value DuplexLongSide   Both sides of each sheet of paper are used for printing.
+                            The paper is turned over its longest edge before the second
+                            side is printed
+    \value DuplexShortSide  Both sides of each sheet of paper are used for printing.
+                            The paper is turned over its shortest edge before the second
+                            side is printed
+*/
+
+/*!
+  \since 4.2
+
+  Enables double sided printing if \a doubleSided is true; otherwise disables it.
+
+  Currently this option is only supported on X11.
+*/
+void QPrinter::setDoubleSidedPrinting(bool doubleSided)
+{
+    setDuplex(doubleSided ? DuplexAuto : DuplexNone);
+}
+
+
+/*!
+  \since 4.2
+
+  Returns true if double side printing is enabled.
+
+  Currently this option is only supported on X11.
+*/
+bool QPrinter::doubleSidedPrinting() const
+{
+    return duplex() != DuplexNone;
+}
+
+/*!
+  \since 4.4
+
+  Enables double sided printing based on the \a duplex mode.
+
+  Currently this option is only supported on X11.
+*/
+void QPrinter::setDuplex(DuplexMode duplex)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_Duplex, duplex);
+    d->addToManualSetList(QPrintEngine::PPK_Duplex);
+}
+
+/*!
+  \since 4.4
+
+  Returns the current duplex mode.
+
+  Currently this option is only supported on X11.
+*/
+QPrinter::DuplexMode QPrinter::duplex() const
+{
+    Q_D(const QPrinter);
+    return static_cast <DuplexMode> (d->printEngine->property(QPrintEngine::PPK_Duplex).toInt());
+}
+
+/*!
+    \since 4.4
+
+    Returns the page's rectangle in \a unit; this is usually smaller
+    than the paperRect() since the page normally has margins between
+    its borders and the paper.
+
+    \sa paperSize()
+*/
+QRectF QPrinter::pageRect(Unit unit) const
+{
+    Q_D(const QPrinter);
+    int res = resolution();
+    const qreal multiplier = qt_multiplierForUnit(unit, res);
+    // the page rect is in device pixels
+    QRect devRect(d->printEngine->property(QPrintEngine::PPK_PageRect).toRect());
+    if (unit == DevicePixel)
+        return devRect;
+    QRectF diRect(devRect.x()*72.0/res,
+                  devRect.y()*72.0/res,
+                  devRect.width()*72.0/res,
+                  devRect.height()*72.0/res);
+    return QRectF(diRect.x()/multiplier, diRect.y()/multiplier,
+                  diRect.width()/multiplier, diRect.height()/multiplier);
+}
+
+
+/*!
+    \since 4.4
+
+    Returns the paper's rectangle in \a unit; this is usually larger
+    than the pageRect().
+
+   \sa pageRect()
+*/
+QRectF QPrinter::paperRect(Unit unit) const
+{
+    Q_D(const QPrinter);
+    int res = resolution();
+    const qreal multiplier = qt_multiplierForUnit(unit, resolution());
+    // the page rect is in device pixels
+    QRect devRect(d->printEngine->property(QPrintEngine::PPK_PaperRect).toRect());
+    if (unit == DevicePixel)
+        return devRect;
+    QRectF diRect(devRect.x()*72.0/res,
+                  devRect.y()*72.0/res,
+                  devRect.width()*72.0/res,
+                  devRect.height()*72.0/res);
+    return QRectF(diRect.x()/multiplier, diRect.y()/multiplier,
+                  diRect.width()/multiplier, diRect.height()/multiplier);
+}
+
+/*!
+    Returns the page's rectangle; this is usually smaller than the
+    paperRect() since the page normally has margins between its
+    borders and the paper.
+
+    The unit of the returned rectangle is DevicePixel.
+
+    \sa paperSize()
+*/
+QRect QPrinter::pageRect() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_PageRect).toRect();
+}
+
+/*!
+    Returns the paper's rectangle; this is usually larger than the
+    pageRect().
+
+    The unit of the returned rectangle is DevicePixel.
+
+    \sa pageRect()
+*/
+QRect QPrinter::paperRect() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_PaperRect).toRect();
+}
+
+
+/*!
+    \since 4.4
+
+    This function sets the \a left, \a top, \a right and \a bottom
+    page margins for this printer. The unit of the margins are
+    specified with the \a unit parameter.
+*/
+void QPrinter::setPageMargins(qreal left, qreal top, qreal right, qreal bottom, QPrinter::Unit unit)
+{
+    Q_D(QPrinter);
+    const qreal multiplier = qt_multiplierForUnit(unit, resolution());
+    QList<QVariant> margins;
+    margins << (left * multiplier) << (top * multiplier)
+            << (right * multiplier) << (bottom * multiplier);
+    d->printEngine->setProperty(QPrintEngine::PPK_PageMargins, margins);
+    d->addToManualSetList(QPrintEngine::PPK_PageMargins);
+    d->hasCustomPageMargins = true;
+}
+
+/*!
+    \since 4.4
+
+    Returns the page margins for this printer in \a left, \a top, \a
+    right, \a bottom. The unit of the returned margins are specified
+    with the \a unit parameter.
+*/
+void QPrinter::getPageMargins(qreal *left, qreal *top, qreal *right, qreal *bottom, QPrinter::Unit unit) const
+{
+    Q_D(const QPrinter);
+    Q_ASSERT(left && top && right && bottom);
+    const qreal multiplier = qt_multiplierForUnit(unit, resolution());
+    QList<QVariant> margins(d->printEngine->property(QPrintEngine::PPK_PageMargins).toList());
+    *left = margins.at(0).toReal() / multiplier;
+    *top = margins.at(1).toReal() / multiplier;
+    *right = margins.at(2).toReal() / multiplier;
+    *bottom = margins.at(3).toReal() / multiplier;
+}
+
+/*!
+    \internal
+
+    Returns the metric for the given \a id.
+*/
+int QPrinter::metric(PaintDeviceMetric id) const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->metric(id);
+}
+
+/*!
+    Returns the paint engine used by the printer.
+*/
+QPaintEngine *QPrinter::paintEngine() const
+{
+    Q_D(const QPrinter);
+    return d->paintEngine;
+}
+
+/*!
+    \since 4.1
+
+    Returns the print engine used by the printer.
+*/
+QPrintEngine *QPrinter::printEngine() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine;
+}
+
+#if defined (Q_WS_WIN)
+/*!
+    Sets the page size to be used by the printer under Windows to \a
+    pageSize.
+
+    \warning This function is not portable so you may prefer to use
+    setPaperSize() instead.
+
+    \sa winPageSize()
+*/
+void QPrinter::setWinPageSize(int pageSize)
+{
+    Q_D(QPrinter);
+    ABORT_IF_ACTIVE("QPrinter::setWinPageSize");
+    d->printEngine->setProperty(QPrintEngine::PPK_WindowsPageSize, pageSize);
+    d->addToManualSetList(QPrintEngine::PPK_WindowsPageSize);
+}
+
+/*!
+    Returns the page size used by the printer under Windows.
+
+    \warning This function is not portable so you may prefer to use
+    paperSize() instead.
+
+    \sa setWinPageSize()
+*/
+int QPrinter::winPageSize() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_WindowsPageSize).toInt();
+}
+#endif // Q_WS_WIN
+
+/*!
+    Returns a list of the resolutions (a list of dots-per-inch
+    integers) that the printer says it supports.
+
+    For X11 where all printing is directly to postscript, this
+    function will always return a one item list containing only the
+    postscript resolution, i.e., 72 (72 dpi -- but see PrinterMode).
+*/
+QList<int> QPrinter::supportedResolutions() const
+{
+    Q_D(const QPrinter);
+    QList<QVariant> varlist
+        = d->printEngine->property(QPrintEngine::PPK_SupportedResolutions).toList();
+    QList<int> intlist;
+    for (int i=0; i<varlist.size(); ++i)
+        intlist << varlist.at(i).toInt();
+    return intlist;
+}
+
+/*!
+    Tells the printer to eject the current page and to continue
+    printing on a new page. Returns true if this was successful;
+    otherwise returns false.
+
+    Calling newPage() on an inactive QPrinter object will always
+    fail.
+*/
+bool QPrinter::newPage()
+{
+    Q_D(QPrinter);
+    if (d->printEngine->printerState() != QPrinter::Active)
+        return false;
+    return d->printEngine->newPage();
+}
+
+/*!
+    Aborts the current print run. Returns true if the print run was
+    successfully aborted and printerState() will return QPrinter::Aborted; otherwise
+    returns false.
+
+    It is not always possible to abort a print job. For example,
+    all the data has gone to the printer but the printer cannot or
+    will not cancel the job when asked to.
+*/
+bool QPrinter::abort()
+{
+    Q_D(QPrinter);
+    return d->printEngine->abort();
+}
+
+/*!
+    Returns the current state of the printer. This may not always be
+    accurate (for example if the printer doesn't have the capability
+    of reporting its state to the operating system).
+*/
+QPrinter::PrinterState QPrinter::printerState() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->printerState();
+}
+
+
+/*! \fn void QPrinter::margins(uint *top, uint *left, uint *bottom, uint *right) const
+
+    Sets *\a top, *\a left, *\a bottom, *\a right to be the top,
+    left, bottom, and right margins.
+
+    This function has been superseded by paperRect() and pageRect().
+    Use paperRect().top() - pageRect().top() for the top margin,
+    paperRect().left() - pageRect().left() for the left margin,
+    paperRect().bottom() - pageRect().bottom() for the bottom margin,
+    and papaerRect().right() - pageRect().right() for the right
+    margin.
+
+    \oldcode
+        uint rightMargin;
+        uint bottomMargin;
+        printer->margins(0, 0, &bottomMargin, &rightMargin);
+    \newcode
+        int rightMargin = printer->paperRect().right() - printer->pageRect().right();
+        int bottomMargin = printer->paperRect().bottom() - printer->pageRect().bottom();
+    \endcode
+*/
+
+/*! \fn QSize QPrinter::margins() const
+
+    \overload
+
+    Returns a QSize containing the left margin and the top margin.
+
+    This function has been superseded by paperRect() and pageRect().
+    Use paperRect().left() - pageRect().left() for the left margin,
+    and paperRect().top() - pageRect().top() for the top margin.
+
+    \oldcode
+        QSize margins = printer->margins();
+        int leftMargin = margins.width();
+        int topMargin = margins.height();
+    \newcode
+        int leftMargin = printer->paperRect().left() - printer->pageRect().left();
+        int topMargin = printer->paperRect().top() - printer->pageRect().top();
+    \endcode
+*/
+
+/*! \fn bool QPrinter::aborted()
+
+    Use printerState() == QPrinter::Aborted instead.
+*/
+
+#ifdef Q_WS_WIN
+/*!
+    \internal
+*/
+HDC QPrinter::getDC() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->getPrinterDC();
+}
+
+/*!
+    \internal
+*/
+void QPrinter::releaseDC(HDC hdc) const
+{
+    Q_D(const QPrinter);
+    d->printEngine->releasePrinterDC(hdc);
+}
+
+/*!
+    Returns the supported paper sizes for this printer.
+
+    The values will be either a value that matches an entry in the
+    QPrinter::PaperSource enum or a driver spesific value. The driver
+    spesific values are greater than the constant DMBIN_USER declared
+    in wingdi.h.
+
+    \warning This function is only available in windows.
+*/
+
+QList<QPrinter::PaperSource> QPrinter::supportedPaperSources() const
+{
+    Q_D(const QPrinter);
+    QVariant v = d->printEngine->property(QPrintEngine::PPK_PaperSources);
+
+    QList<QVariant> variant_list = v.toList();
+    QList<QPrinter::PaperSource> int_list;
+    for (int i=0; i<variant_list.size(); ++i)
+        int_list << (QPrinter::PaperSource) variant_list.at(i).toInt();
+
+    return int_list;
+}
+
+#endif
+
+/*!
+    \fn QString QPrinter::printerSelectionOption() const
+
+    Returns the printer options selection string. This is useful only
+    if the print command has been explicitly set.
+
+    The default value (an empty string) implies that the printer should
+    be selected in a system-dependent manner.
+
+    Any other value implies that the given value should be used.
+
+    \warning This function is not available on Windows.
+
+    \sa setPrinterSelectionOption()
+*/
+
+/*!
+    \fn void QPrinter::setPrinterSelectionOption(const QString &option)
+
+    Sets the printer to use \a option to select the printer. \a option
+    is null by default (which implies that Qt should be smart enough
+    to guess correctly), but it can be set to other values to use a
+    specific printer selection option.
+
+    If the printer selection option is changed while the printer is
+    active, the current print job may or may not be affected.
+
+    \warning This function is not available on Windows.
+
+    \sa printerSelectionOption()
+*/
+
+#ifndef Q_WS_WIN
+QString QPrinter::printerSelectionOption() const
+{
+    Q_D(const QPrinter);
+    return d->printEngine->property(QPrintEngine::PPK_SelectionOption).toString();
+}
+
+void QPrinter::setPrinterSelectionOption(const QString &option)
+{
+    Q_D(QPrinter);
+    d->printEngine->setProperty(QPrintEngine::PPK_SelectionOption, option);
+    d->addToManualSetList(QPrintEngine::PPK_SelectionOption);
+}
+#endif
+
+/*!
+    \since 4.1
+    \fn int QPrinter::fromPage() const
+
+    Returns the number of the first page in a range of pages to be printed
+    (the "from page" setting). Pages in a document are numbered according to
+    the convention that the first page is page 1.
+
+    By default, this function returns a special value of 0, meaning that
+    the "from page" setting is unset.
+
+    \note If fromPage() and toPage() both return 0, this indicates that
+    \e{the whole document will be printed}.
+
+    \sa setFromTo(), toPage()
+*/
+
+int QPrinter::fromPage() const
+{
+    Q_D(const QPrinter);
+    return d->fromPage;
+}
+
+/*!
+    \since 4.1
+
+    Returns the number of the last page in a range of pages to be printed
+    (the "to page" setting). Pages in a document are numbered according to
+    the convention that the first page is page 1.
+
+    By default, this function returns a special value of 0, meaning that
+    the "to page" setting is unset.
+
+    \note If fromPage() and toPage() both return 0, this indicates that
+    \e{the whole document will be printed}.
+
+    The programmer is responsible for reading this setting and
+    printing accordingly.
+
+    \sa setFromTo(), fromPage()
+*/
+
+int QPrinter::toPage() const
+{
+    Q_D(const QPrinter);
+    return d->toPage;
+}
+
+/*!
+    \since 4.1
+
+    Sets the range of pages to be printed to cover the pages with numbers
+    specified by \a from and \a to, where \a from corresponds to the first
+    page in the range and \a to corresponds to the last.
+
+    \note Pages in a document are numbered according to the convention that
+    the first page is page 1. However, if \a from and \a to are both set to 0,
+    the \e{whole document will be printed}.
+
+    This function is mostly used to set a default value that the user can
+    override in the print dialog when you call setup().
+
+    \sa fromPage(), toPage()
+*/
+
+void QPrinter::setFromTo(int from, int to)
+{
+    Q_D(QPrinter);
+    if (from > to) {
+        qWarning() << "QPrinter::setFromTo: 'from' must be less than or equal to 'to'";
+        from = to;
+    }
+    d->fromPage = from;
+    d->toPage = to;
+
+    if (d->minPage == 0 && d->maxPage == 0) {
+        d->minPage = 1;
+        d->maxPage = to;
+        d->options |= QAbstractPrintDialog::PrintPageRange;
+    }
+}
+
+/*!
+    \since 4.1
+
+    Sets the print range option in to be \a range.
+*/
+void QPrinter::setPrintRange( PrintRange range )
+{
+    Q_D(QPrinter);
+    d->printRange = QAbstractPrintDialog::PrintRange(range);
+}
+
+/*!
+    \since 4.1
+
+    Returns the page range of the QPrinter. After the print setup
+    dialog has been opened, this function returns the value selected
+    by the user.
+
+    \sa setPrintRange()
+*/
+QPrinter::PrintRange QPrinter::printRange() const
+{
+    Q_D(const QPrinter);
+    return PrintRange(d->printRange);
+}
+
+#if defined(QT3_SUPPORT)
+
+void QPrinter::setOutputToFile(bool f)
+{
+    if (f) {
+        if (outputFileName().isEmpty())
+            setOutputFileName(QLatin1String("untitled_printer_document"));
+    } else {
+        setOutputFileName(QString());
+    }
+}
+
+bool qt_compat_QPrinter_printSetup(QPrinter *printer, QPrinterPrivate *pd, QWidget *parent)
+{
+    Q_UNUSED(pd);
+    QPrintDialog dlg(printer, parent);
+    return dlg.exec() != 0;
+}
+
+
+#ifdef Q_WS_MAC
+bool qt_compat_QPrinter_pageSetup(QPrinter *p, QWidget *parent)
+{
+    QPageSetupDialog psd(p, parent);
+    return psd.exec() != 0;
+}
+
+/*!
+    Executes a page setup dialog so that the user can configure the type of
+    page used for printing. Returns true if the contents of the dialog are
+    accepted; returns false if the dialog is canceled.
+*/
+bool QPrinter::pageSetup(QWidget *parent)
+{
+    return qt_compat_QPrinter_pageSetup(this, parent);
+}
+
+/*!
+    Executes a print setup dialog so that the user can configure the printing
+    process. Returns true if the contents of the dialog are accepted; returns
+    false if the dialog is canceled.
+*/
+bool QPrinter::printSetup(QWidget *parent)
+{
+    Q_D(QPrinter);
+    return qt_compat_QPrinter_printSetup(this, d, parent);
+}
+#endif // Q_WS_MAC
+
+/*!
+    Use QPrintDialog instead.
+
+    \oldcode
+        if (printer->setup(parent))
+            ...
+    \newcode
+        QPrintDialog dialog(printer, parent);
+        if (dialog.exec())
+            ...
+    \endcode
+*/
+bool QPrinter::setup(QWidget *parent)
+{
+    Q_D(QPrinter);
+    return qt_compat_QPrinter_printSetup(this, d, parent)
+#ifdef Q_WS_MAC
+        && qt_compat_QPrinter_pageSetup(this, parent);
+#endif
+        ;
+}
+
+/*!
+    Use QPrintDialog::minPage() instead.
+*/
+int QPrinter::minPage() const
+{
+    Q_D(const QPrinter);
+    return d->minPage;
+}
+
+/*!
+    Use QPrintDialog::maxPage() instead.
+*/
+int QPrinter::maxPage() const
+{
+    Q_D(const QPrinter);
+    return d->maxPage;
+}
+
+/*!
+    Use QPrintDialog::setMinMax() instead.
+*/
+void QPrinter::setMinMax( int minPage, int maxPage )
+{
+    Q_D(QPrinter);
+    Q_ASSERT_X(minPage <= maxPage, "QPrinter::setMinMax",
+               "'min' must be less than or equal to 'max'");
+    d->minPage = minPage;
+    d->maxPage = maxPage;
+    d->options |= QPrintDialog::PrintPageRange;
+}
+
+/*!
+    Returns true if the printer is set up to collate copies of printed documents;
+    otherwise returns false.
+
+    Use QPrintDialog::isOptionEnabled(QPrintDialog::PrintCollateCopies)
+    instead.
+
+    \sa collateCopies()
+*/
+bool QPrinter::collateCopiesEnabled() const
+{
+    Q_D(const QPrinter);
+    return (d->options & QPrintDialog::PrintCollateCopies);
+}
+
+/*!
+    Use QPrintDialog::setOption(QPrintDialog::PrintCollateCopies)
+    or QPrintDialog::setOptions(QPrintDialog::options()
+    & ~QPrintDialog::PrintCollateCopies) instead, depending on \a
+    enable.
+*/
+void QPrinter::setCollateCopiesEnabled(bool enable)
+{
+    Q_D(QPrinter);
+
+    if (enable)
+        d->options |= QPrintDialog::PrintCollateCopies;
+    else
+        d->options &= ~QPrintDialog::PrintCollateCopies;
+}
+
+/*!
+    Use QPrintDialog instead.
+*/
+void QPrinter::setOptionEnabled( PrinterOption option, bool enable )
+{
+    Q_D(QPrinter);
+    if (enable)
+        d->options |= QPrintDialog::PrintDialogOption(1 << option);
+    else
+        d->options &= ~QPrintDialog::PrintDialogOption(1 << option);
+}
+
+/*!
+    Use QPrintDialog instead.
+*/
+bool QPrinter::isOptionEnabled( PrinterOption option ) const
+{
+    Q_D(const QPrinter);
+    return (d->options & QPrintDialog::PrintDialogOption(option));
+}
+
+#endif // QT3_SUPPORT
+
+/*!
+    \class QPrintEngine
+    \reentrant
+
+    \ingroup printing
+
+    \brief The QPrintEngine class defines an interface for how QPrinter
+    interacts with a given printing subsystem.
+
+    The common case when creating your own print engine is to derive from both
+    QPaintEngine and QPrintEngine. Various properties of a print engine are
+    given with property() and set with setProperty().
+
+    \sa QPaintEngine
+*/
+
+/*!
+    \enum QPrintEngine::PrintEnginePropertyKey
+
+    This enum is used to communicate properties between the print
+    engine and QPrinter. A property may or may not be supported by a
+    given print engine.
+
+    \value PPK_CollateCopies A boolean value indicating whether the
+    printout should be collated or not.
+
+    \value PPK_ColorMode Refers to QPrinter::ColorMode, either color or
+    monochrome.
+
+    \value PPK_Creator A string describing the document's creator.
+
+    \value PPK_Duplex A boolean value indicating whether both sides of
+    the printer paper should be used for the printout.
+
+    \value PPK_DocumentName A string describing the document name in
+    the spooler.
+
+    \value PPK_FontEmbedding A boolean value indicating whether data for
+    the document's fonts should be embedded in the data sent to the
+    printer.
+
+    \value PPK_FullPage A boolean describing if the printer should be
+    full page or not.
+
+    \value PPK_NumberOfCopies Obsolete. An integer specifying the number of
+    copies. Use PPK_CopyCount instead.
+
+    \value PPK_Orientation Specifies a QPrinter::Orientation value.
+
+    \value PPK_OutputFileName The output file name as a string. An
+    empty file name indicates that the printer should not print to a file.
+
+    \value PPK_PageOrder Specifies a QPrinter::PageOrder value.
+
+    \value PPK_PageRect A QRect specifying the page rectangle
+
+    \value PPK_PageSize Obsolete. Use PPK_PaperSize instead.
+
+    \value PPK_PaperRect A QRect specifying the paper rectangle.
+
+    \value PPK_PaperSource Specifies a QPrinter::PaperSource value.
+
+    \value PPK_PaperSources Specifies more than one QPrinter::PaperSource value.
+
+    \value PPK_PaperSize Specifies a QPrinter::PaperSize value.
+
+    \value PPK_PrinterName A string specifying the name of the printer.
+
+    \value PPK_PrinterProgram A string specifying the name of the
+    printer program used for printing,
+
+    \value PPK_Resolution An integer describing the dots per inch for
+    this printer.
+
+    \value PPK_SelectionOption
+
+    \value PPK_SupportedResolutions A list of integer QVariants
+    describing the set of supported resolutions that the printer has.
+
+    \value PPK_SuppressSystemPrintStatus Suppress the built-in dialog for showing
+    printing progress. As of 4.1 this only has effect on Mac OS X where, by default,
+    a status dialog is shown.
+
+    \value PPK_WindowsPageSize An integer specifying a DM_PAPER entry
+    on Windows.
+
+    \value PPK_CustomPaperSize A QSizeF specifying a custom paper size
+    in the QPrinter::Point unit.
+
+    \value PPK_PageMargins A QList<QVariant> containing the left, top,
+    right and bottom margin values.
+
+    \value PPK_CopyCount An integer specifying the number of copies to print.
+
+    \value PPK_SupportsMultipleCopies A boolean value indicating whether or not
+    the printer supports printing multiple copies in one job.
+
+    \value PPK_CustomBase Basis for extension.
+*/
+
+/*!
+    \fn QPrintEngine::~QPrintEngine()
+
+    Destroys the print engine.
+*/
+
+/*!
+    \fn void QPrintEngine::setProperty(PrintEnginePropertyKey key, const QVariant &value)
+
+    Sets the print engine's property specified by \a key to the given \a value.
+
+    \sa property()
+*/
+
+/*!
+    \fn void QPrintEngine::property(PrintEnginePropertyKey key) const
+
+    Returns the print engine's property specified by \a key.
+
+    \sa setProperty()
+*/
+
+/*!
+    \fn bool QPrintEngine::newPage()
+
+    Instructs the print engine to start a new page. Returns true if
+    the printer was able to create the new page; otherwise returns false.
+*/
+
+/*!
+    \fn bool QPrintEngine::abort()
+
+    Instructs the print engine to abort the printing process. Returns
+    true if successful; otherwise returns false.
+*/
+
+/*!
+    \fn int QPrintEngine::metric(QPaintDevice::PaintDeviceMetric id) const
+
+    Returns the metric for the given \a id.
+*/
+
+/*!
+    \fn QPrinter::PrinterState QPrintEngine::printerState() const
+
+    Returns the current state of the printer being used by the print engine.
+*/
+
+/*!
+    \fn HDC QPrintEngine::getPrinterDC() const
+    \internal
+*/
+
+/*!
+    \fn void QPrintEngine::releasePrinterDC(HDC) const
+    \internal
+*/
+
+/*
+    Returns the dimensions for the given paper size, \a size, in millimeters.
+*/
+QSizeF qt_paperSizeToQSizeF(QPrinter::PaperSize size)
+{
+    if (size == QPrinter::Custom) return QSizeF(0, 0);
+    return QSizeF(qt_paperSizes[size][0], qt_paperSizes[size][1]);
+}
+
+/*
+    Returns the PaperSize type that matches \a size, where \a size
+    is in millimeters.
+
+    Because dimensions may not always be completely accurate (for
+    example when converting between units), a particular PaperSize
+    will be returned if it matches within -1/+1 millimeters.
+*/
+QPrinter::PaperSize qSizeFTopaperSize(const QSizeF& size)
+{
+    for (int i = 0; i < static_cast<int>(QPrinter::NPaperSize); ++i) {
+        if (qt_paperSizes[i][0] >= size.width() - 1 &&
+                qt_paperSizes[i][0] <= size.width() + 1 &&
+                qt_paperSizes[i][1] >= size.height() - 1 &&
+                qt_paperSizes[i][1] <= size.height() + 1) {
+            return QPrinter::PaperSize(i);
+        }
+    }
+
+    return QPrinter::Custom;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_PRINTER
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qabstractsystemtrayiconsys.cpp qt-everywhere-opensource-src-4.8.7/src/gui/util/qabstractsystemtrayiconsys.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qabstractsystemtrayiconsys.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qabstractsystemtrayiconsys.cpp	2017-09-26 08:03:14.976747740 +0000
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include "qabstractsystemtrayiconsys_p.h"
+
+
+QSystemTrayIconSysFactoryInterface::QSystemTrayIconSysFactoryInterface()
+{
+}
+
+/////////////////////////////////////////////////
+QAbstractSystemTrayIconSys::QAbstractSystemTrayIconSys(QSystemTrayIcon *icon)
+: trayIcon(icon)
+{
+}
+
+QAbstractSystemTrayIconSys::~QAbstractSystemTrayIconSys()
+{
+}
+
+void QAbstractSystemTrayIconSys::sendActivated(QSystemTrayIcon::ActivationReason reason)
+{
+    qtsystray_sendActivated(trayIcon, reason);
+}
+
+#endif
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qabstractsystemtrayiconsys_p.h qt-everywhere-opensource-src-4.8.7/src/gui/util/qabstractsystemtrayiconsys_p.h
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qabstractsystemtrayiconsys_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qabstractsystemtrayiconsys_p.h	2017-09-26 08:03:14.976747740 +0000
@@ -0,0 +1,106 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QABSTRACTSYSTEMTRAYICONSYS_P_H
+#define QABSTRACTSYSTEMTRAYICONSYS_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of a number of Qt sources files.  This header file may change from
+// version to version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include <qfactoryinterface.h>
+#include <qsystemtrayicon.h>
+
+class QAbstractSystemTrayIconSys;
+
+class Q_GUI_EXPORT QSystemTrayIconSysFactoryInterface : public QObject, public QFactoryInterface
+{
+    Q_OBJECT
+public:
+    QSystemTrayIconSysFactoryInterface();
+    virtual QAbstractSystemTrayIconSys * create(QSystemTrayIcon *) = 0;
+    virtual bool isAvailable() const = 0;
+
+    // \reimp
+    virtual QStringList keys() const { return QStringList() << QLatin1String("default"); }
+
+Q_SIGNALS:
+    void availableChanged(bool);
+};
+
+#define QSystemTrayIconSysFactoryInterface_iid "com.nokia.qt.QSystemTrayIconSysFactoryInterface"
+Q_DECLARE_INTERFACE(QSystemTrayIconSysFactoryInterface, QSystemTrayIconSysFactoryInterface_iid)
+
+class QRect;
+
+class Q_GUI_EXPORT QAbstractSystemTrayIconSys
+{
+public:
+    QAbstractSystemTrayIconSys(QSystemTrayIcon *icon);
+    virtual ~QAbstractSystemTrayIconSys();
+
+    virtual QRect geometry() const = 0;
+    virtual void updateVisibility() = 0;
+    virtual void updateIcon() = 0;
+    virtual void updateToolTip() = 0;
+    virtual void updateMenu() = 0;
+    virtual void showMessage(const QString &title, const QString &message,
+                     QSystemTrayIcon::MessageIcon icon, int msecs) = 0;
+
+    void sendActivated(QSystemTrayIcon::ActivationReason);
+
+protected:
+    QSystemTrayIcon *trayIcon;
+};
+
+#endif // QT_NO_SYSTEMTRAYICON
+
+#endif // QABSTRACTSYSTEMTRAYICONSYS_P_H
+
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon.cpp qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon.cpp	2017-09-26 08:03:14.976747740 +0000
@@ -287,12 +287,6 @@
 */
 bool QSystemTrayIcon::event(QEvent *e)
 {
-#if defined(Q_WS_X11)
-    if (e->type() == QEvent::ToolTip) {
-        Q_D(QSystemTrayIcon);
-        return d->sys->deliverToolTipEvent(e);
-    }
-#endif
     return QObject::event(e);
 }
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon_p.h qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon_p.h
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon_p.h	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon_p.h	2017-09-26 08:03:14.976747740 +0000
@@ -62,10 +62,17 @@
 #include "QtGui/qpixmap.h"
 #include "QtCore/qstring.h"
 #include "QtCore/qpointer.h"
+#if defined(Q_WS_X11)
+#include "QtCore/qset.h"
+#endif
 
 QT_BEGIN_NAMESPACE
 
+#if defined(Q_WS_X11)
+class QAbstractSystemTrayIconSys;
+#else
 class QSystemTrayIconSys;
+#endif
 class QToolButton;
 class QLabel;
 
@@ -75,6 +82,9 @@
 
 public:
     QSystemTrayIconPrivate() : sys(0), visible(false) { }
+    #if defined(Q_WS_X11)
+    ~QSystemTrayIconPrivate();
+    #endif
 
     void install_sys();
     void remove_sys();
@@ -90,7 +100,11 @@
     QPointer<QMenu> menu;
     QIcon icon;
     QString toolTip;
+    #if defined(Q_WS_X11)
+    QAbstractSystemTrayIconSys *sys;
+    #else
     QSystemTrayIconSys *sys;
+    #endif
     bool visible;
 };
 
@@ -123,60 +137,37 @@
 };
 
 #if defined(Q_WS_X11)
-QT_BEGIN_INCLUDE_NAMESPACE
-#include <QtCore/qcoreapplication.h>
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-#include <X11/Xutil.h>
-QT_END_INCLUDE_NAMESPACE
+class QSystemTrayIconSysFactoryInterface;
 
-class QSystemTrayIconSys : public QWidget
+/**
+ * This class acts as a composite QSystemTrayIconSysFactory: It can create
+ * instances of QAbstractSystemTrayIconSys* using either a plugin or the
+ * builtin factory and will cause QSystemTrayIconPrivate to recreate their
+ * 'sys' instances if the plugin availability changes.
+ */
+class QSystemTrayIconSysFactory : public QObject
 {
-    friend class QSystemTrayIconPrivate;
-
+    Q_OBJECT
 public:
-    QSystemTrayIconSys(QSystemTrayIcon *q);
-    ~QSystemTrayIconSys();
-    enum {
-        SYSTEM_TRAY_REQUEST_DOCK = 0,
-        SYSTEM_TRAY_BEGIN_MESSAGE = 1,
-        SYSTEM_TRAY_CANCEL_MESSAGE =2
-    };
-
-    void addToTray();
-    void updateIcon();
-    XVisualInfo* getSysTrayVisualInfo();
-
-    // QObject::event is public but QWidget's ::event() re-implementation
-    // is protected ;(
-    inline bool deliverToolTipEvent(QEvent *e)
-    { return QWidget::event(e); }
-
-    static Window sysTrayWindow;
-    static QList<QSystemTrayIconSys *> trayIcons;
-    static QCoreApplication::EventFilter oldEventFilter;
-    static bool sysTrayTracker(void *message, long *result);
-    static Window locateSystemTray();
-    static Atom sysTraySelection;
-    static XVisualInfo sysTrayVisual;
+    QSystemTrayIconSysFactory();
+    void registerSystemTrayIconPrivate(QSystemTrayIconPrivate *iconPrivate);
+    void unregisterSystemTrayIconPrivate(QSystemTrayIconPrivate *iconPrivate);
 
-protected:
-    void paintEvent(QPaintEvent *pe);
-    void resizeEvent(QResizeEvent *re);
-    bool x11Event(XEvent *event);
-    void mousePressEvent(QMouseEvent *event);
-    void mouseDoubleClickEvent(QMouseEvent *event);
-#ifndef QT_NO_WHEELEVENT
-    void wheelEvent(QWheelEvent *event);
-#endif
-    bool event(QEvent *e);
+    QAbstractSystemTrayIconSys *create(QSystemTrayIcon *) const;
+
+    bool isAvailable() const;
+
+private Q_SLOTS:
+    void refreshTrayIconPrivates();
 
 private:
-    QPixmap background;
-    QSystemTrayIcon *q;
-    Colormap colormap;
+    QSystemTrayIconSysFactoryInterface *factory() const;
+    void loadPluginFactory();
+
+    QSystemTrayIconSysFactoryInterface *pluginFactory;
+    QSet<QSystemTrayIconPrivate *> trayIconPrivates;
 };
-#endif // Q_WS_X11
+#endif
 
 QT_END_NAMESPACE
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon_x11.cpp qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon_x11.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qsystemtrayicon_x11.cpp	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qsystemtrayicon_x11.cpp	2017-09-26 08:03:15.860081103 +0000
@@ -38,311 +38,122 @@
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include <private/qfactoryloader_p.h>
 
-#include "private/qt_x11_p.h"
-#include "qlabel.h"
-#include "qx11info_x11.h"
-#include "qpainter.h"
-#include "qpixmap.h"
-#include "qbitmap.h"
-#include "qevent.h"
-#include "qapplication.h"
-#include "qlist.h"
-#include "qmenu.h"
-#include "qtimer.h"
 #include "qsystemtrayicon_p.h"
-#include "qpaintengine.h"
+#include "qabstractsystemtrayiconsys_p.h"
+#include "qcoreapplication.h"
+#include "qxembedsystemtrayicon_x11_p.h"
 
-#ifndef QT_NO_SYSTEMTRAYICON
 QT_BEGIN_NAMESPACE
 
-Window QSystemTrayIconSys::sysTrayWindow = XNone;
-QList<QSystemTrayIconSys *> QSystemTrayIconSys::trayIcons;
-QCoreApplication::EventFilter QSystemTrayIconSys::oldEventFilter = 0;
-Atom QSystemTrayIconSys::sysTraySelection = XNone;
-XVisualInfo QSystemTrayIconSys::sysTrayVisual = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-
-// Locate the system tray
-Window QSystemTrayIconSys::locateSystemTray()
-{
-    Display *display = QX11Info::display();
-    if (sysTraySelection == XNone) {
-        int screen = QX11Info::appScreen();
-        QString net_sys_tray = QString::fromLatin1("_NET_SYSTEM_TRAY_S%1").arg(screen);
-        sysTraySelection = XInternAtom(display, net_sys_tray.toLatin1(), False);
-    }
-
-    return XGetSelectionOwner(QX11Info::display(), sysTraySelection);
-}
+Q_GLOBAL_STATIC(QSystemTrayIconSysFactory, qt_guiSystemTrayIconSysFactory)
 
-XVisualInfo* QSystemTrayIconSys::getSysTrayVisualInfo()
+QSystemTrayIconSysFactory::QSystemTrayIconSysFactory()
+: pluginFactory(0)
 {
-    Display *display = QX11Info::display();
-
-    if (!sysTrayVisual.visual) {
-        Window win = locateSystemTray();
-        if (win != XNone) {
-            Atom actual_type;
-            int actual_format;
-            ulong nitems, bytes_remaining;
-            uchar *data = 0;
-            int result = XGetWindowProperty(display, win, ATOM(_NET_SYSTEM_TRAY_VISUAL), 0, 1,
-                                            False, XA_VISUALID, &actual_type,
-                                            &actual_format, &nitems, &bytes_remaining, &data);
-            VisualID vid = 0;
-            if (result == Success && data && actual_type == XA_VISUALID && actual_format == 32 &&
-                nitems == 1 && bytes_remaining == 0)
-                vid = *(VisualID*)data;
-            if (data)
-                XFree(data);
-            if (vid == 0)
-                return 0;
-
-            uint mask = VisualIDMask;
-            XVisualInfo *vi, rvi;
-            int count;
-            rvi.visualid = vid;
-            vi = XGetVisualInfo(display, mask, &rvi, &count);
-            if (vi) {
-                sysTrayVisual = vi[0];
-                XFree((char*)vi);
-            }
-            if (sysTrayVisual.depth != 32)
-                memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
-        }
-    }
-
-    return sysTrayVisual.visual ? &sysTrayVisual : 0;
 }
 
-bool QSystemTrayIconSys::sysTrayTracker(void *message, long *result)
+void QSystemTrayIconSysFactory::loadPluginFactory()
 {
-    bool retval = false;
-    if (QSystemTrayIconSys::oldEventFilter)
-        retval = QSystemTrayIconSys::oldEventFilter(message, result);
-
-    if (trayIcons.isEmpty())
-        return retval;
-
-    Display *display = QX11Info::display();
-    XEvent *ev = (XEvent *)message;
-    if  (ev->type == DestroyNotify && ev->xany.window == sysTrayWindow) {
-	sysTrayWindow = locateSystemTray();
-        memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
-        for (int i = 0; i < trayIcons.count(); i++) {
-            if (sysTrayWindow == XNone) {
-	        QBalloonTip::hideBalloon();
-                trayIcons[i]->hide(); // still no luck
-                trayIcons[i]->destroy();
-                trayIcons[i]->create();
-	    } else
-                trayIcons[i]->addToTray(); // add it to the new tray
-        }
-        retval = true;
-    } else if (ev->type == ClientMessage && sysTrayWindow == XNone) {
-        static Atom manager_atom = XInternAtom(display, "MANAGER", False);
-        XClientMessageEvent *cm = (XClientMessageEvent *)message;
-        if ((cm->message_type == manager_atom) && ((Atom)cm->data.l[1] == sysTraySelection)) {
-	    sysTrayWindow = cm->data.l[2];
-            memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
-	    XSelectInput(display, sysTrayWindow, StructureNotifyMask);
-            for (int i = 0; i < trayIcons.count(); i++) {
-                trayIcons[i]->addToTray();
-            }
-            retval = true;
-        }
-    } else if (ev->type == PropertyNotify && ev->xproperty.atom == ATOM(_NET_SYSTEM_TRAY_VISUAL) &&
-               ev->xproperty.window == sysTrayWindow) {
-        memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
-        for (int i = 0; i < trayIcons.count(); i++) {
-            trayIcons[i]->addToTray();
-        }
-    }
-
-    return retval;
-}
-
-QSystemTrayIconSys::QSystemTrayIconSys(QSystemTrayIcon *q)
-    : QWidget(0, Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint),
-      q(q), colormap(0)
-{
-    setAttribute(Qt::WA_AlwaysShowToolTips);
-    setAttribute(Qt::WA_QuitOnClose, false);
-    setAttribute(Qt::WA_NoSystemBackground, true);
-    setAttribute(Qt::WA_PaintOnScreen);
-
-    static bool eventFilterAdded = false;
-    Display *display = QX11Info::display();
-    if (!eventFilterAdded) {
-        oldEventFilter = qApp->setEventFilter(sysTrayTracker);
-	eventFilterAdded = true;
-	Window root = QX11Info::appRootWindow();
-        XWindowAttributes attr;
-        XGetWindowAttributes(display, root, &attr);
-        if ((attr.your_event_mask & StructureNotifyMask) != StructureNotifyMask) {
-            (void) QApplication::desktop(); // lame trick to ensure our event mask is not overridden
-            XSelectInput(display, root, attr.your_event_mask | StructureNotifyMask); // for MANAGER selection
-        }
+    if (pluginFactory) {
+        return;
     }
-    if (trayIcons.isEmpty()) {
-        sysTrayWindow = locateSystemTray();
-	if (sysTrayWindow != XNone)
-	    XSelectInput(display, sysTrayWindow, StructureNotifyMask); // track tray events
+#ifndef QT_NO_LIBRARY
+    QFactoryLoader loader(QSystemTrayIconSysFactoryInterface_iid, QLatin1String("/systemtrayicon"));
+    pluginFactory = qobject_cast<QSystemTrayIconSysFactoryInterface *>(loader.instance(QLatin1String("default")));
+    if (pluginFactory) {
+        // Set parent to ensure factory destructor is called when application
+        // is closed
+        pluginFactory->setParent(QCoreApplication::instance());
+        connect(pluginFactory, SIGNAL(availableChanged(bool)), SLOT(refreshTrayIconPrivates()));
     }
-    trayIcons.append(this);
-    setMouseTracking(true);
-#ifndef QT_NO_TOOLTIP
-    setToolTip(q->toolTip());
-#endif
-    if (sysTrayWindow != XNone)
-        addToTray();
+#endif // QT_NO_LIBRARY
 }
 
-QSystemTrayIconSys::~QSystemTrayIconSys()
+QSystemTrayIconSysFactoryInterface *QSystemTrayIconSysFactory::factory() const
 {
-    trayIcons.removeAt(trayIcons.indexOf(this));
-    Display *display = QX11Info::display();
-    if (trayIcons.isEmpty()) {
-        if (sysTrayWindow == XNone)
-            return;
-        if (display)
-            XSelectInput(display, sysTrayWindow, 0); // stop tracking the tray
-        sysTrayWindow = XNone;
+    if (!pluginFactory) {
+        const_cast<QSystemTrayIconSysFactory*>(this)->loadPluginFactory();
     }
-    if (colormap)
-        XFreeColormap(display, colormap);
+    if (pluginFactory && pluginFactory->isAvailable()) {
+        return pluginFactory;
+    }
+    static QXEmbedSystemTrayIconSysFactory def;
+    return def.isAvailable() ? &def : 0;
 }
 
-void QSystemTrayIconSys::addToTray()
+void QSystemTrayIconSysFactory::refreshTrayIconPrivates()
 {
-    Q_ASSERT(sysTrayWindow != XNone);
-    Display *display = QX11Info::display();
-
-    XVisualInfo *vi = getSysTrayVisualInfo();
-    if (vi && vi->visual) {
-        Window root = RootWindow(display, vi->screen);
-        Window p = root;
-        if (QWidget *pw = parentWidget())
-            p = pw->effectiveWinId();
-        colormap = XCreateColormap(display, root, vi->visual, AllocNone);
-        XSetWindowAttributes wsa;
-        wsa.background_pixmap = 0;
-        wsa.colormap = colormap;
-        wsa.background_pixel = 0;
-        wsa.border_pixel = 0;
-        Window wid = XCreateWindow(display, p, -1, -1, 1, 1,
-                                   0, vi->depth, InputOutput, vi->visual,
-                                   CWBackPixmap|CWBackPixel|CWBorderPixel|CWColormap, &wsa);
-        create(wid);
-    } else {
-        XSetWindowBackgroundPixmap(display, winId(), ParentRelative);
-    }
-
-    // GNOME, NET WM Specification
-    static Atom netwm_tray_atom = XInternAtom(display, "_NET_SYSTEM_TRAY_OPCODE", False);
-    long l[5] = { CurrentTime, SYSTEM_TRAY_REQUEST_DOCK, static_cast<long>(winId()), 0, 0 };
-    XEvent ev;
-    memset(&ev, 0, sizeof(ev));
-    ev.xclient.type = ClientMessage;
-    ev.xclient.window = sysTrayWindow;
-    ev.xclient.message_type = netwm_tray_atom;
-    ev.xclient.format = 32;
-    memcpy((char *)&ev.xclient.data, (const char *) l, sizeof(l));
-    XSendEvent(display, sysTrayWindow, False, 0, &ev);
-    setMinimumSize(22, 22); // required at least on GNOME
-}
-
-void QSystemTrayIconSys::updateIcon()
-{
-    update();
-}
-
-void QSystemTrayIconSys::resizeEvent(QResizeEvent *re)
-{
-     QWidget::resizeEvent(re);
-     updateIcon();
-}
-
-void QSystemTrayIconSys::paintEvent(QPaintEvent*)
-{
-    QPainter p(this);
-    if (!getSysTrayVisualInfo()) {
-        const QRegion oldSystemClip = p.paintEngine()->systemClip();
-        const QRect clearedRect = oldSystemClip.boundingRect();
-        XClearArea(QX11Info::display(), winId(), clearedRect.x(), clearedRect.y(),
-                   clearedRect.width(), clearedRect.height(), False);
-        QPaintEngine *pe = p.paintEngine();
-        pe->setSystemClip(clearedRect);
-        q->icon().paint(&p, rect());
-        pe->setSystemClip(oldSystemClip);
-    } else {
-        p.setCompositionMode(QPainter::CompositionMode_Source);
-        p.fillRect(rect(), Qt::transparent);
-        p.setCompositionMode(QPainter::CompositionMode_SourceOver);
-        q->icon().paint(&p, rect());
+    Q_FOREACH(QSystemTrayIconPrivate *trayIconPrivate, trayIconPrivates) {
+        if (trayIconPrivate->sys) {
+            delete trayIconPrivate->sys;
+            trayIconPrivate->sys = 0;
+        }
+        // When visible is true, sys is usually not 0 but it can be 0 if the
+        // call to install_sys() failed.
+        if (trayIconPrivate->visible) {
+            trayIconPrivate->install_sys();
+        }
     }
 }
 
-void QSystemTrayIconSys::mousePressEvent(QMouseEvent *ev)
+void QSystemTrayIconSysFactory::registerSystemTrayIconPrivate(QSystemTrayIconPrivate* trayIconPrivate)
 {
-    QPoint globalPos = ev->globalPos();
-    if (ev->button() == Qt::RightButton && q->contextMenu())
-        q->contextMenu()->popup(globalPos);
-
-    if (QBalloonTip::isBalloonVisible()) {
-        emit q->messageClicked();
-        QBalloonTip::hideBalloon();
-    }
-
-    if (ev->button() == Qt::LeftButton)
-        emit q->activated(QSystemTrayIcon::Trigger);
-    else if (ev->button() == Qt::RightButton)
-        emit q->activated(QSystemTrayIcon::Context);
-    else if (ev->button() == Qt::MidButton)
-        emit q->activated(QSystemTrayIcon::MiddleClick);
+    trayIconPrivates.insert(trayIconPrivate);
 }
 
-void QSystemTrayIconSys::mouseDoubleClickEvent(QMouseEvent *ev)
+void QSystemTrayIconSysFactory::unregisterSystemTrayIconPrivate(QSystemTrayIconPrivate* trayIconPrivate)
 {
-    if (ev->button() == Qt::LeftButton)
-        emit q->activated(QSystemTrayIcon::DoubleClick);
+    trayIconPrivates.remove(trayIconPrivate);
 }
 
-#ifndef QT_NO_WHEELEVENT
-void QSystemTrayIconSys::wheelEvent(QWheelEvent *e)
+QAbstractSystemTrayIconSys *QSystemTrayIconSysFactory::create(QSystemTrayIcon *trayIcon) const
 {
-    QApplication::sendEvent(q, e);
+    QSystemTrayIconSysFactoryInterface *f = factory();
+    if (!f) {
+        qWarning("No systemtrayicon available");
+        return 0;
+    }
+    return f->create(trayIcon);
 }
-#endif
 
-bool QSystemTrayIconSys::event(QEvent *e)
+bool QSystemTrayIconSysFactory::isAvailable() const
 {
-    if (e->type() == QEvent::ToolTip) {
-        return QApplication::sendEvent(q, e);
-    }
-    return QWidget::event(e);
+    return factory();
 }
 
-bool QSystemTrayIconSys::x11Event(XEvent *event)
+////////////////////////////////////////////////
+QSystemTrayIconPrivate::~QSystemTrayIconPrivate()
 {
-    if (event->type == ReparentNotify)
-        show();
-    return QWidget::x11Event(event);
+    qt_guiSystemTrayIconSysFactory()->unregisterSystemTrayIconPrivate(this);
+    delete sys;
 }
 
-////////////////////////////////////////////////////////////////////////////
 void QSystemTrayIconPrivate::install_sys()
 {
     Q_Q(QSystemTrayIcon);
-    if (!sys)
-        sys = new QSystemTrayIconSys(q);
+    if (!sys) {
+        // Register ourself even if create() fails: our "sys" will get created
+        // later by refreshTrayIconPrivates() if a systemtray becomes
+        // available. This situation can happen for applications which are
+        // started at login time, while the desktop itself is starting up.
+        qt_guiSystemTrayIconSysFactory()->registerSystemTrayIconPrivate(this);
+        sys = qt_guiSystemTrayIconSysFactory()->create(q);
+        if (!sys) {
+            return;
+        }
+    }
+    sys->updateVisibility();
 }
 
 QRect QSystemTrayIconPrivate::geometry_sys() const
 {
-    if (!sys)
-	return QRect();
-    return QRect(sys->mapToGlobal(QPoint(0, 0)), sys->size());
+    if (!sys || !visible)
+        return QRect();
+    return sys->geometry();
 }
 
 void QSystemTrayIconPrivate::remove_sys()
@@ -350,35 +161,35 @@
     if (!sys)
         return;
     QBalloonTip::hideBalloon();
-    sys->hide(); // this should do the trick, but...
-    delete sys; // wm may resize system tray only for DestroyEvents
-    sys = 0;
+    sys->updateVisibility();
 }
 
 void QSystemTrayIconPrivate::updateIcon_sys()
 {
-    if (!sys)
+    if (!sys || !visible)
         return;
     sys->updateIcon();
 }
 
 void QSystemTrayIconPrivate::updateMenu_sys()
 {
-
+    if (!sys || !visible)
+        return;
+    sys->updateMenu();
 }
 
 void QSystemTrayIconPrivate::updateToolTip_sys()
 {
-    if (!sys)
+    if (!sys || !visible)
         return;
 #ifndef QT_NO_TOOLTIP
-    sys->setToolTip(toolTip);
+    sys->updateToolTip();
 #endif
 }
 
 bool QSystemTrayIconPrivate::isSystemTrayAvailable_sys()
 {
-    return QSystemTrayIconSys::locateSystemTray() != XNone;
+    return qt_guiSystemTrayIconSysFactory()->isAvailable();
 }
 
 bool QSystemTrayIconPrivate::supportsMessages_sys()
@@ -389,12 +200,9 @@
 void QSystemTrayIconPrivate::showMessage_sys(const QString &message, const QString &title,
                                    QSystemTrayIcon::MessageIcon icon, int msecs)
 {
-    if (!sys)
+    if (!sys || !visible)
         return;
-    QPoint g = sys->mapToGlobal(QPoint(0, 0));
-    QBalloonTip::showBalloon(icon, message, title, sys->q,
-                             QPoint(g.x() + sys->width()/2, g.y() + sys->height()/2),
-                             msecs);
+    sys->showMessage(message, title, icon, msecs);
 }
 
 QT_END_NAMESPACE
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qxembedsystemtrayicon_x11.cpp qt-everywhere-opensource-src-4.8.7/src/gui/util/qxembedsystemtrayicon_x11.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qxembedsystemtrayicon_x11.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qxembedsystemtrayicon_x11.cpp	2017-09-26 08:03:15.863414436 +0000
@@ -0,0 +1,469 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qxembedsystemtrayicon_x11_p.h"
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include "private/qt_x11_p.h"
+#include "qapplication.h"
+#include "qevent.h"
+#include "qlist.h"
+#include "qmenu.h"
+#include "qpainter.h"
+#include "qpaintengine.h"
+#include "qsystemtrayicon_p.h"
+#include "qx11info_x11.h"
+
+QT_BEGIN_INCLUDE_NAMESPACE
+#include <QtCore/qcoreapplication.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+QT_END_INCLUDE_NAMESPACE
+
+QT_BEGIN_NAMESPACE
+
+class QSystemTrayIconWidget : public QWidget
+{
+public:
+    QSystemTrayIconWidget(QSystemTrayIcon *q, QXEmbedSystemTrayIconSys *s);
+    ~QSystemTrayIconWidget();
+
+    static Window locateSystemTray();
+
+protected:
+    void paintEvent(QPaintEvent *pe);
+    void resizeEvent(QResizeEvent *re);
+    bool x11Event(XEvent *event);
+    void mousePressEvent(QMouseEvent *event);
+    void mouseDoubleClickEvent(QMouseEvent *event);
+#ifndef QT_NO_WHEELEVENT
+    void wheelEvent(QWheelEvent *event);
+#endif
+    bool event(QEvent *e);
+
+private:
+    enum {
+        SYSTEM_TRAY_REQUEST_DOCK = 0,
+        SYSTEM_TRAY_BEGIN_MESSAGE = 1,
+        SYSTEM_TRAY_CANCEL_MESSAGE =2
+    };
+
+    void addToTray();
+    static XVisualInfo* getSysTrayVisualInfo();
+
+    static Window sysTrayWindow;
+    static QList<QSystemTrayIconWidget *> trayIcons;
+    static QCoreApplication::EventFilter oldEventFilter;
+    static bool sysTrayTracker(void *message, long *result);
+    static Atom sysTraySelection;
+    static XVisualInfo sysTrayVisual;
+
+    QSystemTrayIcon *q;
+    QXEmbedSystemTrayIconSys *sys;
+    Colormap colormap;
+};
+
+Window QSystemTrayIconWidget::sysTrayWindow = XNone;
+QList<QSystemTrayIconWidget *> QSystemTrayIconWidget::trayIcons;
+QCoreApplication::EventFilter QSystemTrayIconWidget::oldEventFilter = 0;
+Atom QSystemTrayIconWidget::sysTraySelection = XNone;
+XVisualInfo QSystemTrayIconWidget::sysTrayVisual = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+QSystemTrayIconWidget::QSystemTrayIconWidget(QSystemTrayIcon* q, QXEmbedSystemTrayIconSys* sys)
+: QWidget(0, Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint)
+, q(q)
+, sys(sys)
+, colormap(0)
+{
+    setAttribute(Qt::WA_AlwaysShowToolTips);
+    setAttribute(Qt::WA_QuitOnClose, false);
+    setAttribute(Qt::WA_NoSystemBackground, true);
+    setAttribute(Qt::WA_PaintOnScreen);
+    setMouseTracking(true);
+#ifndef QT_NO_TOOLTIP
+    setToolTip(q->toolTip());
+#endif
+
+    static bool eventFilterAdded = false;
+    Display *display = QX11Info::display();
+    if (!eventFilterAdded) {
+        oldEventFilter = qApp->setEventFilter(sysTrayTracker);
+        eventFilterAdded = true;
+        Window root = QX11Info::appRootWindow();
+        XWindowAttributes attr;
+        XGetWindowAttributes(display, root, &attr);
+        if ((attr.your_event_mask & StructureNotifyMask) != StructureNotifyMask) {
+            (void) QApplication::desktop(); // lame trick to ensure our event mask is not overridden
+            XSelectInput(display, root, attr.your_event_mask | StructureNotifyMask); // for MANAGER selection
+        }
+    }
+    if (trayIcons.isEmpty()) {
+        sysTrayWindow = locateSystemTray();
+        if (sysTrayWindow != XNone)
+            XSelectInput(display, sysTrayWindow, StructureNotifyMask); // track tray events
+    }
+    trayIcons.append(this);
+    if (sysTrayWindow != XNone)
+        addToTray();
+}
+
+QSystemTrayIconWidget::~QSystemTrayIconWidget()
+{
+    trayIcons.removeAt(trayIcons.indexOf(this));
+    Display *display = QX11Info::display();
+    if (trayIcons.isEmpty()) {
+        if (sysTrayWindow == XNone)
+            return;
+        if (display)
+            XSelectInput(display, sysTrayWindow, 0); // stop tracking the tray
+        sysTrayWindow = XNone;
+    }
+    if (colormap)
+        XFreeColormap(display, colormap);
+}
+
+void QSystemTrayIconWidget::resizeEvent(QResizeEvent *re)
+{
+    QWidget::resizeEvent(re);
+    update();
+}
+
+void QSystemTrayIconWidget::paintEvent(QPaintEvent*)
+{
+    QPainter p(this);
+    if (!getSysTrayVisualInfo()) {
+        const QRegion oldSystemClip = p.paintEngine()->systemClip();
+        const QRect clearedRect = oldSystemClip.boundingRect();
+        XClearArea(QX11Info::display(), winId(), clearedRect.x(), clearedRect.y(),
+                   clearedRect.width(), clearedRect.height(), False);
+        QPaintEngine *pe = p.paintEngine();
+        pe->setSystemClip(clearedRect);
+        q->icon().paint(&p, rect());
+        pe->setSystemClip(oldSystemClip);
+    } else {
+        p.setCompositionMode(QPainter::CompositionMode_Source);
+        p.fillRect(rect(), Qt::transparent);
+        p.setCompositionMode(QPainter::CompositionMode_SourceOver);
+        q->icon().paint(&p, rect());
+    }
+}
+
+void QSystemTrayIconWidget::mousePressEvent(QMouseEvent *ev)
+{
+    QPoint globalPos = ev->globalPos();
+    if (ev->button() == Qt::RightButton && q->contextMenu())
+        q->contextMenu()->popup(globalPos);
+
+    if (QBalloonTip::isBalloonVisible()) {
+        QMetaObject::invokeMethod(q, "messageClicked");
+        QBalloonTip::hideBalloon();
+    }
+
+    if (ev->button() == Qt::LeftButton)
+        qtsystray_sendActivated(q, QSystemTrayIcon::Trigger);
+    else if (ev->button() == Qt::RightButton)
+        qtsystray_sendActivated(q, QSystemTrayIcon::Context);
+    else if (ev->button() == Qt::MidButton)
+        qtsystray_sendActivated(q, QSystemTrayIcon::MiddleClick);
+}
+
+void QSystemTrayIconWidget::mouseDoubleClickEvent(QMouseEvent *ev)
+{
+    if (ev->button() == Qt::LeftButton)
+        qtsystray_sendActivated(q, QSystemTrayIcon::DoubleClick);
+}
+
+#ifndef QT_NO_WHEELEVENT
+void QSystemTrayIconWidget::wheelEvent(QWheelEvent *e)
+{
+    sys->sendWheelEventToTrayIcon(e->delta(), e->orientation());
+}
+#endif
+
+bool QSystemTrayIconWidget::event(QEvent *e)
+{
+    if (e->type() == QEvent::ToolTip) {
+        sys->sendToolTipEventToTrayIcon();
+    }
+    return QWidget::event(e);
+}
+
+bool QSystemTrayIconWidget::x11Event(XEvent *event)
+{
+    if (event->type == ReparentNotify)
+        show();
+    return QWidget::x11Event(event);
+}
+
+// Locate the system tray
+Window QSystemTrayIconWidget::locateSystemTray()
+{
+    Display *display = QX11Info::display();
+    if (sysTraySelection == XNone) {
+        int screen = QX11Info::appScreen();
+        QString net_sys_tray = QString::fromLatin1("_NET_SYSTEM_TRAY_S%1").arg(screen);
+        sysTraySelection = XInternAtom(display, net_sys_tray.toLatin1(), False);
+    }
+
+    return XGetSelectionOwner(QX11Info::display(), sysTraySelection);
+}
+
+XVisualInfo* QSystemTrayIconWidget::getSysTrayVisualInfo()
+{
+    Display *display = QX11Info::display();
+
+    if (!sysTrayVisual.visual) {
+        Window win = locateSystemTray();
+        if (win != XNone) {
+            Atom actual_type;
+            int actual_format;
+            ulong nitems, bytes_remaining;
+            uchar *data = 0;
+            int result = XGetWindowProperty(display, win, ATOM(_NET_SYSTEM_TRAY_VISUAL), 0, 1,
+                                            False, XA_VISUALID, &actual_type,
+                                            &actual_format, &nitems, &bytes_remaining, &data);
+            VisualID vid = 0;
+            if (result == Success && data && actual_type == XA_VISUALID && actual_format == 32 &&
+                nitems == 1 && bytes_remaining == 0)
+                vid = *(VisualID*)data;
+            if (data)
+                XFree(data);
+            if (vid == 0)
+                return 0;
+
+            uint mask = VisualIDMask;
+            XVisualInfo *vi, rvi;
+            int count;
+            rvi.visualid = vid;
+            vi = XGetVisualInfo(display, mask, &rvi, &count);
+            if (vi) {
+                sysTrayVisual = vi[0];
+                XFree((char*)vi);
+            }
+            if (sysTrayVisual.depth != 32)
+                memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
+        }
+    }
+
+    return sysTrayVisual.visual ? &sysTrayVisual : 0;
+}
+
+bool QSystemTrayIconWidget::sysTrayTracker(void *message, long *result)
+{
+    bool retval = false;
+    if (QSystemTrayIconWidget::oldEventFilter)
+        retval = QSystemTrayIconWidget::oldEventFilter(message, result);
+
+    if (trayIcons.isEmpty())
+        return retval;
+
+    Display *display = QX11Info::display();
+    XEvent *ev = (XEvent *)message;
+    if  (ev->type == DestroyNotify && ev->xany.window == sysTrayWindow) {
+        sysTrayWindow = locateSystemTray();
+        memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
+        for (int i = 0; i < trayIcons.count(); i++) {
+            if (sysTrayWindow == XNone) {
+                QBalloonTip::hideBalloon();
+                trayIcons[i]->hide(); // still no luck
+                trayIcons[i]->destroy();
+                trayIcons[i]->create();
+            } else
+                trayIcons[i]->addToTray(); // add it to the new tray
+        }
+        retval = true;
+    } else if (ev->type == ClientMessage && sysTrayWindow == XNone) {
+        static Atom manager_atom = XInternAtom(display, "MANAGER", False);
+        XClientMessageEvent *cm = (XClientMessageEvent *)message;
+        if ((cm->message_type == manager_atom) && ((Atom)cm->data.l[1] == sysTraySelection)) {
+            sysTrayWindow = cm->data.l[2];
+            memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
+            XSelectInput(display, sysTrayWindow, StructureNotifyMask);
+            for (int i = 0; i < trayIcons.count(); i++) {
+                trayIcons[i]->addToTray();
+            }
+            retval = true;
+        }
+    } else if (ev->type == PropertyNotify && ev->xproperty.atom == ATOM(_NET_SYSTEM_TRAY_VISUAL) &&
+               ev->xproperty.window == sysTrayWindow) {
+        memset(&sysTrayVisual, 0, sizeof(sysTrayVisual));
+        for (int i = 0; i < trayIcons.count(); i++) {
+            trayIcons[i]->addToTray();
+        }
+    }
+
+    return retval;
+}
+
+void QSystemTrayIconWidget::addToTray()
+{
+    Q_ASSERT(sysTrayWindow != XNone);
+    Display *display = QX11Info::display();
+
+    XVisualInfo *vi = getSysTrayVisualInfo();
+    if (vi && vi->visual) {
+        Window root = RootWindow(display, vi->screen);
+        Window p = root;
+        if (QWidget *pw = parentWidget())
+            p = pw->effectiveWinId();
+        colormap = XCreateColormap(display, root, vi->visual, AllocNone);
+        XSetWindowAttributes wsa;
+        wsa.background_pixmap = 0;
+        wsa.colormap = colormap;
+        wsa.background_pixel = 0;
+        wsa.border_pixel = 0;
+        Window wid = XCreateWindow(display, p, -1, -1, 1, 1,
+                                   0, vi->depth, InputOutput, vi->visual,
+                                   CWBackPixmap|CWBackPixel|CWBorderPixel|CWColormap, &wsa);
+        create(wid);
+    } else {
+        XSetWindowBackgroundPixmap(display, winId(), ParentRelative);
+    }
+
+    // GNOME, NET WM Specification
+    static Atom netwm_tray_atom = XInternAtom(display, "_NET_SYSTEM_TRAY_OPCODE", False);
+    long l[5] = { CurrentTime, SYSTEM_TRAY_REQUEST_DOCK, static_cast<long>(winId()), 0, 0 };
+    XEvent ev;
+    memset(&ev, 0, sizeof(ev));
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = sysTrayWindow;
+    ev.xclient.message_type = netwm_tray_atom;
+    ev.xclient.format = 32;
+    memcpy((char *)&ev.xclient.data, (const char *) l, sizeof(l));
+    XSendEvent(display, sysTrayWindow, False, 0, &ev);
+    setMinimumSize(22, 22); // required at least on GNOME
+}
+
+////////////////////////////////////////////////////////////////////////////
+QXEmbedSystemTrayIconSys::QXEmbedSystemTrayIconSys(QSystemTrayIcon *q)
+: QAbstractSystemTrayIconSys(q)
+, widget(0)
+{
+}
+
+QXEmbedSystemTrayIconSys::~QXEmbedSystemTrayIconSys()
+{
+    delete widget;
+}
+
+QRect QXEmbedSystemTrayIconSys::geometry() const
+{
+    if (!widget)
+        return QRect();
+    return QRect(widget->mapToGlobal(QPoint(0, 0)), widget->size());
+}
+
+void QXEmbedSystemTrayIconSys::updateIcon()
+{
+    if (!widget)
+        return;
+    widget->update();
+}
+
+void QXEmbedSystemTrayIconSys::updateToolTip()
+{
+    if (!widget)
+        return;
+    widget->setToolTip(trayIcon->toolTip());
+}
+
+void QXEmbedSystemTrayIconSys::showMessage(const QString &message, const QString &title,
+                                   QSystemTrayIcon::MessageIcon icon, int msecs)
+{
+    if (!widget)
+        return;
+    QPoint point = geometry().center();
+    QBalloonTip::showBalloon(icon, message, title, trayIcon, point, msecs);
+}
+
+void QXEmbedSystemTrayIconSys::updateVisibility()
+{
+    bool visible = trayIcon->isVisible();
+    if (visible && !widget)
+        widget = new QSystemTrayIconWidget(trayIcon, this);
+    else if (!visible && widget) {
+        delete widget;
+        widget = 0;
+    }
+}
+
+void QXEmbedSystemTrayIconSys::sendToolTipEventToTrayIcon()
+{
+#ifndef QT_NO_TOOLTIP
+    // Pass the event through QSystemTrayIcon so that it gets a chance to
+    // update the tooltip, then asks widget to show the tooltip
+    Q_ASSERT(widget);
+    QPoint globalPos = QCursor::pos();
+    QPoint pos = widget->mapFromGlobal(globalPos);
+    QHelpEvent event(QEvent::ToolTip, pos, globalPos);
+    QApplication::sendEvent(trayIcon, &event);
+#endif
+}
+
+void QXEmbedSystemTrayIconSys::sendWheelEventToTrayIcon(int delta, Qt::Orientation orientation)
+{
+#ifndef QT_NO_WHEELEVENT
+    Q_ASSERT(widget);
+    QPoint globalPos = QCursor::pos();
+    QPoint pos = widget->mapFromGlobal(globalPos);
+    QWheelEvent event(pos, globalPos, delta, Qt::NoButton, Qt::NoModifier, orientation);
+    QApplication::sendEvent(trayIcon, &event);
+#endif
+}
+
+void QXEmbedSystemTrayIconSys::updateMenu()
+{
+}
+
+/////////////////////////////////////////////////////////////
+QAbstractSystemTrayIconSys * QXEmbedSystemTrayIconSysFactory::create(QSystemTrayIcon *icon)
+{
+    return new QXEmbedSystemTrayIconSys(icon);
+}
+
+bool QXEmbedSystemTrayIconSysFactory::isAvailable() const
+{
+    return QSystemTrayIconWidget::locateSystemTray() != XNone;
+}
+
+QT_END_NAMESPACE
+#endif //QT_NO_SYSTEMTRAYICON
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qxembedsystemtrayicon_x11_p.h qt-everywhere-opensource-src-4.8.7/src/gui/util/qxembedsystemtrayicon_x11_p.h
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/qxembedsystemtrayicon_x11_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/qxembedsystemtrayicon_x11_p.h	2017-09-26 08:03:15.863414436 +0000
@@ -0,0 +1,104 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXEMBEDSYSTEMTRAYICON_X11_P_H
+#define QXEMBEDSYSTEMTRAYICON_X11_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of a number of Qt sources files.  This header file may change from
+// version to version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+#include "qabstractsystemtrayiconsys_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QSystemTrayIconWidget;
+
+class QXEmbedSystemTrayIconSys : public QAbstractSystemTrayIconSys
+{
+public:
+    QXEmbedSystemTrayIconSys(QSystemTrayIcon *);
+    ~QXEmbedSystemTrayIconSys();
+
+    QRect geometry() const;
+
+    void updateVisibility();
+
+    void updateIcon();
+
+    void updateToolTip();
+
+    void updateMenu();
+
+    void showMessage(const QString &message, const QString &title,
+                     QSystemTrayIcon::MessageIcon icon, int msecs);
+
+private:
+    friend class QSystemTrayIconWidget;
+    QSystemTrayIconWidget *widget;
+
+    void sendToolTipEventToTrayIcon();
+
+    void sendWheelEventToTrayIcon(int delta, Qt::Orientation orientation);
+};
+
+struct QXEmbedSystemTrayIconSysFactory : public QSystemTrayIconSysFactoryInterface
+{
+    QAbstractSystemTrayIconSys * create(QSystemTrayIcon *trayIcon);
+    bool isAvailable() const;
+};
+
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SYSTEMTRAYICON
+
+#endif // QXEMBEDSYSTEMTRAYICON_X11_P_H
+
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/gui/util/util.pri qt-everywhere-opensource-src-4.8.7/src/gui/util/util.pri
--- qt-everywhere-opensource-src-4.8.7-original/src/gui/util/util.pri	2015-05-07 14:14:43.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/gui/util/util.pri	2017-09-26 08:03:15.863414436 +0000
@@ -29,8 +29,13 @@
 }
 
 unix:x11 {
+		HEADERS += \
+				util/qabstractsystemtrayiconsys_p.h \
+				util/qxembedsystemtrayicon_x11_p.h
 		SOURCES += \
-				util/qsystemtrayicon_x11.cpp
+				util/qabstractsystemtrayiconsys.cpp \
+				util/qsystemtrayicon_x11.cpp \
+				util/qxembedsystemtrayicon_x11.cpp
 }
 
 embedded|qpa {
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslcertificate.cpp qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslcertificate.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslcertificate.cpp	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslcertificate.cpp	2017-09-26 08:07:37.523423346 +0000
@@ -259,10 +259,10 @@
 QByteArray QSslCertificate::version() const
 {
     QMutexLocker lock(QMutexPool::globalInstanceGet(d.data()));
-    if (d->versionString.isEmpty() && d->x509)
+    if (d->versionString.isEmpty() && d->x509) {
         d->versionString =
-            QByteArray::number(qlonglong(q_ASN1_INTEGER_get(d->x509->cert_info->version)) + 1);
-
+	    QByteArray::number(qlonglong(q_X509_get_version(d->x509)) + 1);
+    }
     return d->versionString;
 }
 
@@ -276,7 +276,7 @@
 {
     QMutexLocker lock(QMutexPool::globalInstanceGet(d.data()));
     if (d->serialNumberString.isEmpty() && d->x509) {
-        ASN1_INTEGER *serialNumber = d->x509->cert_info->serialNumber;
+        ASN1_INTEGER *serialNumber = q_X509_get_serialNumber(d->x509);
         // if we cannot convert to a long, just output the hexadecimal number
         if (serialNumber->length > 4) {
             QByteArray hexString;
@@ -489,24 +489,33 @@
     QSslKey key;
 
     key.d->type = QSsl::PublicKey;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     X509_PUBKEY *xkey = d->x509->cert_info->key;
+#else
+    X509_PUBKEY *xkey = q_X509_get_X509_PUBKEY(d->x509);
+#endif
     EVP_PKEY *pkey = q_X509_PUBKEY_get(xkey);
     Q_ASSERT(pkey);
 
-    if (q_EVP_PKEY_type(pkey->type) == EVP_PKEY_RSA) {
+    int key_id;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+    key_id = q_EVP_PKEY_type(pkey->type);
+#else
+    key_id = q_EVP_PKEY_base_id(pkey);
+#endif
+    if (key_id == EVP_PKEY_RSA) {
         key.d->rsa = q_EVP_PKEY_get1_RSA(pkey);
         key.d->algorithm = QSsl::Rsa;
         key.d->isNull = false;
-    } else if (q_EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA) {
+    } else if (key_id == EVP_PKEY_DSA) {
         key.d->dsa = q_EVP_PKEY_get1_DSA(pkey);
         key.d->algorithm = QSsl::Dsa;
         key.d->isNull = false;
-    } else if (q_EVP_PKEY_type(pkey->type) == EVP_PKEY_DH) {
+    } else if (key_id == EVP_PKEY_DH) {
         // DH unsupported
     } else {
         // error?
     }
-
     q_EVP_PKEY_free(pkey);
     return key;
 }
@@ -687,7 +696,7 @@
         unsigned char *data = 0;
         int size = q_ASN1_STRING_to_UTF8(&data, q_X509_NAME_ENTRY_get_data(e));
         info[QString::fromUtf8(obj)] = QString::fromUtf8((char*)data, size);
-        q_CRYPTO_free(data);
+        q_OPENSSL_free(data);
     }
     return info;
 }
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslkey.cpp qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslkey.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslkey.cpp	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslkey.cpp	2017-09-26 08:07:37.473423345 +0000
@@ -321,8 +321,19 @@
 {
     if (d->isNull)
         return -1;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     return (d->algorithm == QSsl::Rsa)
            ? q_BN_num_bits(d->rsa->n) : q_BN_num_bits(d->dsa->p);
+#else
+    if (d->algorithm == QSsl::Rsa) {
+        return q_RSA_bits(d->rsa);
+    }else{
+        const BIGNUM *p = NULL;
+        q_DSA_get0_pqg(d->dsa, &p, NULL, NULL);
+	return q_BN_num_bits(p);
+    }
+#endif
+
 }
 
 /*!
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl.cpp qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl.cpp	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl.cpp	2017-09-26 08:07:37.473423345 +0000
@@ -93,6 +93,7 @@
 bool QSslSocketPrivate::s_loadedCiphersAndCerts = false;
 bool QSslSocketPrivate::s_loadRootCertsOnDemand = false;
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 /* \internal
 
     From OpenSSL's thread(3) manual page:
@@ -174,6 +175,8 @@
 }
 } // extern "C"
 
+#endif //OPENSSL_VERSION_NUMBER >= 0x10100000L
+
 QSslSocketBackendPrivate::QSslSocketBackendPrivate()
     : ssl(0),
       ctx(0),
@@ -222,9 +225,12 @@
             ciph.d->encryptionMethod = descriptionList.at(4).mid(4);
         ciph.d->exportable = (descriptionList.size() > 6 && descriptionList.at(6) == QLatin1String("export"));
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         ciph.d->bits = cipher->strength_bits;
         ciph.d->supportedBits = cipher->alg_bits;
-
+#else
+	ciph.d->bits = q_SSL_CIPHER_get_bits(cipher, &ciph.d->supportedBits);
+#endif
     }
     return ciph;
 }
@@ -267,7 +273,11 @@
 #endif
         break;
     case QSsl::SslV3:
+#ifndef OPENSSL_NO_SSL3
         ctx = q_SSL_CTX_new(client ? q_SSLv3_client_method() : q_SSLv3_server_method());
+#else
+        ctx = 0; // SSL 3 not supported by the system, but chosen deliberately -> error
+#endif
         break;
     case QSsl::SecureProtocols: // SslV2 will be disabled below
     case QSsl::TlsV1SslV3: // SslV2 will be disabled below
@@ -363,7 +373,7 @@
         //
         // See also: QSslContext::fromConfiguration()
         if (caCertificate.expiryDate() >= QDateTime::currentDateTime()) {
-            q_X509_STORE_add_cert(ctx->cert_store, (X509 *)caCertificate.handle());
+	  q_X509_STORE_add_cert(q_SSL_CTX_get_cert_store(ctx), (X509 *)caCertificate.handle());
         }
     }
 
@@ -500,8 +510,10 @@
 */
 void QSslSocketPrivate::deinitialize()
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     q_CRYPTO_set_id_callback(0);
     q_CRYPTO_set_locking_callback(0);
+#endif
 }
 
 /*!
@@ -522,13 +534,17 @@
         return false;
 
     // Check if the library itself needs to be initialized.
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     QMutexLocker locker(openssl_locks()->initLock());
+#endif
     if (!s_libraryLoaded) {
         s_libraryLoaded = true;
 
         // Initialize OpenSSL.
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         q_CRYPTO_set_id_callback(id_function);
         q_CRYPTO_set_locking_callback(locking_function);
+#endif
         if (q_SSL_library_init() != 1)
             return false;
         q_SSL_load_error_strings();
@@ -567,7 +583,9 @@
 
 void QSslSocketPrivate::ensureCiphersAndCertsLoaded()
 {
-    QMutexLocker locker(openssl_locks()->initLock());
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+  QMutexLocker locker(openssl_locks()->initLock());
+#endif
     if (s_loadedCiphersAndCerts)
         return;
     s_loadedCiphersAndCerts = true;
@@ -659,13 +677,18 @@
     STACK_OF(SSL_CIPHER) *supportedCiphers = q_SSL_get_ciphers(mySsl);
     for (int i = 0; i < q_sk_SSL_CIPHER_num(supportedCiphers); ++i) {
         if (SSL_CIPHER *cipher = q_sk_SSL_CIPHER_value(supportedCiphers, i)) {
-            if (cipher->valid) {
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+	  if (cipher->valid) {
+#endif
                 QSslCipher ciph = QSslSocketBackendPrivate::QSslCipher_from_SSL_CIPHER(cipher);
                 if (!ciph.isNull()) {
                     if (!ciph.name().toLower().startsWith(QLatin1String("adh")))
                         ciphers << ciph;
                 }
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
             }
+#endif
         }
     }
 
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl_symbols.cpp qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl_symbols.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl_symbols.cpp	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl_symbols.cpp	2017-09-26 08:07:37.473423345 +0000
@@ -111,16 +111,16 @@
 DEFINEFUNC2(int, ASN1_STRING_to_UTF8, unsigned char **a, a, ASN1_STRING *b, b, return 0, return);
 DEFINEFUNC4(long, BIO_ctrl, BIO *a, a, int b, b, long c, c, void *d, d, return -1, return)
 DEFINEFUNC(int, BIO_free, BIO *a, a, return 0, return)
-DEFINEFUNC(BIO *, BIO_new, BIO_METHOD *a, a, return 0, return)
+DEFINEFUNC(BIO *, BIO_new, const BIO_METHOD *a, a, return 0, return)
 DEFINEFUNC2(BIO *, BIO_new_mem_buf, void *a, a, int b, b, return 0, return)
 DEFINEFUNC3(int, BIO_read, BIO *a, a, void *b, b, int c, c, return -1, return)
-DEFINEFUNC(BIO_METHOD *, BIO_s_mem, void, DUMMYARG, return 0, return)
+DEFINEFUNC(const BIO_METHOD *, BIO_s_mem, void, DUMMYARG, return 0, return)
 DEFINEFUNC3(int, BIO_write, BIO *a, a, const void *b, b, int c, c, return -1, return)
 DEFINEFUNC(int, BN_num_bits, const BIGNUM *a, a, return 0, return)
 DEFINEFUNC(int, CRYPTO_num_locks, DUMMYARG, DUMMYARG, return 0, return)
 DEFINEFUNC(void, CRYPTO_set_locking_callback, void (*a)(int, int, const char *, int), a, return, DUMMYARG)
 DEFINEFUNC(void, CRYPTO_set_id_callback, unsigned long (*a)(), a, return, DUMMYARG)
-DEFINEFUNC(void, CRYPTO_free, void *a, a, return, DUMMYARG)
+DEFINEFUNC(void, OPENSSL_free, void *a, a, return, DUMMYARG)
 DEFINEFUNC(void, DSA_free, DSA *a, a, return, DUMMYARG)
 #if  OPENSSL_VERSION_NUMBER < 0x00908000L
 DEFINEFUNC3(X509 *, d2i_X509, X509 **a, a, unsigned char **b, b, long c, c, return 0, return)
@@ -228,13 +228,17 @@
 #ifndef OPENSSL_NO_SSL2
 DEFINEFUNC(const SSL_METHOD *, SSLv2_client_method, DUMMYARG, DUMMYARG, return 0, return)
 #endif
+#ifndef OPENSSL_NO_SSL3
 DEFINEFUNC(const SSL_METHOD *, SSLv3_client_method, DUMMYARG, DUMMYARG, return 0, return)
+#endif
 DEFINEFUNC(const SSL_METHOD *, SSLv23_client_method, DUMMYARG, DUMMYARG, return 0, return)
 DEFINEFUNC(const SSL_METHOD *, TLSv1_client_method, DUMMYARG, DUMMYARG, return 0, return)
 #ifndef OPENSSL_NO_SSL2
 DEFINEFUNC(const SSL_METHOD *, SSLv2_server_method, DUMMYARG, DUMMYARG, return 0, return)
 #endif
+#ifndef OPENSSL_NO_SSL3
 DEFINEFUNC(const SSL_METHOD *, SSLv3_server_method, DUMMYARG, DUMMYARG, return 0, return)
+#endif
 DEFINEFUNC(const SSL_METHOD *, SSLv23_server_method, DUMMYARG, DUMMYARG, return 0, return)
 DEFINEFUNC(const SSL_METHOD *, TLSv1_server_method, DUMMYARG, DUMMYARG, return 0, return)
 #else
@@ -286,6 +290,22 @@
 DEFINEFUNC(void, OPENSSL_add_all_algorithms_conf, void, DUMMYARG, return, DUMMYARG)
 DEFINEFUNC3(int, SSL_CTX_load_verify_locations, SSL_CTX *ctx, ctx, const char *CAfile, CAfile, const char *CApath, CApath, return 0, return)
 DEFINEFUNC(long, SSLeay, void, DUMMYARG, return 0, return)
+DEFINEFUNC(X509_STORE *, SSL_CTX_get_cert_store, const SSL_CTX *ctx, ctx, return 0, return)
+
+DEFINEFUNC(ASN1_INTEGER *, X509_get_serialNumber, X509 *x, x, return 0, return)
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+DEFINEFUNC(int, EVP_PKEY_id, const EVP_PKEY *pkey, pkey, return 0, return)
+DEFINEFUNC(int, EVP_PKEY_base_id, const EVP_PKEY *pkey, pkey, return 0, return)
+DEFINEFUNC2(int, SSL_CIPHER_get_bits, const SSL_CIPHER *cipher, cipher, int *alg_bits, alg_bits, return 0, return)
+DEFINEFUNC2(long, SSL_CTX_set_options, SSL_CTX *ctx, ctx, long options, options, return 0, return)
+DEFINEFUNC(long, X509_get_version, X509 *x, x, return 0, return)
+DEFINEFUNC(X509_PUBKEY *, X509_get_X509_PUBKEY, X509 *x, x, return 0, return)
+DEFINEFUNC(int, RSA_bits,  const RSA *rsa, rsa, return 0, return)
+DEFINEFUNC(int, DSA_security_bits, const DSA *dsa, dsa, return 0, return)
+DEFINEFUNC(ASN1_TIME *, X509_get_notAfter, X509 *x, x, return 0, return)
+DEFINEFUNC(ASN1_TIME *, X509_get_notBefore, X509 *x, x, return 0, return)
+DEFINEFUNC4(void, DSA_get0_pqg, const DSA *d, d, const BIGNUM **p, p, const BIGNUM **q, q, const BIGNUM **g, g, return, return)
+#endif
 
 #ifdef Q_OS_SYMBIAN
 #define RESOLVEFUNC(func, ordinal, lib) \
@@ -797,6 +817,7 @@
     RESOLVEFUNC(SSL_CTX_use_PrivateKey)
     RESOLVEFUNC(SSL_CTX_use_RSAPrivateKey)
     RESOLVEFUNC(SSL_CTX_use_PrivateKey_file)
+    RESOLVEFUNC(SSL_CTX_get_cert_store)
     RESOLVEFUNC(SSL_accept)
     RESOLVEFUNC(SSL_clear)
     RESOLVEFUNC(SSL_connect)
@@ -819,16 +840,37 @@
     RESOLVEFUNC(SSL_set_connect_state)
     RESOLVEFUNC(SSL_shutdown)
     RESOLVEFUNC(SSL_write)
+
+    RESOLVEFUNC(X509_get_serialNumber)
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    RESOLVEFUNC(SSL_CTX_ctrl)
+    RESOLVEFUNC(EVP_PKEY_id)
+    RESOLVEFUNC(EVP_PKEY_base_id)
+    RESOLVEFUNC(SSL_CIPHER_get_bits)
+    RESOLVEFUNC(SSL_CTX_set_options)
+    RESOLVEFUNC(X509_get_version)
+    RESOLVEFUNC(X509_get_X509_PUBKEY)
+    RESOLVEFUNC(RSA_bits)
+    RESOLVEFUNC(DSA_security_bits)
+    RESOLVEFUNC(DSA_get0_pqg)
+    RESOLVEFUNC(X509_get_notAfter)
+    RESOLVEFUNC(X509_get_notBefore)
+#endif
+
 #ifndef OPENSSL_NO_SSL2
     RESOLVEFUNC(SSLv2_client_method)
 #endif
+#ifndef OPENSSL_NO_SSL3
     RESOLVEFUNC(SSLv3_client_method)
+#endif
     RESOLVEFUNC(SSLv23_client_method)
     RESOLVEFUNC(TLSv1_client_method)
 #ifndef OPENSSL_NO_SSL2
     RESOLVEFUNC(SSLv2_server_method)
 #endif
+#ifndef OPENSSL_NO_SSL3
     RESOLVEFUNC(SSLv3_server_method)
+#endif
     RESOLVEFUNC(SSLv23_server_method)
     RESOLVEFUNC(TLSv1_server_method)
     RESOLVEFUNC(X509_NAME_entry_count)
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl_symbols_p.h qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl_symbols_p.h
--- qt-everywhere-opensource-src-4.8.7-original/src/network/ssl/qsslsocket_openssl_symbols_p.h	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/network/ssl/qsslsocket_openssl_symbols_p.h	2017-09-26 08:07:37.476756678 +0000
@@ -59,6 +59,9 @@
 QT_BEGIN_NAMESPACE
 
 #define DUMMYARG
+#ifndef OPENSSL_NO_SSL2
+#define OPENSSL_NO_SSL2 1
+#endif
 
 #if !defined QT_LINKED_OPENSSL
 // **************** Shared declarations ******************
@@ -207,16 +210,16 @@
 int q_ASN1_STRING_to_UTF8(unsigned char **a, ASN1_STRING *b);
 long q_BIO_ctrl(BIO *a, int b, long c, void *d);
 int q_BIO_free(BIO *a);
-BIO *q_BIO_new(BIO_METHOD *a);
+BIO *q_BIO_new(const BIO_METHOD *a);
 BIO *q_BIO_new_mem_buf(void *a, int b);
 int q_BIO_read(BIO *a, void *b, int c);
-BIO_METHOD *q_BIO_s_mem();
+const BIO_METHOD *q_BIO_s_mem();
 int q_BIO_write(BIO *a, const void *b, int c);
 int q_BN_num_bits(const BIGNUM *a);
 int q_CRYPTO_num_locks();
 void q_CRYPTO_set_locking_callback(void (*a)(int, int, const char *, int));
 void q_CRYPTO_set_id_callback(unsigned long (*a)());
-void q_CRYPTO_free(void *a);
+void q_OPENSSL_free(void *a);
 void q_DSA_free(DSA *a);
 #if OPENSSL_VERSION_NUMBER >= 0x00908000L
 // 0.9.8 broke SC and BC by changing this function's signature.
@@ -326,7 +329,6 @@
 void q_SSL_set_connect_state(SSL *a);
 int q_SSL_shutdown(SSL *a);
 #if OPENSSL_VERSION_NUMBER >= 0x10000000L
-const SSL_METHOD *q_SSLv2_client_method();
 const SSL_METHOD *q_SSLv3_client_method();
 const SSL_METHOD *q_SSLv23_client_method();
 const SSL_METHOD *q_TLSv1_client_method();
@@ -335,7 +337,6 @@
 const SSL_METHOD *q_SSLv23_server_method();
 const SSL_METHOD *q_TLSv1_server_method();
 #else
-SSL_METHOD *q_SSLv2_client_method();
 SSL_METHOD *q_SSLv3_client_method();
 SSL_METHOD *q_SSLv23_client_method();
 SSL_METHOD *q_TLSv1_client_method();
@@ -399,7 +400,25 @@
 		PEM_ASN1_write_bio((int (*)(void*, unsigned char**))q_i2d_DSAPrivateKey,PEM_STRING_DSA,\
 			bp,(char *)x,enc,kstr,klen,cb,u)
 #endif
+
+X509_STORE * q_SSL_CTX_get_cert_store(const SSL_CTX *ctx);
+ASN1_INTEGER * q_X509_get_serialNumber(X509 *x);
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 #define q_SSL_CTX_set_options(ctx,op) q_SSL_CTX_ctrl((ctx),SSL_CTRL_OPTIONS,(op),NULL)
+#define q_X509_get_version(x) X509_get_version(x)
+#else
+int q_EVP_PKEY_id(const EVP_PKEY *pkey);
+int q_EVP_PKEY_base_id(const EVP_PKEY *pkey);
+int q_SSL_CIPHER_get_bits(const SSL_CIPHER *cipher, int *alg_bits);
+long q_SSL_CTX_set_options(SSL_CTX *ctx, long options);
+long q_X509_get_version(X509 *x);
+X509_PUBKEY * q_X509_get_X509_PUBKEY(X509 *x);
+int q_RSA_bits(const RSA *rsa);
+int q_DSA_security_bits(const DSA *dsa);
+void q_DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
+#endif
+
 #define q_SKM_sk_num(type, st) ((int (*)(const STACK_OF(type) *))q_sk_num)(st)
 #define q_SKM_sk_value(type, st,i) ((type * (*)(const STACK_OF(type) *, int))q_sk_value)(st, i)
 #define q_sk_GENERAL_NAME_num(st) q_SKM_sk_num(GENERAL_NAME, (st))
@@ -410,8 +429,15 @@
 #define q_sk_SSL_CIPHER_value(st, i) q_SKM_sk_value(SSL_CIPHER, (st), (i))
 #define q_SSL_CTX_add_extra_chain_cert(ctx,x509) \
         q_SSL_CTX_ctrl(ctx,SSL_CTRL_EXTRA_CHAIN_CERT,0,(char *)x509)
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 #define q_X509_get_notAfter(x) X509_get_notAfter(x)
 #define q_X509_get_notBefore(x) X509_get_notBefore(x)
+#else
+ASN1_TIME *q_X509_get_notAfter(X509 *x);
+ASN1_TIME *q_X509_get_notBefore(X509 *x);
+#endif
+
 #define q_EVP_PKEY_assign_RSA(pkey,rsa) q_EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\
 					(char *)(rsa))
 #define q_EVP_PKEY_assign_DSA(pkey,dsa) q_EVP_PKEY_assign((pkey),EVP_PKEY_DSA,\
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/tools/moc/main.cpp qt-everywhere-opensource-src-4.8.7/src/tools/moc/main.cpp
--- qt-everywhere-opensource-src-4.8.7-original/src/tools/moc/main.cpp	2015-05-07 14:14:44.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/tools/moc/main.cpp	2017-09-26 08:07:13.030089179 +0000
@@ -188,8 +188,12 @@
     pp.macros["Q_MOC_RUN"];
     pp.macros["__cplusplus"];
 
-    // Workaround a bug while parsing the boost/type_traits/has_operator.hpp header. See QTBUG-22829
+    // Workaround a bugs while parsing some boost headers. See QTBUG-22829 
     pp.macros["BOOST_TT_HAS_OPERATOR_HPP_INCLUDED"];
+    pp.macros["BOOST_LEXICAL_CAST_INCLUDED"];
+    pp.macros["BOOST_NEXT_PRIOR_HPP_INCLUDED"];
+    pp.macros["BOOST_TYPE_TRAITS_HPP"];
+    pp.macros["_SYS_SYSMACROS_H_OUTER"];
 
     QByteArray filename;
     QByteArray output;
diff -Naur qt-everywhere-opensource-src-4.8.7-original/src/xmlpatterns/api/qcoloroutput_p.h qt-everywhere-opensource-src-4.8.7/src/xmlpatterns/api/qcoloroutput_p.h
--- qt-everywhere-opensource-src-4.8.7-original/src/xmlpatterns/api/qcoloroutput_p.h	2015-05-07 14:14:48.000000000 +0000
+++ qt-everywhere-opensource-src-4.8.7/src/xmlpatterns/api/qcoloroutput_p.h	2017-09-26 08:07:04.650088893 +0000
@@ -70,8 +70,8 @@
             ForegroundShift = 10,
             BackgroundShift = 20,
             SpecialShift    = 20,
-            ForegroundMask  = ((1 << ForegroundShift) - 1) << ForegroundShift,
-            BackgroundMask  = ((1 << BackgroundShift) - 1) << BackgroundShift
+            ForegroundMask  = 0x1f << ForegroundShift,
+            BackgroundMask  = 0x7 << BackgroundShift
         };
 
     public:
